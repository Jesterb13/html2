<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB Translator v9.9.0 Web</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/xml.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        * { font-family: 'Inter', sans-serif; }
        .gradient-bg { background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%); }
        .card-gradient { background: linear-gradient(145deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.03) 100%); backdrop-filter: blur(10px); }
        .glow { box-shadow: 0 0 40px rgba(99, 102, 241, 0.3); }
        .glow-green { box-shadow: 0 0 30px rgba(34, 197, 94, 0.3); }
        .glow-orange { box-shadow: 0 0 30px rgba(249, 115, 22, 0.3); }
        .feature-icon { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); }
        .pulse-dot { animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.1); } }
        .progress-bar { background: linear-gradient(90deg, #6366f1, #8b5cf6, #a855f7); background-size: 200% 100%; animation: shimmer 2s infinite; }
        @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
        .tab-active { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); }
        .log-container { font-family: 'Consolas', 'Monaco', monospace; background: #0d1117; border: 1px solid rgba(99, 102, 241, 0.3); }
        .log-entry { border-bottom: 1px solid rgba(255,255,255,0.05); }
        .key-item { transition: all 0.2s; }
        .key-item:hover { background: rgba(99, 102, 241, 0.2); }
        .provider-btn.active { border-color: #6366f1; background: rgba(99, 102, 241, 0.2); }
        .model-btn.active { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); }
        .badge-free { background: linear-gradient(135deg, #22c55e, #16a34a); }
        .badge-paid { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .badge-thinking { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .badge-local { background: linear-gradient(135deg, #06b6d4, #0891b2); }
        .status-ok { color: #22c55e; }
        .status-warn { color: #f59e0b; }
        .status-error { color: #ef4444; }
        .status-pending { color: #6b7280; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background: rgba(99, 102, 241, 0.5); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(99, 102, 241, 0.7); }
        .chapter-row:hover { background: rgba(99, 102, 241, 0.1); }
        .chapter-row.selected { background: rgba(99, 102, 241, 0.2); border-left: 3px solid #6366f1; }
        .diff-added { background: rgba(34, 197, 94, 0.2); }
        .diff-removed { background: rgba(239, 68, 68, 0.2); }
        .split-view { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
        @media (max-width: 1024px) { .split-view { grid-template-columns: 1fr; } }
        .punct-dash { color: #f59e0b; font-weight: bold; }
        .punct-quote { color: #22c55e; font-weight: bold; }
        .punct-operator { color: #ec4899; font-weight: bold; background: rgba(236, 72, 153, 0.2); }
        .punct-forbidden { color: #ef4444; font-weight: bold; background: rgba(239, 68, 68, 0.3); text-decoration: underline wavy; }
        .code-view { font-family: 'Consolas', 'Monaco', monospace; font-size: 13px; }
        .code-view .hljs { background: transparent !important; }
        .conflict-direct { border-left: 3px solid #ef4444; }
        .conflict-overlap { border-left: 3px solid #f59e0b; }
        .conflict-reverse { border-left: 3px solid #8b5cf6; }
        .prompt-preview { font-family: 'Consolas', monospace; font-size: 12px; white-space: pre-wrap; word-break: break-word; }
    </style>
</head>
<body class="gradient-bg min-h-screen text-white">
    <header class="fixed top-0 left-0 right-0 z-50 bg-black/40 backdrop-blur-xl border-b border-white/10">
        <div class="max-w-7xl mx-auto px-4 py-3">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-xl feature-icon flex items-center justify-center">
                        <i class="fas fa-book-open text-white"></i>
                    </div>
                    <span class="text-xl font-bold">EPUB Translator</span>
                    <span class="px-2 py-1 bg-indigo-500/30 rounded-full text-xs font-medium">v9.9.0 Web</span>
                </div>
                <div class="flex items-center gap-4">
                    <div id="status-indicator" class="flex items-center gap-2 text-sm">
                        <span class="w-2 h-2 bg-gray-500 rounded-full"></span>
                        <span class="text-gray-400">Не настроено</span>
                    </div>
                    <button onclick="showProjectHistory()" class="text-gray-400 hover:text-white transition" title="История проектов">
                        <i class="fas fa-history"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main class="pt-20 pb-10 px-4">
        <div class="max-w-7xl mx-auto">
            <div class="flex gap-2 mb-6 overflow-x-auto pb-2">
                <button onclick="switchTab('translate')" id="tab-translate" class="tab-active px-6 py-3 rounded-xl font-medium transition flex items-center gap-2 whitespace-nowrap">
                    <i class="fas fa-language"></i> Перевод
                </button>
                <button onclick="switchTab('validator')" id="tab-validator" class="bg-white/10 hover:bg-white/20 px-6 py-3 rounded-xl font-medium transition flex items-center gap-2 whitespace-nowrap">
                    <i class="fas fa-check-double"></i> Валидатор
                </button>
                <button onclick="switchTab('keys')" id="tab-keys" class="bg-white/10 hover:bg-white/20 px-6 py-3 rounded-xl font-medium transition flex items-center gap-2 whitespace-nowrap">
                    <i class="fas fa-key"></i> API Ключи
                </button>
                <button onclick="switchTab('settings')" id="tab-settings" class="bg-white/10 hover:bg-white/20 px-6 py-3 rounded-xl font-medium transition flex items-center gap-2 whitespace-nowrap">
                    <i class="fas fa-cog"></i> Настройки
                </button>
                <button onclick="switchTab('glossary')" id="tab-glossary" class="bg-white/10 hover:bg-white/20 px-6 py-3 rounded-xl font-medium transition flex items-center gap-2 whitespace-nowrap">
                    <i class="fas fa-book"></i> Глоссарий
                </button>
                <button onclick="switchTab('prompt')" id="tab-prompt" class="bg-white/10 hover:bg-white/20 px-6 py-3 rounded-xl font-medium transition flex items-center gap-2 whitespace-nowrap">
                    <i class="fas fa-scroll"></i> Промпт
                </button>
                <button onclick="switchTab('doctor')" id="tab-doctor" class="bg-white/10 hover:bg-white/20 px-6 py-3 rounded-xl font-medium transition flex items-center gap-2 whitespace-nowrap">
                    <i class="fas fa-stethoscope"></i> Доктор
                </button>
            </div>

            <div id="panel-translate" class="tab-panel">
                <div class="grid lg:grid-cols-3 gap-6">
                    <div class="lg:col-span-2 space-y-6">
                        <div class="card-gradient rounded-2xl p-4 border border-white/10">
                            <div class="flex flex-wrap items-center gap-4">
                                <div class="flex items-center gap-2">
                                    <span class="text-gray-400">Провайдер:</span>
                                    <span id="current-provider" class="font-medium text-indigo-400">Не выбран</span>
                                </div>
                                <div class="w-px h-6 bg-white/20 hidden sm:block"></div>
                                <div class="flex items-center gap-2">
                                    <span class="text-gray-400">Модель:</span>
                                    <span id="current-model" class="font-medium text-purple-400">Не выбрана</span>
                                </div>
                                <div class="w-px h-6 bg-white/20 hidden sm:block"></div>
                                <div class="flex items-center gap-2">
                                    <span class="text-gray-400">Ключей:</span>
                                    <span id="current-keys-count" class="font-medium text-green-400">0</span>
                                </div>
                                <div class="w-px h-6 bg-white/20 hidden sm:block"></div>
                                <div class="flex items-center gap-2">
                                    <span class="text-gray-400">RPD:</span>
                                    <span id="rpd-info" class="font-medium text-yellow-400">-</span>
                                </div>
                            </div>
                        </div>

                        <div id="upload-area" class="card-gradient rounded-2xl p-12 border-2 border-dashed border-white/30 hover:border-indigo-500 transition cursor-pointer text-center"
                             ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)"
                             onclick="document.getElementById('file-input').click()">
                            <i class="fas fa-cloud-upload-alt text-5xl text-gray-400 mb-4"></i>
                            <p class="text-xl font-medium mb-2">Перетащите EPUB файл сюда</p>
                            <p class="text-gray-400">или нажмите для выбора</p>
                            <input type="file" accept=".epub" class="hidden" id="file-input" onchange="handleFileSelect(event)">
                        </div>

                        <div id="file-info" class="hidden card-gradient rounded-2xl p-6 border border-white/10">
                            <div class="flex items-center justify-between mb-4">
                                <div class="flex items-center gap-3">
                                    <div class="w-12 h-12 rounded-xl bg-indigo-500/30 flex items-center justify-center">
                                        <i class="fas fa-file-alt text-xl text-indigo-400"></i>
                                    </div>
                                    <div>
                                        <p id="file-name" class="font-medium">filename.epub</p>
                                        <p id="file-size" class="text-sm text-gray-400">0 KB</p>
                                    </div>
                                </div>
                                <button onclick="clearFile()" class="text-gray-400 hover:text-red-400 transition">
                                    <i class="fas fa-times text-xl"></i>
                                </button>
                            </div>
                            <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 text-sm">
                                <div class="bg-white/5 rounded-lg p-3">
                                    <div class="text-gray-400">Глав</div>
                                    <div id="chapter-count" class="font-medium">-</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3">
                                    <div class="text-gray-400">Символов</div>
                                    <div id="char-count" class="font-medium">-</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3">
                                    <div class="text-gray-400">Токенов (≈)</div>
                                    <div id="token-estimate" class="font-medium">-</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3">
                                    <div class="text-gray-400">Стоимость (≈)</div>
                                    <div id="cost-estimate" class="font-medium">-</div>
                                </div>
                            </div>

                            <div class="mt-4 p-4 bg-white/5 rounded-xl">
                                <div class="flex items-center gap-4 mb-3">
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" id="partial-translation" class="w-4 h-4 rounded" onchange="togglePartialTranslation()">
                                        <span class="text-sm">Частичный перевод (выбрать главы)</span>
                                    </label>
                                </div>
                                <div id="chapter-range" class="hidden grid grid-cols-2 gap-4">
                                    <div>
                                        <label class="text-xs text-gray-400">С главы</label>
                                        <input type="number" id="start-chapter" min="1" value="1" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1">
                                    </div>
                                    <div>
                                        <label class="text-xs text-gray-400">По главу</label>
                                        <input type="number" id="end-chapter" min="1" value="1" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1">
                                    </div>
                                </div>
                            </div>

                            <button id="start-btn" onclick="startTranslation()" class="mt-6 w-full py-4 bg-indigo-600 hover:bg-indigo-700 rounded-xl font-semibold transition flex items-center justify-center gap-2 glow">
                                <i class="fas fa-play"></i> Начать перевод
                            </button>
                        </div>

                        <div id="progress-panel" class="hidden card-gradient rounded-2xl p-6 border border-white/10">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="font-semibold text-lg">Прогресс перевода</h3>
                                <div class="flex gap-2">
                                    <button id="pause-btn" onclick="pauseTranslation()" class="px-4 py-2 bg-yellow-500/20 hover:bg-yellow-500/30 text-yellow-400 rounded-lg transition">
                                        <i class="fas fa-pause mr-2"></i>Пауза
                                    </button>
                                    <button id="cancel-btn" onclick="cancelTranslation()" class="px-4 py-2 bg-red-500/20 hover:bg-red-500/30 text-red-400 rounded-lg transition">
                                        <i class="fas fa-stop mr-2"></i>Отмена
                                    </button>
                                </div>
                            </div>
                            <div class="mb-4">
                                <div class="flex justify-between text-sm mb-2">
                                    <span id="progress-status">Инициализация...</span>
                                    <span id="progress-percent">0%</span>
                                </div>
                                <div class="h-3 bg-white/10 rounded-full overflow-hidden">
                                    <div id="progress-bar" class="progress-bar h-full rounded-full transition-all duration-300" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 sm:grid-cols-5 gap-4 text-sm">
                                <div class="bg-white/5 rounded-lg p-3">
                                    <div class="text-gray-400">Глава</div>
                                    <div id="current-chapter" class="font-medium">0/0</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3">
                                    <div class="text-gray-400">Токены (вход)</div>
                                    <div id="tokens-in" class="font-medium">0</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3">
                                    <div class="text-gray-400">Токены (выход)</div>
                                    <div id="tokens-out" class="font-medium">0</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3">
                                    <div class="text-gray-400">Время</div>
                                    <div id="elapsed-time" class="font-medium">00:00</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3">
                                    <div class="text-gray-400">Ключ</div>
                                    <div id="current-key-index" class="font-medium">1/1</div>
                                </div>
                            </div>
                        </div>

                        <div id="result-panel" class="hidden card-gradient rounded-2xl p-6 border border-green-500/30 glow-green">
                            <div class="text-center mb-6">
                                <div class="w-16 h-16 mx-auto rounded-full bg-green-500 flex items-center justify-center mb-4">
                                    <i class="fas fa-check text-2xl"></i>
                                </div>
                                <h3 class="text-xl font-bold">Перевод завершён!</h3>
                            </div>
                            <div id="result-stats" class="grid grid-cols-2 sm:grid-cols-4 gap-4 text-sm mb-6"></div>
                            <div class="flex flex-col sm:flex-row gap-4">
                                <button onclick="downloadEpub()" class="flex-1 py-3 bg-indigo-600 hover:bg-indigo-700 rounded-xl font-medium transition flex items-center justify-center gap-2">
                                    <i class="fas fa-download"></i> Скачать EPUB
                                </button>
                                <button onclick="downloadGlossary()" class="flex-1 py-3 bg-white/10 hover:bg-white/20 rounded-xl font-medium transition flex items-center justify-center gap-2">
                                    <i class="fas fa-book"></i> Скачать глоссарий
                                </button>
                                <button onclick="openInValidator()" class="flex-1 py-3 bg-orange-500/20 hover:bg-orange-500/30 text-orange-400 rounded-xl font-medium transition flex items-center justify-center gap-2">
                                    <i class="fas fa-check-double"></i> Проверить
                                </button>
                            </div>
                            <button onclick="resetTranslation()" class="mt-4 w-full py-3 text-indigo-400 hover:text-indigo-300 transition">
                                <i class="fas fa-redo mr-2"></i>Перевести ещё
                            </button>
                        </div>
                    </div>

                    <div class="lg:col-span-1">
                        <div class="card-gradient rounded-2xl border border-white/10 h-full flex flex-col">
                            <div class="p-4 border-b border-white/10 flex items-center justify-between">
                                <h3 class="font-semibold flex items-center gap-2">
                                    <i class="fas fa-terminal text-indigo-400"></i> Лог
                                </h3>
                                <div class="flex gap-2">
                                    <button onclick="downloadLog()" class="text-gray-400 hover:text-white transition text-sm" title="Скачать лог">
                                        <i class="fas fa-download"></i>
                                    </button>
                                    <button onclick="clearLog()" class="text-gray-400 hover:text-white transition text-sm">Очистить</button>
                                </div>
                            </div>
                            <div id="log-container" class="log-container flex-1 p-4 overflow-y-auto max-h-[500px] lg:max-h-[600px] text-sm space-y-1">
                                <div class="text-gray-500">Лог пуст. Загрузите файл для начала.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="panel-validator" class="tab-panel hidden">
                <div class="grid lg:grid-cols-4 gap-6">
                    <div class="lg:col-span-1">
                        <div class="card-gradient rounded-2xl border border-white/10 h-full flex flex-col">
                            <div class="p-4 border-b border-white/10">
                                <h3 class="font-semibold flex items-center gap-2 mb-3">
                                    <i class="fas fa-list text-indigo-400"></i> Главы
                                </h3>
                                <div class="flex gap-2">
                                    <button onclick="loadProjectForValidation()" class="flex-1 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm transition">
                                        <i class="fas fa-folder-open mr-1"></i> Загрузить
                                    </button>
                                </div>
                            </div>
                            <div id="validator-chapters" class="flex-1 overflow-y-auto max-h-[500px] p-2 space-y-1">
                                <p class="text-gray-400 text-sm text-center py-8">Загрузите проект для проверки</p>
                            </div>
                            <div class="p-4 border-t border-white/10">
                                <div class="flex justify-between text-sm text-gray-400 mb-2">
                                    <span>Проверено:</span>
                                    <span id="validated-count">0/0</span>
                                </div>
                                <div class="h-2 bg-white/10 rounded-full overflow-hidden">
                                    <div id="validation-progress" class="bg-green-500 h-full transition-all" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="lg:col-span-3">
                        <div class="card-gradient rounded-2xl border border-white/10 p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="font-semibold flex items-center gap-2">
                                    <i class="fas fa-columns text-indigo-400"></i> Сравнение
                                    <span id="current-chapter-name" class="text-gray-400 font-normal ml-2"></span>
                                </h3>
                                <div class="flex gap-2">
                                    <div class="flex bg-white/10 rounded-lg p-0.5 mr-2">
                                        <button onclick="setValidatorViewMode('text')" id="view-text" class="px-3 py-1 rounded text-sm bg-indigo-600">Текст</button>
                                        <button onclick="setValidatorViewMode('code')" id="view-code" class="px-3 py-1 rounded text-sm hover:bg-white/10">Код</button>
                                        <button onclick="setValidatorViewMode('punct')" id="view-punct" class="px-3 py-1 rounded text-sm hover:bg-white/10">Пунктуация</button>
                                    </div>
                                    <button onclick="prevChapterValidator()" class="px-3 py-1 bg-white/10 hover:bg-white/20 rounded-lg transition"><i class="fas fa-chevron-left"></i></button>
                                    <button onclick="nextChapterValidator()" class="px-3 py-1 bg-white/10 hover:bg-white/20 rounded-lg transition"><i class="fas fa-chevron-right"></i></button>
                                    <button onclick="markAsValidated()" class="px-4 py-1 bg-green-600 hover:bg-green-700 rounded-lg transition text-sm"><i class="fas fa-check mr-1"></i> Подтвердить</button>
                                    <button onclick="retryChapter()" class="px-4 py-1 bg-orange-500/20 hover:bg-orange-500/30 text-orange-400 rounded-lg transition text-sm"><i class="fas fa-redo mr-1"></i> Переперевести</button>
                                </div>
                            </div>

                            <div class="split-view">
                                <div>
                                    <div class="text-sm text-gray-400 mb-2 flex items-center gap-2"><i class="fas fa-file-alt"></i> Оригинал</div>
                                    <div id="original-content" class="bg-white/5 rounded-xl p-4 h-[500px] overflow-y-auto text-sm leading-relaxed"><p class="text-gray-500">Выберите главу для просмотра</p></div>
                                </div>
                                <div>
                                    <div class="text-sm text-gray-400 mb-2 flex items-center gap-2"><i class="fas fa-language"></i> Перевод <span id="translation-status" class="ml-auto"></span></div>
                                    <div id="translated-content" class="bg-white/5 rounded-xl p-4 h-[500px] overflow-y-auto text-sm leading-relaxed"><p class="text-gray-500">Выберите главу для просмотра</p></div>
                                </div>
                            </div>

                            <div id="issues-panel" class="hidden mt-4 p-4 bg-orange-500/10 border border-orange-500/30 rounded-xl">
                                <h4 class="font-medium text-orange-400 mb-2 flex items-center gap-2"><i class="fas fa-exclamation-triangle"></i> Найденные проблемы</h4>
                                <div id="issues-list" class="space-y-2 text-sm"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="panel-keys" class="tab-panel hidden">
                <div class="grid lg:grid-cols-3 gap-6">
                    <div class="lg:col-span-1">
                        <div class="card-gradient rounded-2xl p-6 border border-white/10">
                            <h3 class="font-semibold text-lg mb-4 flex items-center gap-2"><i class="fas fa-plus-circle text-indigo-400"></i> Добавить ключи</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm text-gray-400 mb-2">Провайдер</label>
                                    <select id="key-provider-select" onchange="updateKeyProviderInfo()" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition"></select>
                                </div>
                                <div id="key-provider-info" class="bg-white/5 rounded-xl p-4 text-sm"></div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-2">API Ключи (по одному на строку)</label>
                                    <textarea id="keys-input" rows="5" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition resize-none" placeholder="AIzaSy...\nsk-or-...\nhf_..."></textarea>
                                </div>
                                <button onclick="addKeys()" class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 rounded-xl font-medium transition"><i class="fas fa-plus mr-2"></i> Добавить ключи</button>
                            </div>
                        </div>
                    </div>
                    <div class="lg:col-span-2">
                        <div class="card-gradient rounded-2xl p-6 border border-white/10">
                            <h3 class="font-semibold text-lg mb-4 flex items-center gap-2"><i class="fas fa-list text-indigo-400"></i> Сохранённые ключи</h3>
                            <div id="keys-list" class="space-y-4"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="panel-settings" class="tab-panel hidden">
                <div class="grid lg:grid-cols-2 gap-6">
                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <h3 class="font-semibold text-lg mb-4 flex items-center gap-2"><i class="fas fa-server text-indigo-400"></i> Выбор провайдера</h3>
                        <div id="provider-list" class="space-y-3"></div>
                    </div>

                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <h3 class="font-semibold text-lg mb-4 flex items-center gap-2"><i class="fas fa-robot text-indigo-400"></i> Выбор модели</h3>
                        <div id="model-list" class="space-y-3 max-h-[400px] overflow-y-auto"><p class="text-gray-400">Сначала выберите провайдера</p></div>
                    </div>

                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <h3 class="font-semibold text-lg mb-4 flex items-center gap-2"><i class="fas fa-sliders-h text-indigo-400"></i> Параметры перевода</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm text-gray-400 mb-2">Размер чанка (символов)</label>
                                <input type="number" id="chunk-size" value="50000" min="10000" max="200000" step="5000" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-2">Максимум терминов в глоссарии</label>
                                <input type="number" id="max-glossary-terms" value="60" min="20" max="150" step="10" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-2">Макс. повторов на ключ</label>
                                <input type="number" id="max-retries" value="2" min="1" max="5" step="1" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-2">Параллельных воркеров (по ключам)</label>
                                <input type="number" id="num-instances" value="1" min="1" max="20" step="1" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition">
                                <p class="text-xs text-gray-500 mt-1">Обычно: 1 воркер = 1 API ключ. Для локальных моделей значение игнорируется.</p>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-sm">Создавать глоссарий</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="create-glossary" checked class="sr-only peer">
                                    <div class="w-11 h-6 bg-white/20 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-sm">Сохранять оригинал при цензуре</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="keep-censored" checked class="sr-only peer">
                                    <div class="w-11 h-6 bg-white/20 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-sm">Автосохранение после каждой главы</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="auto-save" checked class="sr-only peer">
                                    <div class="w-11 h-6 bg-white/20 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-sm">Batching (объединять маленькие главы)</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="enable-batching" class="sr-only peer">
                                    <div class="w-11 h-6 bg-white/20 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                                </label>
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-2">Лимит batching (символов)</label>
                                <input type="number" id="batching-max-chars" value="120000" min="30000" max="300000" step="5000" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition">
                                <p class="text-xs text-gray-500 mt-1">Собирает несколько маленьких глав в один запрос (с маркерами). Если ответ не делится — будет fallback на одиночный режим.</p>
                            </div>
                        </div>
                    </div>

                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <h3 class="font-semibold text-lg mb-4 flex items-center gap-2"><i class="fas fa-database text-indigo-400"></i> Управление данными</h3>
                        <div class="space-y-4">
                            <button onclick="exportSettings()" class="w-full py-3 bg-white/10 hover:bg-white/20 rounded-xl font-medium transition flex items-center justify-center gap-2"><i class="fas fa-download"></i> Экспорт настроек</button>
                            <button onclick="document.getElementById('import-input').click()" class="w-full py-3 bg-white/10 hover:bg-white/20 rounded-xl font-medium transition flex items-center justify-center gap-2"><i class="fas fa-upload"></i> Импорт настроек</button>
                            <input type="file" id="import-input" accept=".json" class="hidden" onchange="importSettings(event)">

                            <div class="h-px bg-white/10"></div>

                            <button onclick="exportProject()" class="w-full py-3 bg-indigo-600/20 hover:bg-indigo-600/30 text-indigo-200 rounded-xl font-medium transition flex items-center justify-center gap-2">
                                <i class="fas fa-file-export"></i> Экспорт проекта (перевод+глоссарий)
                            </button>
                            <button onclick="document.getElementById('project-import-input').click()" class="w-full py-3 bg-indigo-600/20 hover:bg-indigo-600/30 text-indigo-200 rounded-xl font-medium transition flex items-center justify-center gap-2">
                                <i class="fas fa-file-import"></i> Импорт проекта
                            </button>
                            <input type="file" id="project-import-input" accept=".json" class="hidden" onchange="importProjectFile(event)">

                            <div class="h-px bg-white/10"></div>

                            <button onclick="clearProjectHistory()" class="w-full py-3 bg-yellow-500/20 hover:bg-yellow-500/30 text-yellow-400 rounded-xl font-medium transition flex items-center justify-center gap-2"><i class="fas fa-history"></i> Очистить историю проектов</button>
                            <button onclick="clearAllData()" class="w-full py-3 bg-red-500/20 hover:bg-red-500/30 text-red-400 rounded-xl font-medium transition flex items-center justify-center gap-2"><i class="fas fa-trash"></i> Очистить все данные</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="panel-glossary" class="tab-panel hidden">
                <div class="grid lg:grid-cols-3 gap-6">
                    <div class="lg:col-span-2">
                        <div class="card-gradient rounded-2xl p-6 border border-white/10">
                            <div class="flex items-center justify-between mb-6">
                                <h3 class="font-semibold text-lg flex items-center gap-2"><i class="fas fa-book text-indigo-400"></i> Глоссарий терминов <span id="glossary-count" class="text-sm text-gray-400">(0 терминов)</span></h3>
                                <div class="flex gap-2">
                                    <button onclick="analyzeGlossaryConflicts()" class="px-4 py-2 bg-orange-500/20 hover:bg-orange-500/30 text-orange-400 rounded-lg transition text-sm"><i class="fas fa-search mr-1"></i> Анализ</button>
                                    <button onclick="showGlossaryResolverModal()" class="px-4 py-2 bg-emerald-500/20 hover:bg-emerald-500/30 text-emerald-200 rounded-lg transition text-sm"><i class="fas fa-diagram-project mr-1"></i> Резолвер</button>
                                    <button onclick="showGroupAnalyzerModal()" class="px-4 py-2 bg-sky-500/20 hover:bg-sky-500/30 text-sky-200 rounded-lg transition text-sm"><i class="fas fa-layer-group mr-1"></i> Группы</button>
                                    <button onclick="showGlossaryGeneratorModal()" class="px-4 py-2 bg-indigo-500/20 hover:bg-indigo-500/30 text-indigo-200 rounded-lg transition text-sm"><i class="fas fa-microchip mr-1"></i> AI‑генерация</button>
                                    <button onclick="showGlossaryCorrectorModal()" class="px-4 py-2 bg-purple-500/20 hover:bg-purple-500/30 text-purple-200 rounded-lg transition text-sm"><i class="fas fa-wand-magic-sparkles mr-1"></i> AI‑корректор</button>
                                    <button onclick="document.getElementById('glossary-import').click()" class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition text-sm"><i class="fas fa-upload mr-1"></i> Импорт</button>
                                    <input type="file" id="glossary-import" accept=".json,.txt" class="hidden" onchange="importGlossary(event)">
                                    <button onclick="clearGlossary()" class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition text-sm">Очистить</button>
                                    <button onclick="downloadGlossary()" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg transition text-sm"><i class="fas fa-download mr-2"></i>Скачать</button>
                                </div>
                            </div>

                            <div id="glossary-conflicts" class="hidden mb-4 p-4 bg-orange-500/10 border border-orange-500/30 rounded-xl">
                                <h4 class="font-medium text-orange-400 mb-2 flex items-center gap-2"><i class="fas fa-exclamation-triangle"></i> Найденные конфликты</h4>
                                <div id="conflicts-list" class="space-y-2 text-sm max-h-[200px] overflow-y-auto"></div>
                            </div>

                            <div id="glossary-content" class="space-y-3 max-h-[500px] overflow-y-auto">
                                <p class="text-gray-400 text-center py-8">Глоссарий будет создан после начала перевода</p>
                            </div>
                        </div>
                    </div>

                    <div class="lg:col-span-1">
                        <div class="card-gradient rounded-2xl p-6 border border-white/10">
                            <h3 class="font-semibold text-lg mb-4 flex items-center gap-2"><i class="fas fa-plus-circle text-indigo-400"></i> Добавить термин</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm text-gray-400 mb-2">Оригинал</label>
                                    <input type="text" id="new-term-original" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition" placeholder="Wei Wuxian">
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-2">Перевод</label>
                                    <input type="text" id="new-term-translation" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition" placeholder="Вэй Усянь">
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-2">Примечание</label>
                                    <input type="text" id="new-term-note" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition" placeholder="Персонаж; Мужчина; Склоняется">
                                </div>
                                <button onclick="addGlossaryTerm()" class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 rounded-xl font-medium transition"><i class="fas fa-plus mr-2"></i> Добавить</button>
                            </div>
                        </div>

                        <div class="card-gradient rounded-2xl p-6 border border-white/10 mt-6">
                            <h3 class="font-semibold text-lg mb-4 flex items-center gap-2"><i class="fas fa-search text-indigo-400"></i> Поиск</h3>
                            <input type="text" id="glossary-search" oninput="searchGlossary()" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition" placeholder="Поиск по термину...">
                        </div>
                    </div>
                </div>
            </div>

            <div id="panel-prompt" class="tab-panel hidden">
                <div class="grid lg:grid-cols-2 gap-6">
                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="font-semibold text-lg flex items-center gap-2"><i class="fas fa-user-cog text-indigo-400"></i> Системная инструкция</h3>
                            <div class="flex gap-2">
                                <select id="system-prompt-preset" onchange="loadSystemPromptPreset()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-1 text-sm">
                                    <option value="">— Пресет —</option>
                                    <option value="literary">Литературный</option>
                                    <option value="technical">Технический</option>
                                    <option value="fantasy">Фэнтези</option>
                                    <option value="wuxia">Культивация/Уся</option>
                                </select>
                            </div>
                        </div>
                        <p class="text-sm text-gray-400 mb-4">Высокоуровневая инструкция, определяющая роль и личность AI на протяжении всей сессии.</p>
                        <textarea id="system-prompt" rows="10" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition resize-none font-mono text-sm" placeholder="Ты — профессиональный литературный переводчик..."></textarea>
                    </div>

                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="font-semibold text-lg flex items-center gap-2"><i class="fas fa-language text-indigo-400"></i> Промпт перевода</h3>
                            <button onclick="resetTranslationPrompt()" class="text-sm text-gray-400 hover:text-white transition"><i class="fas fa-undo mr-1"></i> Сбросить</button>
                        </div>
                        <p class="text-sm text-gray-400 mb-4">Инструкция для перевода каждой главы. Переменные: <code class="bg-white/10 px-1 rounded">{glossary}</code>, <code class="bg-white/10 px-1 rounded">{text}</code></p>
                        <textarea id="translation-prompt" rows="10" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition resize-none font-mono text-sm"></textarea>
                    </div>

                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="font-semibold text-lg flex items-center gap-2"><i class="fas fa-book-open text-indigo-400"></i> Промпт глоссария</h3>
                            <button onclick="resetGlossaryPrompt()" class="text-sm text-gray-400 hover:text-white transition"><i class="fas fa-undo mr-1"></i> Сбросить</button>
                        </div>
                        <p class="text-sm text-gray-400 mb-4">Инструкция для создания глоссария из первых глав. Переменная: <code class="bg-white/10 px-1 rounded">{text}</code></p>
                        <textarea id="glossary-prompt" rows="10" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition resize-none font-mono text-sm"></textarea>
                    </div>

                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <h3 class="font-semibold text-lg mb-4 flex items-center gap-2"><i class="fas fa-flask text-indigo-400"></i> Пробный запуск (Dry Run)</h3>
                        <p class="text-sm text-gray-400 mb-4">Просмотрите финальный промпт перед отправкой. Полезно для отладки и тестирования с внешними моделями.</p>
                        <div class="space-y-4">
                            <button onclick="showDryRunModal()" class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 rounded-xl font-medium transition flex items-center justify-center gap-2" id="dry-run-btn" disabled>
                                <i class="fas fa-eye"></i> Просмотреть промпт
                            </button>
                            <p class="text-xs text-gray-500 text-center">Загрузите EPUB файл для активации</p>
                        </div>
                    </div>
                </div>
            </div>

            <div id="panel-doctor" class="tab-panel hidden">
                <div class="grid lg:grid-cols-2 gap-6">
                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="font-semibold text-lg flex items-center gap-2"><i class="fas fa-microscope text-indigo-400"></i> Микроскоп (prettify HTML)</h3>
                            <button onclick="doctorCopyOutput()" class="text-sm text-gray-400 hover:text-white transition"><i class="fas fa-copy mr-1"></i> Копировать результат</button>
                        </div>
                        <p class="text-sm text-gray-400 mb-4">Безопасная «косметика» для HTML/XHTML: нормализация переносов строк и отступов без попытки «чинить» структуру.</p>
                        <div class="grid grid-cols-1 gap-4">
                            <div>
                                <label class="block text-xs text-gray-400 mb-2">Вход (грязный HTML)</label>
                                <textarea id="doctor-input" rows="10" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition resize-none font-mono text-sm" placeholder="Вставьте HTML/XHTML сюда..."></textarea>
                            </div>
                            <div class="flex gap-2">
                                <button onclick="doctorPrettifyFragment()" class="flex-1 py-3 bg-indigo-600 hover:bg-indigo-700 rounded-xl font-medium transition"><i class="fas fa-wand-magic-sparkles mr-2"></i> Prettify</button>
                                <button onclick="doctorClearFragment()" class="px-5 py-3 bg-white/10 hover:bg-white/20 rounded-xl font-medium transition">Очистить</button>
                            </div>
                            <div>
                                <label class="block text-xs text-gray-400 mb-2">Выход</label>
                                <textarea id="doctor-output" rows="10" readonly class="w-full bg-black/20 border border-white/10 rounded-xl px-4 py-3 resize-none font-mono text-sm text-gray-200" placeholder="Здесь появится результат..."></textarea>
                            </div>
                        </div>
                    </div>

                    <div class="card-gradient rounded-2xl p-6 border border-white/10">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="font-semibold text-lg flex items-center gap-2"><i class="fas fa-book-medical text-indigo-400"></i> EPUB Doctor (массовое prettify)</h3>
                            <span class="text-xs text-gray-500">Создаёт *_prettified.epub</span>
                        </div>
                        <p class="text-sm text-gray-400 mb-4">Обрабатывает все <code class="bg-white/10 px-1 rounded">.html/.xhtml/.htm</code> внутри EPUB и собирает новый файл.</p>

                        <input type="file" id="doctor-epub-input" accept=".epub" class="hidden" onchange="doctorHandleEpub(event)">

                        <div class="flex flex-col sm:flex-row gap-3 mb-4">
                            <button onclick="document.getElementById('doctor-epub-input').click()" class="flex-1 py-3 bg-indigo-600 hover:bg-indigo-700 rounded-xl font-medium transition flex items-center justify-center gap-2">
                                <i class="fas fa-file-upload"></i> Выбрать EPUB
                            </button>
                            <button id="doctor-download-btn" onclick="doctorDownloadEpub()" disabled class="flex-1 py-3 bg-green-600/20 hover:bg-green-600/30 text-green-400 rounded-xl font-medium transition flex items-center justify-center gap-2 disabled:opacity-40 disabled:cursor-not-allowed">
                                <i class="fas fa-download"></i> Скачать результат
                            </button>
                        </div>

                        <div class="bg-white/5 rounded-xl p-4 border border-white/10 mb-4">
                            <div class="flex items-center justify-between text-sm">
                                <span class="text-gray-400">Файл:</span>
                                <span id="doctor-epub-filename" class="font-medium text-gray-200">—</span>
                            </div>
                            <div class="mt-3 h-2 bg-white/10 rounded-full overflow-hidden">
                                <div id="doctor-epub-progress" class="bg-indigo-500 h-full transition-all" style="width: 0%"></div>
                            </div>
                            <div class="flex justify-between text-xs text-gray-500 mt-2">
                                <span id="doctor-epub-status">Ожидание</span>
                                <span id="doctor-epub-percent">0%</span>
                            </div>
                        </div>

                        <div id="doctor-epub-log" class="log-container rounded-xl p-4 max-h-[320px] overflow-y-auto text-sm">
                            <div class="text-gray-500">Выберите EPUB для начала.</div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </main>

    <div id="project-history-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="card-gradient rounded-2xl border border-white/10 max-w-2xl w-full max-h-[80vh] flex flex-col">
            <div class="p-6 border-b border-white/10 flex items-center justify-between">
                <h3 class="font-semibold text-lg flex items-center gap-2"><i class="fas fa-history text-indigo-400"></i> История проектов</h3>
                <button onclick="hideProjectHistory()" class="text-gray-400 hover:text-white transition"><i class="fas fa-times text-xl"></i></button>
            </div>
            <div id="project-history-list" class="flex-1 overflow-y-auto p-4 space-y-3"><p class="text-gray-400 text-center py-8">История пуста</p></div>
        </div>
    </div>

    <div id="dry-run-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="card-gradient rounded-2xl border border-white/10 max-w-4xl w-full max-h-[90vh] flex flex-col">
            <div class="p-6 border-b border-white/10 flex items-center justify-between">
                <h3 class="font-semibold text-lg flex items-center gap-2"><i class="fas fa-flask text-indigo-400"></i> Пробный запуск — Просмотр промпта</h3>
                <button onclick="hideDryRunModal()" class="text-gray-400 hover:text-white transition"><i class="fas fa-times text-xl"></i></button>
            </div>
            <div class="flex-1 overflow-y-auto p-4">
                <div class="mb-4 flex gap-2">
                    <select id="dry-run-chapter" class="flex-1 bg-white/10 border border-white/20 rounded-lg px-4 py-2"><option value="0">Глава 1</option></select>
                    <button onclick="generateDryRunPrompt()" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg transition"><i class="fas fa-sync mr-1"></i> Сгенерировать</button>
                </div>
                <div id="dry-run-content" class="bg-black/30 rounded-xl p-4 prompt-preview max-h-[400px] overflow-y-auto text-gray-300">Выберите главу и нажмите "Сгенерировать"</div>
            </div>
            <div class="p-4 border-t border-white/10 flex flex-wrap gap-3">
                <button onclick="copyDryRunPrompt()" class="flex-1 py-3 bg-white/10 hover:bg-white/20 rounded-xl font-medium transition flex items-center justify-center gap-2"><i class="fas fa-copy"></i> Копировать промпт</button>
                <button onclick="showManualResponseInput()" class="flex-1 py-3 bg-orange-500/20 hover:bg-orange-500/30 text-orange-400 rounded-xl font-medium transition flex items-center justify-center gap-2"><i class="fas fa-edit"></i> Ручной ответ</button>
                <button onclick="hideDryRunModal()" class="px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded-xl font-medium transition">Закрыть</button>
            </div>
            <div id="manual-response-section" class="hidden p-4 border-t border-white/10">
                <h4 class="font-medium mb-2 flex items-center gap-2"><i class="fas fa-keyboard text-indigo-400"></i> Вставьте ответ от внешней модели:</h4>
                <textarea id="manual-response-input" rows="6" class="w-full bg-white/10 border border-white/20 rounded-xl px-4 py-3 focus:outline-none focus:border-indigo-500 transition resize-none font-mono text-sm" placeholder="Вставьте переведённый HTML сюда..."></textarea>
                <div class="mt-3 flex gap-2">
                    <button onclick="applyManualResponse()" class="flex-1 py-2 bg-green-600 hover:bg-green-700 rounded-lg font-medium transition"><i class="fas fa-check mr-1"></i> Применить как перевод</button>
                    <button onclick="hideManualResponseInput()" class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition">Отмена</button>
                </div>
            </div>
        </div>
    </div>

    <div id="toast-container" class="fixed bottom-4 right-4 z-50 space-y-2"></div>

    <!-- Glossary AI Generator Modal -->
    <div id="glossary-generator-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="card-gradient rounded-2xl border border-white/10 max-w-5xl w-full max-h-[90vh] flex flex-col">
            <div class="p-6 border-b border-white/10 flex items-center justify-between">
                <h3 class="font-semibold text-lg flex items-center gap-2">
                    <i class="fas fa-microchip text-indigo-300"></i> AI‑генерация глоссария
                </h3>
                <button onclick="hideGlossaryGeneratorModal()" class="text-gray-400 hover:text-white transition"><i class="fas fa-times text-xl"></i></button>
            </div>

            <div class="flex-1 overflow-y-auto p-6 space-y-5">
                <div class="grid lg:grid-cols-3 gap-4">
                    <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="text-sm text-gray-400 mb-2">Источник текста</div>
                        <p class="text-xs text-gray-500 mb-3">Генерация идёт из выбранных глав EPUB (нужно загрузить книгу во вкладке «Перевод»).</p>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="block text-xs text-gray-400">С главы</label>
                                <input type="number" id="gg-start" min="1" value="1" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-400">По главу</label>
                                <input type="number" id="gg-end" min="1" value="1" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1">
                            </div>
                        </div>
                        <div class="mt-3 text-xs text-gray-500" id="gg-total-info">—</div>
                    </div>

                    <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="text-sm text-gray-400 mb-2">Режим слияния</div>
                        <div class="space-y-2">
                            <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="gg-merge" value="supplement" checked class="w-4 h-4"><span class="text-sm">Дополнить (только новые)</span></label>
                            <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="gg-merge" value="update" class="w-4 h-4"><span class="text-sm">Обновить (перезапись)</span></label>
                            <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="gg-merge" value="accumulate" class="w-4 h-4"><span class="text-sm">Накопить (всё подряд)</span></label>
                        </div>
                        <div class="mt-3 flex items-center justify-between gap-3">
                            <span class="text-sm">Включать примечания</span>
                            <input type="checkbox" id="gg-include-notes" class="w-4 h-4" checked>
                        </div>
                    </div>

                    <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="text-sm text-gray-400 mb-2">Действия</div>
                        <div class="space-y-3">
                            <button onclick="glossaryGeneratorBuildPreview()" class="w-full py-2.5 bg-white/10 hover:bg-white/20 rounded-lg transition">
                                <i class="fas fa-eye mr-2"></i>Собрать превью
                            </button>
                            <button onclick="glossaryGeneratorRun()" class="w-full py-2.5 bg-indigo-600 hover:bg-indigo-700 rounded-lg transition font-medium">
                                <i class="fas fa-rocket mr-2"></i>Сгенерировать
                            </button>
                        </div>
                        <div class="mt-3">
                            <label class="block text-xs text-gray-400 mb-1">Порог размера (≈ токены)</label>
                            <input type="number" id="gg-token-limit" value="60000" min="5000" step="5000" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2">
                            <p class="text-xs text-gray-500 mt-1">Если превью больше лимита — уменьшите диапазон глав.</p>
                        </div>
                    </div>
                </div>

                <div class="grid lg:grid-cols-2 gap-4">
                    <div class="bg-black/30 rounded-xl p-4 border border-white/10">
                        <div class="flex items-center justify-between mb-2">
                            <div class="text-sm text-gray-300 flex items-center gap-2"><i class="fas fa-scroll"></i> Превью запроса</div>
                            <button onclick="glossaryGeneratorCopyPreview()" class="text-xs text-gray-400 hover:text-white transition"><i class="fas fa-copy mr-1"></i>Копировать</button>
                        </div>
                        <pre id="gg-preview" class="prompt-preview text-gray-300 max-h-[260px] overflow-y-auto">Нажмите «Собрать превью»</pre>
                        <div id="gg-preview-warn" class="hidden mt-3 text-sm bg-yellow-500/10 border border-yellow-500/30 text-yellow-200 rounded-lg p-3"></div>
                    </div>

                    <div class="bg-black/30 rounded-xl p-4 border border-white/10">
                        <div class="flex items-center justify-between mb-2">
                            <div class="text-sm text-gray-300 flex items-center gap-2"><i class="fas fa-list"></i> Результат (термины)</div>
                            <div class="flex gap-2">
                                <button onclick="glossaryGeneratorMergeResult()" class="text-xs bg-green-600/20 hover:bg-green-600/30 text-green-200 px-2 py-1 rounded transition"><i class="fas fa-check mr-1"></i>Применить</button>
                            </div>
                        </div>
                        <textarea id="gg-result" rows="12" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 font-mono text-xs text-gray-200 resize-none" placeholder="Здесь появится JSON словарь терминов от AI..."></textarea>
                        <p class="text-xs text-gray-500 mt-2">«Применить» объединит результат с вашим глоссарием согласно выбранному режиму.</p>
                    </div>
                </div>

                <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                    <div class="text-sm text-gray-300 flex items-center gap-2 mb-2"><i class="fas fa-info-circle"></i> Примечание</div>
                    <ul class="text-sm text-gray-400 list-disc pl-5 space-y-1">
                        <li>Это web‑упрощение desktop‑диалога <code class="bg-white/10 px-1 rounded">ai_generation.py</code>.</li>
                        <li>Для лучшего качества используйте 1–3 главы и включённые примечания.</li>
                        <li>Результат должен быть JSON формата <code class="bg-white/10 px-1 rounded">{"Term": {"translation":"…","note":"…"}}</code>.</li>
                    </ul>
                </div>
            </div>

            <div class="p-4 border-t border-white/10 flex justify-end gap-2">
                <button onclick="hideGlossaryGeneratorModal()" class="px-5 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition">Закрыть</button>
            </div>
        </div>
    </div>

    <!-- Glossary AI Corrector Modal -->
    <div id="glossary-corrector-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="card-gradient rounded-2xl border border-white/10 max-w-5xl w-full max-h-[90vh] flex flex-col">
            <div class="p-6 border-b border-white/10 flex items-center justify-between">
                <h3 class="font-semibold text-lg flex items-center gap-2">
                    <i class="fas fa-wand-magic-sparkles text-purple-300"></i> AI‑корректор глоссария
                </h3>
                <button onclick="hideGlossaryCorrectorModal()" class="text-gray-400 hover:text-white transition"><i class="fas fa-times text-xl"></i></button>
            </div>

            <div class="flex-1 overflow-y-auto p-6 space-y-5">
                <div class="grid lg:grid-cols-3 gap-4">
                    <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="text-sm text-gray-400 mb-2">Источник данных</div>
                        <div class="space-y-3">
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="gc-source" value="conflicts" checked class="w-4 h-4">
                                <span class="text-sm">Только проблемные (конфликты/наложения)</span>
                            </label>
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="gc-source" value="all" class="w-4 h-4">
                                <span class="text-sm">Весь глоссарий (осторожно: большой промпт)</span>
                            </label>
                        </div>
                    </div>

                    <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="text-sm text-gray-400 mb-2">Оптимизация</div>
                        <div class="space-y-3">
                            <label class="flex items-center justify-between gap-3">
                                <span class="text-sm">Игнорировать примечания (экономия токенов)</span>
                                <input type="checkbox" id="gc-no-notes" class="w-4 h-4">
                            </label>
                            <label class="flex items-center justify-between gap-3">
                                <span class="text-sm">Разрешить добавление новых терминов</span>
                                <input type="checkbox" id="gc-allow-additions" class="w-4 h-4" checked>
                            </label>
                            <div>
                                <label class="block text-xs text-gray-400 mb-1">Порог размера запроса (≈ токены)</label>
                                <input type="number" id="gc-token-limit" value="60000" min="5000" step="5000" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2">
                                <p class="text-xs text-gray-500 mt-1">Если превью промпта больше лимита — предложит сузить входные данные.</p>
                            </div>
                        </div>
                    </div>

                    <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="text-sm text-gray-400 mb-2">Действия</div>
                        <div class="space-y-3">
                            <button onclick="glossaryCorrectorBuildPreview()" class="w-full py-2.5 bg-white/10 hover:bg-white/20 rounded-lg transition">
                                <i class="fas fa-eye mr-2"></i>Собрать превью
                            </button>
                            <button onclick="glossaryCorrectorRun()" class="w-full py-2.5 bg-purple-600 hover:bg-purple-700 rounded-lg transition font-medium">
                                <i class="fas fa-rocket mr-2"></i>Запустить коррекцию
                            </button>
                        </div>
                    </div>
                </div>

                <div class="grid lg:grid-cols-2 gap-4">
                    <div class="bg-black/30 rounded-xl p-4 border border-white/10">
                        <div class="flex items-center justify-between mb-2">
                            <div class="text-sm text-gray-300 flex items-center gap-2"><i class="fas fa-scroll"></i> Превью запроса</div>
                            <button onclick="glossaryCorrectorCopyPreview()" class="text-xs text-gray-400 hover:text-white transition"><i class="fas fa-copy mr-1"></i>Копировать</button>
                        </div>
                        <pre id="gc-preview" class="prompt-preview text-gray-300 max-h-[260px] overflow-y-auto">Нажмите «Собрать превью»</pre>
                        <div id="gc-preview-warn" class="hidden mt-3 text-sm bg-yellow-500/10 border border-yellow-500/30 text-yellow-200 rounded-lg p-3"></div>
                    </div>

                    <div class="bg-black/30 rounded-xl p-4 border border-white/10">
                        <div class="flex items-center justify-between mb-2">
                            <div class="text-sm text-gray-300 flex items-center gap-2"><i class="fas fa-code"></i> Патч (JSON)</div>
                            <div class="flex gap-2">
                                <button onclick="glossaryCorrectorCopyPatch()" class="text-xs text-gray-400 hover:text-white transition"><i class="fas fa-copy mr-1"></i>Копировать</button>
                                <button onclick="glossaryCorrectorApplyPatch()" class="text-xs bg-green-600/20 hover:bg-green-600/30 text-green-200 px-2 py-1 rounded transition"><i class="fas fa-check mr-1"></i>Применить</button>
                            </div>
                        </div>
                        <textarea id="gc-patch" rows="12" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 font-mono text-xs text-gray-200 resize-none" placeholder="Здесь появится JSON‑патч от AI..."></textarea>
                        <p class="text-xs text-gray-500 mt-2">Применение обновит глоссарий в приложении (вы сможете откатить через Экспорт/Импорт проекта).</p>
                    </div>
                </div>

                <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                    <div class="text-sm text-gray-300 flex items-center gap-2 mb-2"><i class="fas fa-info-circle"></i> Как это работает</div>
                    <ul class="text-sm text-gray-400 list-disc pl-5 space-y-1">
                        <li>Собираем входные данные: либо весь глоссарий, либо только конфликтные/наложения.</li>
                        <li>Формируем промпт «исправь/унифицируй переводы» и просим вернуть JSON‑патч.</li>
                        <li>Вы можете вручную отредактировать патч и применить его.</li>
                    </ul>
                </div>
            </div>

            <div class="p-4 border-t border-white/10 flex justify-end gap-2">
                <button onclick="hideGlossaryCorrectorModal()" class="px-5 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition">Закрыть</button>
            </div>
        </div>
    </div>

    <!-- Glossary Manual Resolver Modal (desktop-inspired conflict_resolvers.py) -->
    <!-- Group Analyzer Modal (web port of group_analyzer.py) -->
    <div id="group-analyzer-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="card-gradient rounded-2xl border border-white/10 max-w-6xl w-full max-h-[90vh] flex flex-col">
            <div class="p-6 border-b border-white/10 flex items-center justify-between">
                <h3 class="font-semibold text-lg flex items-center gap-2">
                    <i class="fas fa-layer-group text-sky-300"></i> Анализ групп терминов
                </h3>
                <button onclick="hideGroupAnalyzerModal()" class="text-gray-400 hover:text-white transition"><i class="fas fa-times text-xl"></i></button>
            </div>

            <div class="flex-1 overflow-y-auto p-6 space-y-4">
                <div class="grid lg:grid-cols-4 gap-4">
                    <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="text-sm text-gray-400 mb-2">Фильтры</div>
                        <div class="space-y-3">
                            <div>
                                <label class="block text-xs text-gray-400">Мин. длина слова</label>
                                <input type="number" id="ga-min-len" min="1" max="20" value="3" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-400">Частота от</label>
                                <input type="number" id="ga-min-count" min="1" value="3" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-400">Частота до</label>
                                <input type="number" id="ga-max-count" min="1" value="10" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1">
                                <p class="text-xs text-gray-500 mt-1">Авто: max(10, 30% терминов)</p>
                            </div>
                            <button onclick="groupAnalyzerRefresh(true)" class="w-full py-2.5 bg-white/10 hover:bg-white/20 rounded-lg transition">
                                <i class="fas fa-arrows-rotate mr-2"></i>Обновить список
                            </button>
                        </div>
                    </div>

                    <div class="lg:col-span-3 bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="flex items-center justify-between mb-3">
                            <div class="text-sm text-gray-300">Группы</div>
                            <div class="text-xs text-gray-500" id="ga-summary">—</div>
                        </div>

                        <div class="overflow-x-auto rounded-xl border border-white/10">
                            <table class="min-w-full text-sm">
                                <thead class="bg-white/5 text-gray-300">
                                    <tr>
                                        <th class="px-3 py-2 text-left w-10"><input id="ga-select-all" type="checkbox" class="w-4 h-4"></th>
                                        <th class="px-3 py-2 text-left">Слово (маркер)</th>
                                        <th class="px-3 py-2 text-left w-24">Записей</th>
                                        <th class="px-3 py-2 text-left">Примеры</th>
                                    </tr>
                                </thead>
                                <tbody id="ga-table" class="divide-y divide-white/10"></tbody>
                            </table>
                        </div>

                        <div class="mt-4 flex flex-wrap items-center gap-2">
                            <button onclick="groupAnalyzerOpenEditor()" class="px-4 py-2 bg-sky-600 hover:bg-sky-700 rounded-lg font-medium transition">
                                <i class="fas fa-pen-to-square mr-2"></i>Открыть редактор для выбранных
                            </button>
                            <button onclick="hideGroupAnalyzerModal()" class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition">Закрыть</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Group Editor Modal (subset editor for Group Analyzer) -->
    <div id="group-editor-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="card-gradient rounded-2xl border border-white/10 max-w-6xl w-full max-h-[90vh] flex flex-col">
            <div class="p-6 border-b border-white/10 flex items-center justify-between gap-3">
                <div>
                    <h3 class="font-semibold text-lg flex items-center gap-2"><i class="fas fa-pen-to-square text-sky-300"></i> Редактор групп</h3>
                    <div class="text-xs text-gray-500" id="ge-title">—</div>
                </div>
                <button onclick="hideGroupEditorModal()" class="text-gray-400 hover:text-white transition"><i class="fas fa-times text-xl"></i></button>
            </div>

            <div class="flex-1 overflow-y-auto p-6 space-y-4">
                <div class="grid lg:grid-cols-3 gap-4">
                    <div class="bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="text-sm text-gray-300 mb-2">Поиск</div>
                        <input id="ge-search" type="text" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2" placeholder="Фильтр по оригиналу/переводу/примечанию..." oninput="groupEditorRender()">
                        <div class="mt-3 text-xs text-gray-500" id="ge-summary">—</div>
                        <div class="mt-4 flex gap-2">
                            <button onclick="groupEditorSelectAll(true)" class="flex-1 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition text-sm">Выбрать все</button>
                            <button onclick="groupEditorSelectAll(false)" class="flex-1 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition text-sm">Снять</button>
                        </div>
                        <div class="mt-4">
                            <button onclick="groupEditorMarkDeleteSelected()" class="w-full py-2 bg-red-500/20 hover:bg-red-500/30 text-red-200 rounded-lg transition text-sm"><i class="fas fa-trash mr-2"></i>Удалить выбранные</button>
                        </div>
                    </div>

                    <div class="lg:col-span-2 bg-white/5 rounded-xl p-4 border border-white/10">
                        <div class="text-sm text-gray-300 mb-2">Массовое редактирование (Regex)</div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                            <div>
                                <label class="block text-xs text-gray-400">Поле</label>
                                <select id="ge-field" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1">
                                    <option value="original">Оригинал</option>
                                    <option value="translation" selected>Перевод</option>
                                    <option value="note">Примечание</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs text-gray-400">Найти (regex)</label>
                                <input id="ge-find" type="text" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1" placeholder="Напр. \"\bthe\b\"">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-400">Заменить</label>
                                <input id="ge-replace" type="text" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 mt-1" placeholder="...">
                            </div>
                        </div>
                        <div class="mt-3 flex gap-2">
                            <button onclick="groupEditorApplyRegex()" class="px-4 py-2 bg-sky-600 hover:bg-sky-700 rounded-lg transition font-medium"><i class="fas fa-wand-magic-sparkles mr-2"></i>Применить к выбранным</button>
                            <button onclick="groupEditorUndo()" class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition"><i class="fas fa-rotate-left mr-2"></i>Откатить</button>
                        </div>
                    </div>
                </div>

                <div class="bg-white/5 rounded-xl border border-white/10 overflow-hidden">
                    <div class="p-4 border-b border-white/10 flex items-center justify-between">
                        <div class="text-sm text-gray-300">Термины</div>
                        <div class="text-xs text-gray-500">Подсказка: редактируйте поля прямо в таблице</div>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="min-w-full text-sm">
                            <thead class="bg-white/5 text-gray-300">
                                <tr>
                                    <th class="px-3 py-2 w-10"><input id="ge-select-all" type="checkbox" class="w-4 h-4" onchange="groupEditorToggleAllVisible(this.checked)"></th>
                                    <th class="px-3 py-2 text-left">Оригинал</th>
                                    <th class="px-3 py-2 text-left">Перевод</th>
                                    <th class="px-3 py-2 text-left">Примечание</th>
                                    <th class="px-3 py-2 w-20">Удалить</th>
                                </tr>
                            </thead>
                            <tbody id="ge-table" class="divide-y divide-white/10"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="p-4 border-t border-white/10 flex flex-wrap gap-2 justify-end">
                <button onclick="groupEditorApplyChanges()" class="px-5 py-2 bg-green-600 hover:bg-green-700 rounded-lg font-medium transition"><i class="fas fa-check mr-2"></i>Применить</button>
                <button onclick="hideGroupEditorModal()" class="px-5 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition">Закрыть</button>
            </div>
        </div>
    </div>

    <div id="glossary-resolver-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="card-gradient rounded-2xl border border-white/10 max-w-6xl w-full max-h-[90vh] flex flex-col">
            <div class="p-6 border-b border-white/10 flex items-center justify-between">
                <h3 class="font-semibold text-lg flex items-center gap-2">
                    <i class="fas fa-diagram-project text-emerald-300"></i> Резолвер конфликтов глоссария
                </h3>
                <button onclick="hideGlossaryResolverModal()" class="text-gray-400 hover:text-white transition"><i class="fas fa-times text-xl"></i></button>
            </div>

            <div class="flex-1 overflow-y-auto p-6">
                <div class="grid lg:grid-cols-5 gap-4">
                    <!-- Left: groups list -->
                    <div class="lg:col-span-2 bg-white/5 rounded-xl border border-white/10 overflow-hidden flex flex-col">
                        <div class="p-4 border-b border-white/10 space-y-3">
                            <div class="flex items-center gap-2">
                                <label class="text-xs text-gray-400">Режим</label>
                                <select id="gr-mode" class="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                    <option value="reverse">Обратные конфликты (один перевод → разные оригиналы)</option>
                                    <option value="overlap">Наложения (термин внутри другого)</option>
                                    <option value="direct">Дубликаты/версии (Term и Term#2)</option>
                                </select>
                            </div>
                            <div class="flex items-center gap-2">
                                <input id="gr-search" type="text" class="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm" placeholder="Поиск по группам...">
                                <button id="gr-toggle-view" onclick="glossaryResolverToggleOverlapView()" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded-lg text-sm transition" title="Переключить вид наложений" disabled>
                                    <i class="fas fa-exchange-alt"></i>
                                </button>
                            </div>
                            <div class="flex items-center justify-between gap-3">
                                <div class="text-xs text-gray-500" id="gr-summary">—</div>
                                <label class="flex items-center gap-2 text-sm cursor-pointer">
                                    <input type="checkbox" id="gr-wizard" class="w-4 h-4">
                                    <span class="text-xs text-gray-300">Визард</span>
                                </label>
                            </div>
                            <div id="gr-wizard-controls" class="hidden flex gap-2">
                                <button onclick="glossaryResolverWizardPrev()" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded-lg text-sm transition"><i class="fas fa-chevron-left mr-1"></i>Назад</button>
                                <button onclick="glossaryResolverWizardNext()" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded-lg text-sm transition">Далее<i class="fas fa-chevron-right ml-1"></i></button>
                            </div>
                        </div>
                        <div id="gr-list" class="p-2 overflow-y-auto max-h-[60vh] space-y-1">
                            <div class="text-gray-500 text-sm text-center py-10">Нет данных</div>
                        </div>
                    </div>

                    <!-- Right: editor -->
                    <div class="lg:col-span-3 bg-white/5 rounded-xl border border-white/10 overflow-hidden flex flex-col">
                        <div class="p-4 border-b border-white/10 flex items-start justify-between gap-3">
                            <div>
                                <div class="text-sm text-gray-400">Группа</div>
                                <div id="gr-current-title" class="font-semibold">—</div>
                                <div id="gr-current-subtitle" class="text-xs text-gray-500 mt-1">—</div>
                            </div>
                            <div class="flex items-center gap-2">
                                <label class="flex items-center gap-2 cursor-pointer text-sm">
                                    <input type="checkbox" id="gr-checked" class="w-4 h-4">
                                    <span class="text-gray-300">Проверено</span>
                                </label>
                                <button onclick="glossaryResolverApplyEdits()" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded-lg font-medium transition text-sm">
                                    <i class="fas fa-check mr-1"></i> Применить
                                </button>
                            </div>
                        </div>

                        <div class="p-4 overflow-y-auto max-h-[60vh]">
                            <div id="gr-editor" class="text-sm text-gray-400">Выберите группу слева.</div>
                        </div>

                        <div class="p-4 border-t border-white/10 text-xs text-gray-500">
                            Подсказка: изменения применяются к текущему глоссарию в приложении. Для отката используйте «Экспорт проекта».
                        </div>
                    </div>
                </div>
            </div>

            <div class="p-4 border-t border-white/10 flex justify-end gap-2">
                <button onclick="hideGlossaryResolverModal()" class="px-5 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition">Закрыть</button>
            </div>
        </div>
    </div>

    <!-- Основной JS приложения (интегрированный) -->
    <script id="app-js">
        // =============================================
        // CUSTOM ERRORS (Aligned with desktop error taxonomy)
        // =============================================
        class ContentBlockedError extends Error { constructor(message = 'Content blocked') { super(message); this.name = 'ContentBlockedError'; } }
        class AllKeysExhaustedError extends Error { constructor(message = 'All keys exhausted') { super(message); this.name = 'AllKeysExhaustedError'; } }
        class TemporaryRateLimitError extends Error { constructor(message = 'Temporary rate limit', delayMs = 60000) { super(message); this.name = 'TemporaryRateLimitError'; this.delayMs = delayMs; } }
        class RateLimitExceededError extends Error { constructor(message = 'Rate limit exceeded') { super(message); this.name = 'RateLimitExceededError'; } }
        class ModelNotFoundError extends Error { constructor(message = 'Model not found') { super(message); this.name = 'ModelNotFoundError'; } }
        class NetworkError extends Error { constructor(message = 'Network error', delayMs = 30000) { super(message); this.name = 'NetworkError'; this.delayMs = delayMs; } }
        class OperationCancelledError extends Error { constructor(message = 'Cancelled') { super(message); this.name = 'OperationCancelledError'; } }

        // =============================================
        // ASYNC MUTEX (Thread Safety)
        // =============================================
        class AsyncMutex {
            constructor() { this._locked = false; this._queue = []; }
            async acquire() {
                return new Promise(resolve => {
                    if (!this._locked) { this._locked = true; resolve(); }
                    else { this._queue.push(resolve); }
                });
            }
            release() {
                if (this._queue.length > 0) { this._queue.shift()(); }
                else { this._locked = false; }
            }
            async withLock(fn) {
                await this.acquire();
                try { return await fn(); } finally { this.release(); }
            }
        }

        // =============================================
        // EVENT BUS (Like PyQt EventBus)
        // =============================================
        class EventBus {
            constructor() { this._listeners = {}; this._dataStore = {}; }
            on(event, callback) { if (!this._listeners[event]) this._listeners[event] = []; this._listeners[event].push(callback); }
            off(event, callback) { if (!this._listeners[event]) return; this._listeners[event] = this._listeners[event].filter(cb => cb !== callback); }
            emit(event, data) { if (this._listeners[event]) this._listeners[event].forEach(cb => cb(data)); }
            setData(key, value) { this._dataStore[key] = value; this.emit(`data:${key}`, value); }
            getData(key, defaultVal = null) { return this._dataStore[key] ?? defaultVal; }
            popData(key, defaultVal = null) { const val = this._dataStore[key] ?? defaultVal; delete this._dataStore[key]; return val; }
        }
        const eventBus = new EventBus();

        // =============================================
        // LANGUAGE DETECTOR
        // =============================================
        const LanguageDetector = {
            CJK_PATTERN: /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]+/,
            isCJKText(text) { return this.CJK_PATTERN.test(text); }
        };

        // =============================================
        // KEY MANAGER (Model-aware, pause/exhaust, timezone daily reset, persistent snapshot)
        // =============================================
        class KeyManager {
            constructor(keys, resetPolicy, providerId, snapshot = null) {
                this.keys = [...new Set((keys || []).map(k => String(k).trim()).filter(k => k.length > 0))];
                this.currentIndex = Math.max(0, Math.min(snapshot?.currentIndex ?? 0, Math.max(0, this.keys.length - 1)));
                this.resetPolicy = resetPolicy || { type: 'rolling', duration_hours: 24 };
                this.providerId = providerId;
                this.keyStatuses = snapshot?.keyStatuses && typeof snapshot.keyStatuses === 'object' ? snapshot.keyStatuses : {};
                this._mutex = new AsyncMutex();
                this._lastRequestTime = snapshot?.lastRequestTime && typeof snapshot.lastRequestTime === 'object' ? snapshot.lastRequestTime : {};
                this._leased = new Set();
                this._initKeyStatuses();
            }

            toJSON() {
                return { keys: this.keys, currentIndex: this.currentIndex, keyStatuses: this.keyStatuses, lastRequestTime: this._lastRequestTime };
            }

            _initKeyStatuses() {
                for (const key of this.keys) {
                    if (!this.keyStatuses[key]) this.keyStatuses[key] = { provider: this.providerId, statusByModel: {} };
                }
            }

            _getStatusForModel(key, modelId) {
                if (!this.keyStatuses[key]) this.keyStatuses[key] = { provider: this.providerId, statusByModel: {} };
                if (!this.keyStatuses[key].statusByModel[modelId]) {
                    this.keyStatuses[key].statusByModel[modelId] = {
                        exhaustedAt: null,
                        exhaustedLevel: 0,
                        pausedUntil: null,
                        requests: [],
                        dailyRequests: 0
                    };
                }
                return this.keyStatuses[key].statusByModel[modelId];
            }

            _tzOffsetMs(date, timeZone) {
                const dtf = new Intl.DateTimeFormat('en-US', {
                    timeZone,
                    hour12: false,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                const parts = dtf.formatToParts(date);
                const map = {};
                for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;
                const asUTC = Date.UTC(+map.year, +map.month - 1, +map.day, +map.hour, +map.minute, +map.second);
                return asUTC - date.getTime();
            }

            _getZonedYMD(nowMs, timeZone) {
                const dtf = new Intl.DateTimeFormat('en-US', { timeZone, year: 'numeric', month: '2-digit', day: '2-digit' });
                const parts = dtf.formatToParts(new Date(nowMs));
                const map = {};
                for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;
                return { y: +map.year, m: +map.month, d: +map.day };
            }

            _makeTimeInZoneUTCms(y, m, d, hh, mm, timeZone) {
                const utcGuess = Date.UTC(y, m - 1, d, hh, mm, 0);
                let utc = utcGuess;
                for (let i = 0; i < 3; i++) {
                    const off = this._tzOffsetMs(new Date(utc), timeZone);
                    utc = utcGuess - off;
                }
                return utc;
            }

            _getLastDailyResetMs(nowMs) {
                const policy = this.resetPolicy || {};
                const tz = policy.timezone || 'UTC';
                const resetHour = policy.reset_hour ?? 0;
                const resetMinute = policy.reset_minute ?? 0;

                const { y, m, d } = this._getZonedYMD(nowMs, tz);
                const todayReset = this._makeTimeInZoneUTCms(y, m, d, resetHour, resetMinute, tz);
                if (nowMs < todayReset) {
                    const yesterdayParts = this._getZonedYMD(todayReset - 12 * 3600 * 1000, tz);
                    return this._makeTimeInZoneUTCms(yesterdayParts.y, yesterdayParts.m, yesterdayParts.d, resetHour, resetMinute, tz);
                }
                return todayReset;
            }

            _shouldReset(exhaustedAtMs) {
                const policy = this.resetPolicy;
                const now = Date.now();
                if (!exhaustedAtMs) return false;

                if (policy.type === 'rolling') return now >= exhaustedAtMs + ((policy.duration_hours || 24) * 3600 * 1000);
                if (policy.type === 'daily') {
                    const lastResetMs = this._getLastDailyResetMs(now);
                    return exhaustedAtMs < lastResetMs;
                }
                return now >= exhaustedAtMs + (24 * 3600 * 1000);
            }

            getCurrent() { return this.keys.length > 0 ? this.keys[this.currentIndex] : null; }
            getCurrentIndex() { return this.currentIndex; }

            async acquireKey(modelId = null) {
                return this._mutex.withLock(() => {
                    if (this.keys.length === 0) return null;

                    for (let tries = 0; tries < this.keys.length; tries++) {
                        const idx = (this.currentIndex + tries) % this.keys.length;
                        const key = this.keys[idx];
                        if (this._leased.has(key)) continue;

                        if (modelId) {
                            const status = this._getStatusForModel(key, modelId);
                            this._normalizeAvailability(status);
                            if (status.exhaustedLevel !== 0) continue;
                        }

                        this._leased.add(key);
                        this.currentIndex = idx;

                        return { key, index: idx, release: () => { this._leased.delete(key); } };
                    }
                    return null;
                });
            }

            async pauseKeyFor(modelId, key, delayMs = 60000) {
                await this._mutex.withLock(() => {
                    if (!key || !modelId) return;
                    const status = this._getStatusForModel(key, modelId);
                    status.exhaustedLevel = 1;
                    status.pausedUntil = Date.now() + Math.max(0, delayMs);
                });
            }

            async markExhaustedFor(modelId, key) {
        // [FIX: AUTO-RESET] Восстанавливаем ключ через 60 секунд
        setTimeout(() => {
            try {
                if (this._exhausted?.get(modelId)?.has(key)) {
                    this._exhausted.get(modelId).delete(key);
                    // console.log('♻️ Ключ восстановлен: ' + key.slice(0,5));
                }
            } catch(e) {}
        }, 60000);
        
                await this._mutex.withLock(() => {
                    if (!key || !modelId) return;
                    const status = this._getStatusForModel(key, modelId);
                    status.exhaustedAt = Date.now();
                    status.exhaustedLevel = 2;
                    status.pausedUntil = null;
                });
            }

            async pauseKey(modelId, delayMs = 60000) {
                const key = this.getCurrent();
                await this.pauseKeyFor(modelId, key, delayMs);
            }

            async markExhausted(modelId) {
                const key = this.getCurrent();
                await this.markExhaustedFor(modelId, key);
            }

            _normalizeAvailability(status) {
                const now = Date.now();

                if (status.exhaustedLevel === 1) {
                    if (status.pausedUntil && now < status.pausedUntil) return;
                    status.exhaustedLevel = 0;
                    status.pausedUntil = null;
                }

                if (status.exhaustedLevel === 2 && status.exhaustedAt) {
                    if (this._shouldReset(status.exhaustedAt)) {
                        status.exhaustedAt = null;
                        status.exhaustedLevel = 0;
                        status.pausedUntil = null;
                        status.dailyRequests = 0;
                    }
                }

                const cutoff = Date.now() - (25 * 3600 * 1000);
                status.requests = (status.requests || []).filter(ts => ts > cutoff);
            }

            isKeyAvailable(modelId) {
                const key = this.getCurrent();
                if (!key || !modelId) return true;
                const status = this._getStatusForModel(key, modelId);
                this._normalizeAvailability(status);
                return status.exhaustedLevel === 0;
            }

            rotate(modelId = null) {
                if (this.keys.length === 0) return;
                const prev = this.currentIndex;
                let attempts = 0;
                while (attempts < this.keys.length) {
                    this.currentIndex = (this.currentIndex + 1) % this.keys.length;
                    if (!modelId || this.isKeyAvailable(modelId)) {
                        console.log(`🔄 Rotation: ${prev + 1} -> ${this.currentIndex + 1}`);
                        return;
                    }
                    attempts++;
                }
            }

            async incrementRequestFor(modelId, key, rpd = null) {
                await this._mutex.withLock(() => {
                    if (!key || !modelId) return;
                    const status = this._getStatusForModel(key, modelId);
                    this._normalizeAvailability(status);
                    status.requests = status.requests || [];
                    status.requests.push(Date.now());
                    status.dailyRequests = (status.dailyRequests || 0) + 1;
                    if (typeof rpd === 'number' && rpd > 0 && status.dailyRequests >= rpd) {
                        status.exhaustedAt = Date.now();
                        status.exhaustedLevel = 2;
                        status.pausedUntil = null;
                    }
                    const cutoff = Date.now() - (25 * 3600 * 1000);
                    status.requests = status.requests.filter(ts => ts > cutoff);
                });
            }

            async incrementRequest(modelId, rpd = null) {
                const key = this.getCurrent();
                return this.incrementRequestFor(modelId, key, rpd);
            }

            async waitForRateLimitFor(modelId, key, rpm) {
                if (!rpm || rpm <= 0) return;
                if (!key) return;
                const keyModelId = `${key}_${modelId}`;
                const lastTime = this._lastRequestTime[keyModelId] || 0;
                const minInterval = (60 * 1000) / rpm;
                const elapsed = Date.now() - lastTime;
                if (elapsed < minInterval) await sleep(minInterval - elapsed);
                this._lastRequestTime[keyModelId] = Date.now();
            }

            async waitForRateLimit(modelId, rpm) {
                const key = this.getCurrent();
                return this.waitForRateLimitFor(modelId, key, rpm);
            }

            count() { return this.keys.length; }

            availableCount(modelId) {
                if (!modelId) return this.keys.length;
                return this.keys.filter((key) => {
                    const status = this._getStatusForModel(key, modelId);
                    this._normalizeAvailability(status);
                    return status.exhaustedLevel === 0;
                }).length;
            }
        }

        // =============================================
        // PROVIDERS CONFIG (v9.9.0)
        // =============================================
        const PROVIDERS_CONFIG = {
            gemini: {
                displayName: "Google Gemini Free",
                baseUrl: "https://generativelanguage.googleapis.com/v1beta",
                resetPolicy: { type: "daily", timezone: "America/Los_Angeles", reset_hour: 0, reset_minute: 1 },
                getKeyUrl: "https://aistudio.google.com/app/apikey",
                sharedRequestCounter: true,
                rpd: 1500,
                visible: true,
                models: {
                    "Gemini 3.0 Flash Preview": { id: "gemini-3-flash-preview", rpm: 5, rpd: 20, maxOutputTokens: 32768, contextLength: 230000, thinkingLevel: ["high", "medium", "low", "minimal"], minThinkingBudget: "minimal" },
                    "Gemini 2.5 Flash": { id: "gemini-flash-latest", rpm: 5, rpd: 20, maxOutputTokens: 32768, contextLength: 230000 },
                    "Gemini 2.5 Flash-Lite": { id: "gemini-flash-lite-latest", rpm: 10, rpd: 20, maxOutputTokens: 16384, contextLength: 230000 },
                    "Gemma 3 27B": { id: "gemma-3-27b-it", rpm: 2, rpd: 0, maxOutputTokens: 8192, contextLength: 12000 }
                }
            },
            openrouter: {
                displayName: "OpenRouter (бесплатные)",
                baseUrl: "https://openrouter.ai/api/v1/chat/completions",
                resetPolicy: { type: "rolling", duration_hours: 24 },
                getKeyUrl: "https://openrouter.ai/keys",
                sharedRequestCounter: true,
                visible: true,
                models: {
                    "Gemini 2.0 Flash Exp": { id: "google/gemini-2.0-flash-exp:free", rpm: 20, maxOutputTokens: 15000, contextLength: 250000 },
                    "DeepSeek V3.1 Nex N1": { id: "nex-agi/deepseek-v3.1-nex-n1:free", rpm: 20, maxOutputTokens: 15000, contextLength: 100000 },
                    "Qwen3 Coder 480B": { id: "qwen/qwen3-coder:free", rpm: 20, maxOutputTokens: 15000, contextLength: 30000 },
                    "DeepSeek R1T2 Chimera": { id: "tngtech/deepseek-r1t2-chimera:free", rpm: 20, maxOutputTokens: 7500, contextLength: 100000 },
                    "GLM-4.5 Air": { id: "z-ai/glm-4.5-air:free", rpm: 20, maxOutputTokens: 7500, contextLength: 30000 },
                    "Gemma 3 27B": { id: "google/gemma-3-27b-it:free", rpm: 20, maxOutputTokens: 7500, contextLength: 30000 },
                    "Xiaomi MiMo-V2-Flash": { id: "xiaomi/mimo-v2-flash:free", rpm: 20, maxOutputTokens: 15000, contextLength: 60000 },
                    "GPT OSS 120B": { id: "openai/gpt-oss-120b:free", rpm: 20, maxOutputTokens: 7500, contextLength: 30000 }
                }
            },
            huggingface: {
                displayName: "Hugging Face (Free)",
                baseUrl: "https://router.huggingface.co/v1/chat/completions",
                resetPolicy: { type: "rolling", duration_hours: 24 },
                getKeyUrl: "https://huggingface.co/settings/tokens",
                sharedRequestCounter: false,
                visible: true,
                models: {
                    "Gemma 3 27B (Scaleway)": { id: "google/gemma-3-27b-it", rpm: 5, maxOutputTokens: 8192, contextLength: 128000 },
                    "Kimi-K2 1T (Groq)": { id: "moonshotai/Kimi-K2-Instruct-0905", rpm: 5, maxOutputTokens: 8192, contextLength: 128000 },
                    "GLM-4.6 357B": { id: "zai-org/GLM-4.6", rpm: 5, maxOutputTokens: 8192, contextLength: 128000 },
                    "GPT OSS 120B (Scaleway)": { id: "openai/gpt-oss-120b", rpm: 5, maxOutputTokens: 8192, contextLength: 64000 }
                }
            },
            neuroapi: {
                displayName: "NeuroAPI (Платный)",
                baseUrl: "https://neuroapi.host/v1/chat/completions",
                resetPolicy: { type: "rolling", duration_hours: 24 },
                getKeyUrl: "https://neuroapi.host",
                sharedRequestCounter: true,
                visible: true,
                paid: true,
                models: {
                    "GPT-5": { id: "gpt-5", rpm: 60, maxOutputTokens: 16384, contextLength: 400000 },
                    "Claude 3.7 Sonnet": { id: "claude-3-7-sonnet-20250219", rpm: 60, maxOutputTokens: 8192, contextLength: 200000 },
                    "Gemini 2.5 Pro": { id: "gemini-2.5-pro", rpm: 60, maxOutputTokens: 32768, contextLength: 1000000 },
                    "DeepSeek V3.1": { id: "deepseek-v3.1", rpm: 60, maxOutputTokens: 8192, contextLength: 128000 },
                    "GPT-4o Mini": { id: "gpt-4o-mini", rpm: 100, maxOutputTokens: 16384, contextLength: 128000 },
                    "o3-mini": { id: "o3-mini", rpm: 60, maxOutputTokens: 32768, contextLength: 200000, thinking: true }
                }
            },
            gemini_top: {
                displayName: "Google Gemini Top",
                baseUrl: "https://generativelanguage.googleapis.com/v1beta",
                resetPolicy: { type: "daily", timezone: "America/Los_Angeles", reset_hour: 0, reset_minute: 1 },
                getKeyUrl: "https://aistudio.google.com/app/apikey",
                sharedRequestCounter: true,
                visible: true,
                models: {
                    "Gemini 3.0 Pro Preview": { id: "gemini-3.0-pro-preview", rpm: 2, rpd: 20, maxOutputTokens: 32768, contextLength: 110000, thinkingLevel: ["high", "low"], minThinkingBudget: "low" },
                    "Gemini 2.5 Pro": { id: "gemini-2.5-pro", rpm: 2, maxOutputTokens: 32768, contextLength: 110000, minThinkingBudget: 768 },
                    "Gemini 2.0 Flash": { id: "gemini-2.0-flash", rpm: 10, maxOutputTokens: 16384, contextLength: 950000 },
                    "Gemini 2.0 Flash-Lite": { id: "gemini-2.0-flash-lite", rpm: 10, maxOutputTokens: 8192, contextLength: 950000 }
                }
            },
            local: {
                displayName: "Локальные модели (Ollama/LM Studio)",
                baseUrl: "http://127.0.0.1:11434/v1/chat/completions",
                resetPolicy: { type: "rolling", duration_hours: 9999 },
                getKeyUrl: "https://ollama.com/",
                sharedRequestCounter: false,
                visible: true,
                local: true,
                models: {
                    "DeepSeek R1 8B (Ollama)": { id: "deepseek-r1:8b", rpm: 1000, maxOutputTokens: 4096, contextLength: 12000, baseUrl: "http://127.0.0.1:11434/v1/chat/completions" },
                    "Qwen 3 8B (Ollama)": { id: "qwen3:8b", rpm: 1000, maxOutputTokens: 4096, contextLength: 12000, baseUrl: "http://127.0.0.1:11434/v1/chat/completions" },
                    "Gemma 3 12B IT (Ollama)": { id: "gemma3:12b-it-qat", rpm: 1000, maxOutputTokens: 8192, contextLength: 12000, baseUrl: "http://127.0.0.1:11434/v1/chat/completions" },
                    "Mistral Nemo 12B (LM Studio)": { id: "mistralai/mistral-nemo-instruct-2407", rpm: 1000, maxOutputTokens: 8192, contextLength: 12000, baseUrl: "http://localhost:1234/v1/chat/completions" },
                    "Custom Model": { id: "custom", rpm: 1000, maxOutputTokens: 8192, contextLength: 32000, baseUrl: "http://127.0.0.1:11434/v1/chat/completions" }
                }
            }
        };

        // =============================================
        // PROMPTS (From config files)
        // =============================================
        const PROMPTS = {
            glossary: `## РОЛЬ И АРХИТЕКТУРА СИСТЕМЫ\n\nТы – **Компилятор Глоссария**. Твоя задача – создать **конфигурационный JSON-файл** для последующей программной обработки.\n\n**ГЛАВНАЯ ПРОБЛЕМА: \"АМНЕЗИЯ ПЕРЕВОДЧИКА\"**\nИтоговый ИИ-Переводчик, который будет использовать твой глоссарий, **не имеет памяти**. Он видит только одну главу за раз.\nТвоя Задача: Создать глоссарий, который будет **внешней памятью** для этого \"слепого\" переводчика.\n\n**ПРИНЦИП ОТБОРА:**\n🟢 РАЗРЕШЕНО: Имена/Клички, Локации, Организации, Артефакты, Титулы, Способности\n🔴 ЗАПРЕЩЕНО: Глаголы, прилагательные, местоимения, обычные предметы\n\n**ПРАВИЛА:**\n1. Ключ = точная копия из текста\n2. translation = перевод на русский\n3. note = тип; пол/род; склонение\n\n**ТЕКСТ:**\n{text}\n\n**ФОРМАТ ВЫВОДА:** Только JSON без markdown:\n{\n  \"Term\": { \"translation\": \"Перевод\", \"note\": \"тип; род; описание\" }\n}`,
            translation: `## РОЛЬ\n\nТы – **элитный локализатор-адаптолог**, чье мышление фундаментально русское. \nТвоя цель – **абсолютная естественность**: текст должен читаться так, будто изначально написан русским автором.\n\n## ГЛОССАРИЙ\n{glossary}\n\n## ПРАВИЛА ОФОРМЛЕНИЯ\n*   **Прямая речь:** Начинается с оператора \`─\`. Никогда не заключается в кавычки.\n*   **Мысли, цитаты:** Заключаются в кавычки-ёлочки \`«»\`.\n*   **Запрещено:** длинное тире \`—\`\n\n**Примеры:**\n\`\"Hello,\" he said.\` → \`─ Привет, ─ сказал он.\`\n\`'What a fool,' he thought.\` → \`«Какой же я дурак», – подумал он.\`\n\n## ТЕКСТ ДЛЯ ПЕРЕВОДА\n{text}\n\n**ВЫВОД:** Только XHTML код результата.`
        };

        // =============================================
        // STATE
        // =============================================
        let state = {
            keys: {},
            provider: null,
            model: null,
            glossary: {},
            currentFile: null,
            epubData: null,
            translatedChapters: [],
            isTranslating: false,
            isPaused: false,
            cancelRequested: false,
            stats: { tokensIn: 0, tokensOut: 0, startTime: null },
            projectHistory: [],
            validatorData: { chapters: [], currentIndex: 0, validated: new Set() }
        };

        // =============================================
        // INITIALIZATION HELPERS
        // =============================================
        function populateProviderSelect() {
            const select = document.getElementById('key-provider-select');
            select.innerHTML = Object.entries(PROVIDERS_CONFIG)
                .filter(([_, c]) => c.visible !== false)
                .map(([id, c]) => `<option value="${id}">${c.displayName}</option>`)
                .join('');
        }

        function loadState() {
            try {
                const saved = localStorage.getItem('epubTranslatorState99');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    state.provider = parsed.provider || null;
                    state.model = parsed.model || null;
                    state.glossary = parsed.glossary || {};
                    state.projectHistory = parsed.projectHistory || [];

                    for (const [provider, payload] of Object.entries(parsed.keys || {})) {
                        if (!PROVIDERS_CONFIG[provider]) continue;
                        if (Array.isArray(payload)) {
                            if (payload.length > 0) state.keys[provider] = new KeyManager(payload, PROVIDERS_CONFIG[provider].resetPolicy, provider);
                        } else if (payload && typeof payload === 'object' && Array.isArray(payload.keys)) {
                            if (payload.keys.length > 0) state.keys[provider] = new KeyManager(payload.keys, PROVIDERS_CONFIG[provider].resetPolicy, provider, payload);
                        }
                    }
                }
            } catch (e) { console.error('Load state error:', e); }
        }

        function saveState() {
            try {
                const keysToSave = {};
                for (const [provider, km] of Object.entries(state.keys)) {
                    if (!km) continue;
                    if (typeof km.toJSON === 'function') keysToSave[provider] = km.toJSON();
                    else if (km?.keys) keysToSave[provider] = km.keys;
                }
                localStorage.setItem('epubTranslatorState99', JSON.stringify({
                    keys: keysToSave,
                    provider: state.provider,
                    model: state.model,
                    glossary: state.glossary,
                    projectHistory: state.projectHistory.slice(0, 20)
                }));
            } catch (e) { console.error('Save state error:', e); }
        }

        // =============================================
        // UI FUNCTIONS
        // =============================================
        function switchTab(tabName) {
            document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden'));
            document.querySelectorAll('[id^="tab-"]').forEach(t => { t.classList.remove('tab-active'); t.classList.add('bg-white/10'); });
            document.getElementById(`panel-${tabName}`).classList.remove('hidden');
            const btn = document.getElementById(`tab-${tabName}`);
            btn.classList.add('tab-active');
            btn.classList.remove('bg-white/10');
            if (tabName === 'settings' && state.provider) renderModelList();
        }

        function updateUI() {
            const indicator = document.getElementById('status-indicator');
            const hasKeys = Object.values(state.keys).some(km => km?.count() > 0);
            const isConfigured = hasKeys && state.provider && state.model;

            if (isConfigured) {
                indicator.innerHTML = `<span class="w-2 h-2 bg-green-500 rounded-full pulse-dot"></span><span class="text-green-400">Готов к работе</span>`;
            } else if (hasKeys) {
                indicator.innerHTML = `<span class="w-2 h-2 bg-yellow-500 rounded-full"></span><span class="text-yellow-400">Выберите модель</span>`;
            } else {
                indicator.innerHTML = `<span class="w-2 h-2 bg-gray-500 rounded-full"></span><span class="text-gray-400">Добавьте ключи</span>`;
            }

            document.getElementById('current-provider').textContent = state.provider ? PROVIDERS_CONFIG[state.provider].displayName : 'Не выбран';
            document.getElementById('current-model').textContent = state.model || 'Не выбрана';
            document.getElementById('current-keys-count').textContent = state.provider && state.keys[state.provider] ? state.keys[state.provider].count() : 0;

            if (state.provider && state.model && PROVIDERS_CONFIG[state.provider]?.models[state.model]) {
                const model = PROVIDERS_CONFIG[state.provider].models[state.model];
                const rpd = (model.rpd ?? PROVIDERS_CONFIG[state.provider].rpd ?? null);
                document.getElementById('rpd-info').textContent = (rpd === 0) ? '∞' : (rpd === null ? '-' : String(rpd));
            } else {
                document.getElementById('rpd-info').textContent = '-';
            }

            updateGlossaryDisplay();
        }

        function updateGlossaryDisplay() {
            const container = document.getElementById('glossary-content');
            const count = Object.keys(state.glossary).length;
            document.getElementById('glossary-count').textContent = `(${count} терминов)`;

            if (count === 0) {
                container.innerHTML = '<p class="text-gray-400 text-center py-8">Глоссарий будет создан после начала перевода</p>';
                return;
            }

            const searchTerm = (document.getElementById('glossary-search')?.value || '').toLowerCase();
            const filtered = Object.entries(state.glossary).filter(([term, data]) =>
                !searchTerm || term.toLowerCase().includes(searchTerm) || (data.translation || '').toLowerCase().includes(searchTerm)
            );

            container.innerHTML = filtered.map(([term, data]) => {
                const safeTermHtml = escapeHtml(term);
                const safeTranslationHtml = escapeHtml(data.translation || '');
                const safeNoteHtml = escapeHtml(data.note || '');
                const termJs = JSON.stringify(term);

                return `
                    <div class="bg-white/5 rounded-xl p-4 hover:bg-white/10 transition">
                        <div class="flex justify-between items-start">
                            <div class="flex-1">
                                <span class="font-medium text-indigo-300">${safeTermHtml}</span>
                                <span class="text-gray-400 mx-2">→</span>
                                <span class="font-medium">${safeTranslationHtml}</span>
                            </div>
                            <button onclick='removeGlossaryTerm(${termJs})' class="text-gray-400 hover:text-red-400 transition ml-2">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        ${data.note ? `<p class="text-sm text-gray-400 mt-2">${safeNoteHtml}</p>` : ''}
                    </div>
                `;
            }).join('');
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const colors = { info: 'bg-indigo-600', success: 'bg-green-600', error: 'bg-red-600', warning: 'bg-yellow-600' };
            const toast = document.createElement('div');
            toast.className = `${colors[type]} px-4 py-3 rounded-xl shadow-lg transform transition-all duration-300 translate-x-full`;
            toast.innerHTML = `<div class="flex items-center gap-3"><i class="fas fa-${type === 'success' ? 'check' : type === 'error' ? 'times' : 'info'}-circle"></i><span>${escapeHtml(message)}</span></div>`;
            container.appendChild(toast);
            requestAnimationFrame(() => toast.classList.remove('translate-x-full'));
            setTimeout(() => { toast.classList.add('translate-x-full'); setTimeout(() => toast.remove(), 300); }, 3000);
        }

        function log(message, type = 'info') {
            const container = document.getElementById('log-container');
            const colors = { info: 'text-blue-400', success: 'text-green-400', error: 'text-red-400', warning: 'text-yellow-400' };
            const icons = { info: 'ℹ️', success: '✅', error: '❌', warning: '⚠️' };
            if (container.querySelector('.text-gray-500:only-child')) container.innerHTML = '';
            const entry = document.createElement('div');
            entry.className = `log-entry py-1 ${colors[type]}`;
            entry.innerHTML = `<span class="text-gray-500">[${new Date().toLocaleTimeString()}]</span> ${icons[type]} ${escapeHtml(message)}`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
            eventBus.emit('log', { message, type, time: new Date() });
        }

        function clearLog() { document.getElementById('log-container').innerHTML = '<div class="text-gray-500">Лог очищен.</div>'; }

        function downloadLog() {
            const container = document.getElementById('log-container');
            const text = container.innerText;
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `translation_log_${new Date().toISOString().slice(0,10)}.txt`;
            a.click();
        }

        // =============================================
        // KEY MANAGEMENT
        // =============================================
        function updateKeyProviderInfo() {
            const provider = document.getElementById('key-provider-select').value;
            const config = PROVIDERS_CONFIG[provider];
            const isPaid = config.paid;
            document.getElementById('key-provider-info').innerHTML = `
                <div class="flex items-center gap-2 mb-2">
                    <strong>${config.displayName}</strong>
                    ${isPaid ? '<span class="badge-paid px-2 py-0.5 rounded text-xs">Платный</span>' : '<span class="badge-free px-2 py-0.5 rounded text-xs">Бесплатный</span>'}
                </div>
                <p class="text-gray-400 mb-2">Моделей: ${Object.keys(config.models).length}</p>
                <p class="text-gray-400 mb-2">Сброс лимитов: ${config.resetPolicy.type === 'daily' ? 'Ежедневно (PST)' : 'Скользящие 24ч'}</p>
                <a href="${config.getKeyUrl}" target="_blank" class="text-indigo-400 hover:text-indigo-300">
                    <i class="fas fa-external-link-alt mr-1"></i>Получить ключ
                </a>
            `;
        }

        function addKeys() {
            const provider = document.getElementById('key-provider-select').value;
            const input = document.getElementById('keys-input').value;
            const isLocal = !!PROVIDERS_CONFIG[provider]?.local;
            const keys = isLocal ? ['local-no-key'] : input.split(/[\n,\s]+/).map(k => k.trim()).filter(k => k.length > 10);
            if (!isLocal && keys.length === 0) { showToast('Не найдено валидных ключей', 'error'); return; }

            const existingKeys = state.keys[provider]?.keys || [];
            const allKeys = [...new Set([...existingKeys, ...keys])];
            state.keys[provider] = new KeyManager(allKeys, PROVIDERS_CONFIG[provider].resetPolicy, provider);

            if (!state.provider) {
                state.provider = provider;
                state.model = Object.keys(PROVIDERS_CONFIG[provider].models)[0];
            }

            saveState(); updateUI(); renderKeysList(); renderProviderList();
            document.getElementById('keys-input').value = '';
            showToast(`Добавлено ${allKeys.length - existingKeys.length} ключей`, 'success');
            log(`Добавлено ключей для ${PROVIDERS_CONFIG[provider].displayName}`, 'success');
        }

        function renderKeysList() {
            const container = document.getElementById('keys-list');
            let html = '';
            for (const [provider, km] of Object.entries(state.keys)) {
                if (!km || km.count() === 0) continue;
                const config = PROVIDERS_CONFIG[provider];
                html += `
                    <div class="border border-white/10 rounded-xl overflow-hidden">
                        <div class="bg-white/5 px-4 py-3 flex items-center justify-between">
                            <span class="font-medium">${config.displayName}</span>
                            <span class="text-sm text-gray-400">${km.keys.length} ключей</span>
                        </div>
                        <div class="divide-y divide-white/5">
                            ${km.keys.map((key, idx) => {
                                const isLocal = !!PROVIDERS_CONFIG[provider]?.local;
                                const label = isLocal ? '(local / no key)' : `${key.slice(0, 12)}...${key.slice(-4)}`;
                                return `
                                <div class="key-item px-4 py-2 flex items-center justify-between">
                                    <code class="text-sm text-gray-400">${escapeHtml(label)}</code>
                                    <button onclick="removeKey('${provider}', ${idx})" class="text-red-400 hover:text-red-300 transition">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            container.innerHTML = html || '<p class="text-gray-400 text-center py-8">Нет сохранённых ключей</p>';
        }

        function removeKey(provider, index) {
            if (!state.keys[provider]) return;
            const keys = [...state.keys[provider].keys];
            keys.splice(index, 1);
            if (keys.length === 0) {
                delete state.keys[provider];
                if (state.provider === provider) { state.provider = null; state.model = null; }
            } else {
                state.keys[provider] = new KeyManager(keys, PROVIDERS_CONFIG[provider].resetPolicy, provider);
            }
            saveState(); updateUI(); renderKeysList(); renderProviderList();
            showToast('Ключ удалён', 'info');
        }

        // =============================================
        // PROVIDER/MODEL SELECTION
        // =============================================
        function renderProviderList() {
            const container = document.getElementById('provider-list');
            container.innerHTML = Object.entries(PROVIDERS_CONFIG)
                .filter(([_, c]) => c.visible !== false)
                .map(([id, config]) => {
                    const hasKeys = state.keys[id]?.count() > 0;
                    const isActive = state.provider === id;
                    const isPaid = config.paid;
                    return `
                        <button onclick="selectProvider('${id}')" class="provider-btn w-full p-4 rounded-xl border border-white/20 text-left transition ${isActive ? 'active' : 'hover:border-white/40'}">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center gap-3">
                                    <div class="w-10 h-10 rounded-lg ${hasKeys ? 'bg-green-500/30' : 'bg-white/10'} flex items-center justify-center">
                                        <i class="fas fa-${hasKeys ? 'check' : 'key'} ${hasKeys ? 'text-green-400' : 'text-gray-400'}"></i>
                                    </div>
                                    <div>
                                        <p class="font-medium flex items-center gap-2">
                                            ${config.displayName}
                                            ${isPaid ? '<span class="badge-paid px-1.5 py-0.5 rounded text-[10px]">$</span>' : ''}
                                        </p>
                                        <p class="text-sm text-gray-400">${Object.keys(config.models).length} моделей</p>
                                    </div>
                                </div>
                                <span class="text-sm ${hasKeys ? 'text-green-400' : 'text-gray-500'}">${hasKeys ? state.keys[id].count() : 0} ключей</span>
                            </div>
                        </button>
                    `;
                }).join('');
        }

        function selectProvider(providerId) {
            const isLocal = !!PROVIDERS_CONFIG[providerId]?.local;
            if (!isLocal && !state.keys[providerId]?.count()) { showToast('Сначала добавьте ключи', 'warning'); return; }
            if (isLocal && !state.keys[providerId]?.count()) {
                state.keys[providerId] = new KeyManager(['local-no-key'], PROVIDERS_CONFIG[providerId].resetPolicy, providerId);
            }
            state.provider = providerId;
            state.model = Object.keys(PROVIDERS_CONFIG[providerId].models)[0];
            saveState(); updateUI(); renderProviderList(); renderModelList();
            log(`Провайдер: ${PROVIDERS_CONFIG[providerId].displayName}`, 'info');
        }

        function renderModelList() {
            const container = document.getElementById('model-list');
            if (!state.provider) { container.innerHTML = '<p class="text-gray-400">Сначала выберите провайдера</p>'; return; }

            const providerConfig = PROVIDERS_CONFIG[state.provider];
            const models = providerConfig.models;
            const isLocal = providerConfig.local;

            container.innerHTML = Object.entries(models).map(([name, config]) => {
                const isActive = state.model === name;
                const hasThinking = config.thinkingLevel || config.minThinkingBudget || config.thinking;
                return `
                    <button onclick="selectModel('${name}')" class="model-btn w-full p-4 rounded-xl border border-white/20 text-left transition ${isActive ? 'active' : 'hover:border-white/40'}">
                        <div class="flex items-center justify-between">
                            <div>
                                <p class="font-medium flex items-center gap-2">
                                    ${name}
                                    ${hasThinking ? '<span class="badge-thinking px-1.5 py-0.5 rounded text-[10px]">🧠</span>' : ''}
                                    ${isLocal ? '<span class="badge-local px-1.5 py-0.5 rounded text-[10px]">Local</span>' : ''}
                                </p>
                                <p class="text-sm text-gray-400">
                                    ${isLocal ? `${(config.baseUrl || providerConfig.baseUrl).split('//')[1]?.split('/')[0] || 'localhost'}` : `${config.rpm} RPM`} • ${formatNumber(config.contextLength)} ctx
                                    ${config.rpd ? ` • ${config.rpd} RPD` : ''}
                                </p>
                            </div>
                            ${isActive ? '<i class="fas fa-check text-white"></i>' : ''}
                        </div>
                    </button>
                `;
            }).join('');
        }

        function selectModel(modelName) {
            state.model = modelName;
            saveState(); updateUI(); renderModelList();
            log(`Модель: ${modelName}`, 'info');
        }

        // =============================================
        // FILE HANDLING
        // =============================================
        function handleDragOver(e) { e.preventDefault(); e.currentTarget.classList.add('border-indigo-500', 'bg-indigo-500/10'); }
        function handleDragLeave(e) { e.currentTarget.classList.remove('border-indigo-500', 'bg-indigo-500/10'); }
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('border-indigo-500', 'bg-indigo-500/10');
            const file = e.dataTransfer.files[0];
            if (file?.name.endsWith('.epub')) processFile(file);
            else showToast('Загрузите EPUB файл', 'error');
        }
        function handleFileSelect(e) { if (e.target.files[0]) processFile(e.target.files[0]); }

        function togglePartialTranslation() {
            const enabled = document.getElementById('partial-translation').checked;
            document.getElementById('chapter-range').classList.toggle('hidden', !enabled);
        }

        async function processFile(file) {
            state.currentFile = file;
            log(`Загружен: ${file.name}`, 'info');
            document.getElementById('file-name').textContent = file.name;
            document.getElementById('file-size').textContent = formatSize(file.size);

            try {
                const zip = await JSZip.loadAsync(file);
                state.epubData = { zip, chapters: [] };
                const chapters = await parseEpubStructure(zip);
                state.epubData.chapters = chapters;

                let totalChars = 0;
                for (const ch of chapters) {
                    const content = await zip.file(ch.path).async('string');
                    ch._charCount = content.length;
                    totalChars += content.length;
                }

                const tokenEstimate = Math.round(totalChars / 3.5);
                const costEstimate = (tokenEstimate / 1000000 * 0.15).toFixed(4);

                document.getElementById('chapter-count').textContent = chapters.length;
                document.getElementById('char-count').textContent = formatNumber(totalChars);
                document.getElementById('token-estimate').textContent = formatNumber(tokenEstimate);
                document.getElementById('cost-estimate').textContent = `$${costEstimate}`;
                document.getElementById('end-chapter').value = chapters.length;
                document.getElementById('end-chapter').max = chapters.length;
                document.getElementById('start-chapter').max = chapters.length;

                document.getElementById('upload-area').classList.add('hidden');
                document.getElementById('file-info').classList.remove('hidden');
                document.getElementById('dry-run-btn').disabled = false;
                log(`${chapters.length} глав, ${formatNumber(totalChars)} символов`, 'success');
            } catch (e) {
                log(`Ошибка: ${e.message}`, 'error');
                showToast('Ошибка чтения файла', 'error');
            }
        }

        async function parseEpubStructure(zip) {
            const chapters = [];
            try {
                const containerFile = zip.file('META-INF/container.xml');
                if (containerFile) {
                    const containerXml = await containerFile.async('string');
                    const opfMatch = containerXml.match(/full-path="([^"]+\.opf)"/);
                    if (opfMatch && zip.file(opfMatch[1])) {
                        const opfContent = await zip.file(opfMatch[1]).async('string');
                        const opfDir = opfMatch[1].includes('/') ? opfMatch[1].substring(0, opfMatch[1].lastIndexOf('/') + 1) : '';

                        const manifest = {};
                        const itemRegex = /<item[^>]+id="([^"]+)"[^>]+href="([^"]+)"/g;
                        let match;
                        while ((match = itemRegex.exec(opfContent)) !== null) manifest[match[1]] = match[2];

                        const spineRegex = /<itemref[^>]+idref="([^"]+)"/g;
                        while ((match = spineRegex.exec(opfContent)) !== null) {
                            if (manifest[match[1]]) {
                                const fullPath = opfDir + manifest[match[1]];
                                if (zip.file(fullPath)) chapters.push({ id: match[1], path: fullPath, title: `Глава ${chapters.length + 1}` });
                            }
                        }
                    }
                }
            } catch (e) { console.error('OPF error:', e); }

            if (chapters.length === 0) {
                Object.keys(zip.files)
                    .filter(f => /\.(x?html?|htm)$/i.test(f) && !f.includes('META-INF'))
                    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
                    .forEach((f, i) => chapters.push({ id: `ch${i}`, path: f, title: `Глава ${i + 1}` }));
            }
            return chapters;
        }

        function clearFile() {
            if (state.isTranslating) {
                showToast('Нельзя очистить файл во время перевода', 'warning');
                return;
            }
            state.currentFile = null;
            state.epubData = null;
            state.translatedChapters = [];
            state.stats = { tokensIn: 0, tokensOut: 0, startTime: null };

            document.getElementById('file-input').value = '';
            document.getElementById('upload-area').classList.remove('hidden');
            document.getElementById('file-info').classList.add('hidden');
            document.getElementById('progress-panel').classList.add('hidden');
            document.getElementById('result-panel').classList.add('hidden');
            document.getElementById('dry-run-btn').disabled = true;

            log('Файл очищен', 'info');
        }

        // =============================================
        // TRANSLATION ENGINE
        // =============================================
        async function startTranslation() {
            if (!state.provider || !state.model) { showToast('Настройте провайдера и модель', 'warning'); switchTab('settings'); return; }

            const providerConfig = PROVIDERS_CONFIG[state.provider];
            const isLocal = !!providerConfig?.local;
            if (!isLocal && !state.keys[state.provider]?.count()) { showToast('Добавьте API ключи', 'warning'); switchTab('keys'); return; }
            if (isLocal && !state.keys[state.provider]?.count()) {
                state.keys[state.provider] = new KeyManager(['local-no-key'], providerConfig.resetPolicy, state.provider);
            }

            if (!state.epubData?.chapters?.length) { showToast('Сначала загрузите EPUB', 'warning'); return; }

            state.isTranslating = true; state.cancelRequested = false; state.isPaused = false;
            state.translatedChapters = [];
            state.stats = { tokensIn: 0, tokensOut: 0, startTime: Date.now() };

            document.getElementById('file-info').classList.add('hidden');
            document.getElementById('progress-panel').classList.remove('hidden');
            log('Начало перевода...', 'info');

            const chapters = state.epubData.chapters;
            const createGlossary = document.getElementById('create-glossary').checked;
            const chunkSize = parseInt(document.getElementById('chunk-size').value) || 50000;

            const partial = document.getElementById('partial-translation').checked;
            const startIdx = partial ? parseInt(document.getElementById('start-chapter').value) - 1 : 0;
            const endIdx = partial ? parseInt(document.getElementById('end-chapter').value) : chapters.length;
            const chaptersToTranslate = chapters.slice(startIdx, endIdx);

            const requestedWorkers = Math.max(1, parseInt(document.getElementById('num-instances')?.value) || 1);
            const keyManager = state.keys[state.provider];
            const maxWorkers = isLocal ? 1 : Math.max(1, Math.min(requestedWorkers, keyManager.count()));

            const timerInterval = setInterval(() => {
                if (!state.isTranslating) { clearInterval(timerInterval); return; }
                const elapsed = Math.floor((Date.now() - state.stats.startTime) / 1000);
                document.getElementById('elapsed-time').textContent = `${Math.floor(elapsed / 60).toString().padStart(2, '0')}:${(elapsed % 60).toString().padStart(2, '0')}`;
            }, 1000);

            let completed = 0;
            const total = chaptersToTranslate.length;
            let allKeysExhausted = false;

            const resultsByIndex = new Array(total);

            let nextIndex = 0;
            const indexPool = [];
            const indexMutex = new AsyncMutex();
            async function getNextIndex() {
                return indexMutex.withLock(() => {
                    if (indexPool.length > 0) return indexPool.shift();
                    if (nextIndex >= total) return null;
                    return nextIndex++;
                });
            }
            async function pushBackIndex(i) {
                return indexMutex.withLock(() => {
                    if (i === null || i === undefined) return;
                    // put back to front to preserve order as much as possible
                    indexPool.unshift(i);
                });
            }

            async function waitIfPaused() {
                while (state.isPaused && !state.cancelRequested) await sleep(250);
            }

            try {
                if (createGlossary && chaptersToTranslate.length > 0) {
                    updateProgress(0, 'Создание глоссария...', 0, total);
                    log('Создание глоссария...', 'info');
                    let sampleText = '';
                    for (let i = 0; i < Math.min(2, chaptersToTranslate.length); i++) {
                        const c = await state.epubData.zip.file(chaptersToTranslate[i].path).async('string');
                        sampleText += extractText(c).slice(0, 5000) + '\n';
                    }
                    try {
                        const glossaryPromptTpl = document.getElementById('glossary-prompt')?.value || DEFAULT_GLOSSARY_PROMPT;
                        const glossaryPrompt = glossaryPromptTpl.replace('{text}', sampleText);
                        const glossaryResult = await callAI(glossaryPrompt);
                        const parsed = parseJSON(glossaryResult);
                        if (parsed && typeof parsed === 'object') {
                            state.glossary = { ...state.glossary, ...parsed };
                            saveState();
                            log(`Глоссарий: ${Object.keys(parsed).length} терминов`, 'success');
                            updateGlossaryDisplay();
                        }
                    } catch (e) {
                        if (e instanceof AllKeysExhaustedError) throw e;
                        log(`Ошибка глоссария: ${e.message}`, 'warning');
                    }
                }

                async function workerLoop(workerNo) {
                    const enableBatching = document.getElementById('enable-batching')?.checked;
                    const batchingMaxChars = Math.max(30000, parseInt(document.getElementById('batching-max-chars')?.value) || 120000);

                    while (true) {
                        await waitIfPaused();
                        if (state.cancelRequested) return;

                        const idx = await getNextIndex();
                        if (idx === null) return;

                        // Decide between single and batching.
                        // Batching strategy: if enabled, this worker will try to pull additional small chapters.
                        const batchIndices = [idx];
                        if (enableBatching && !allKeysExhausted) {
                            try {
                                // Read first chapter size quickly to decide.
                                const firstCh = chaptersToTranslate[idx];
                                const firstLen = firstCh?._charCount ?? null;

                                // Only batch if first chapter can be translated in a single call (no chunking).
                                if (firstLen != null && firstLen > chunkSize) {
                                    // skip batching
                                } else if (firstLen === null || firstLen < batchingMaxChars * 0.8) {
                                    let totalChars = firstLen ?? 0;

                                    // Pull more chapters opportunistically.
                                    while (true) {
                                        const next = await getNextIndex();
                                        if (next === null) break;

                                        const nextCh = chaptersToTranslate[next];
                                        const nextLen = nextCh?._charCount ?? null;

                                        // Skip batching long chapters (they need chunking).
                                        if (nextLen != null && nextLen > chunkSize) {
                                            await pushBackIndex(next);
                                            break;
                                        }

                                        const approxNext = nextLen ?? Math.min(20000, batchingMaxChars);

                                        if (totalChars + approxNext > batchingMaxChars) {
                                            await pushBackIndex(next);
                                            break;
                                        }

                                        batchIndices.push(next);
                                        totalChars += approxNext;

                                        if (batchIndices.length >= 8) break; // safety cap
                                    }
                                }
                            } catch {
                                // if anything goes wrong, we keep single
                            }
                        }

                        // If we got multiple indices, try to batch translate. Otherwise single.
                        if (batchIndices.length > 1 && !allKeysExhausted) {
                            // BATCH MODE
                            try {
                                const chaptersBatch = batchIndices.map(i => chaptersToTranslate[i]);
                                updateProgress(Math.round((completed / total) * 100), `Batch: ${batchIndices.length} глав (воркер ${workerNo})`, completed, total);

                                const originals = [];
                                for (const ch of chaptersBatch) {
                                    const txt = await state.epubData.zip.file(ch.path).async('string');
                                    originals.push({ path: ch.path, title: ch.title, content: txt });
                                }

                                const translatedMap = await translateChaptersBatched(originals, chunkSize);

                                for (const i of batchIndices) {
                                    const ch = chaptersToTranslate[i];
                                    const translated = translatedMap.get(ch.path);
                                    if (typeof translated === 'string' && translated.trim().length > 0) {
                                        resultsByIndex[i] = { ...ch, content: translated };
                                        log(`Глава ${startIdx + i + 1} ✓ (batch, воркер ${workerNo})`, 'success');
                                    } else {
                                        // fallback to single per chapter (parsing failed for this chapter)
                                        const src = originals.find(o => o.path === ch.path)?.content || '';
                                        const one = await translateChapter(src, chunkSize);
                                        resultsByIndex[i] = { ...ch, content: one };
                                        log(`Глава ${startIdx + i + 1} ✓ (fallback)`, 'warning');
                                    }

                                    // Progress for each chapter in batch
                                    completed++;
                                    updateProgress(Math.round((completed / total) * 100), `Готово: ${completed}/${total}`, completed, total);
                                    if (document.getElementById('auto-save').checked) {
                                        state.translatedChapters = resultsByIndex.filter(Boolean);
                                        saveProjectState();
                                    }
                                }

                            } catch (e) {
                                // If batch fails, fallback to single for each chapter
                                log(`Batch ошибка: ${e.message || e}. Fallback на одиночный режим.`, 'warning');
                                for (const i of batchIndices) {
                                    let content = '';
                                    try {
                                        const chapter = chaptersToTranslate[i];
                                        content = await state.epubData.zip.file(chapter.path).async('string');

                                        if (allKeysExhausted) {
                                            resultsByIndex[i] = { ...chapter, content };
                                        } else {
                                            const translated = await translateChapter(content, chunkSize);
                                            resultsByIndex[i] = { ...chapter, content: translated };
                                            log(`Глава ${startIdx + i + 1} ✓ (fallback, воркер ${workerNo})`, 'success');
                                        }
                                    } catch (err) {
                                        const chapter = chaptersToTranslate[i];
                                        if (err instanceof AllKeysExhaustedError) {
                                            log('⛔ Все ключи исчерпаны!', 'error');
                                            allKeysExhausted = true;
                                            resultsByIndex[i] = { ...chapter, content };
                                        } else if (err instanceof ContentBlockedError) {
                                            log(`🔞 Глава ${startIdx + i + 1}: цензура`, 'warning');
                                            resultsByIndex[i] = { ...chapter, content: document.getElementById('keep-censored').checked ? content : '' };
                                        } else if (err instanceof OperationCancelledError) {
                                            log(`Отмена (воркер ${workerNo})`, 'warning');
                                            resultsByIndex[i] = { ...chapter, content };
                                        } else {
                                            log(`Ошибка главы ${startIdx + i + 1}: ${err.message || err}`, 'error');
                                            resultsByIndex[i] = { ...chapter, content: document.getElementById('keep-censored').checked ? content : '' };
                                        }
                                    } finally {
                                        completed++;
                                        updateProgress(Math.round((completed / total) * 100), `Готово: ${completed}/${total}`, completed, total);
                                        if (document.getElementById('auto-save').checked) {
                                            state.translatedChapters = resultsByIndex.filter(Boolean);
                                            saveProjectState();
                                        }
                                    }
                                }
                            }

                            continue; // batch handled progress and auto-save
                        }

                        // SINGLE MODE
                        const chapter = chaptersToTranslate[idx];
                        let content = '';
                        try {
                            updateProgress(Math.round((completed / total) * 100), `В работе: глава ${startIdx + idx + 1}/${startIdx + total}`, completed, total);
                            document.getElementById('current-key-index').textContent = `${keyManager.getCurrentIndex() + 1}/${keyManager.count()}`;

                            content = await state.epubData.zip.file(chapter.path).async('string');

                            if (allKeysExhausted) {
                                resultsByIndex[idx] = { ...chapter, content };
                            } else {
                                const translated = await translateChapter(content, chunkSize);
                                resultsByIndex[idx] = { ...chapter, content: translated };
                                log(`Глава ${startIdx + idx + 1} ✓ (воркер ${workerNo})`, 'success');
                            }
                        } catch (e) {
                            if (e instanceof AllKeysExhaustedError) {
                                log('⛔ Все ключи исчерпаны!', 'error');
                                allKeysExhausted = true;
                                resultsByIndex[idx] = { ...chapter, content };
                            } else if (e instanceof ContentBlockedError) {
                                log(`🔞 Глава ${startIdx + idx + 1}: цензура`, 'warning');
                                resultsByIndex[idx] = { ...chapter, content: document.getElementById('keep-censored').checked ? content : '' };
                            } else if (e instanceof OperationCancelledError) {
                                log(`Отмена (воркер ${workerNo})`, 'warning');
                                resultsByIndex[idx] = { ...chapter, content };
                            } else {
                                log(`Ошибка главы ${startIdx + idx + 1}: ${e.message}`, 'error');
                                resultsByIndex[idx] = { ...chapter, content: document.getElementById('keep-censored').checked ? content : '' };
                            }
                        } finally {
                            completed++;
                            updateProgress(Math.round((completed / total) * 100), `Готово: ${completed}/${total}`, completed, total);

                            if (document.getElementById('auto-save').checked) {
                                state.translatedChapters = resultsByIndex.filter(Boolean);
                                saveProjectState();
                            }
                        }
                    }
                }

                const workers = [];
                for (let w = 0; w < maxWorkers; w++) workers.push(workerLoop(w + 1));

                await Promise.all(workers);

                if (!state.cancelRequested) {
                    state.translatedChapters = resultsByIndex.filter(Boolean);
                    saveProjectToHistory();
                    showResult();
                } else {
                    log('Отменено', 'warning');
                }

            } catch (e) {
                log(`Критическая ошибка: ${e.message}`, 'error');
                state.translatedChapters = resultsByIndex.filter(Boolean);
                if (state.translatedChapters.length > 0) showResult();
            } finally {
                state.isTranslating = false;
                clearInterval(timerInterval);
            }
        }

        function stripCodeFences(s) {
            return String(s || '').replace(/```html/gi, '').replace(/```/g, '').trim();
        }

        function extractBodyParts(html) {
            const src = String(html || '');
            const openMatch = src.match(/<body\b[^>]*>/i);
            if (!openMatch) {
                return { hasBody: false, prefix: '', bodyInner: src, suffix: '' };
            }

            const openTag = openMatch[0];
            const openIdx = openMatch.index ?? src.toLowerCase().indexOf('<body');
            const startInner = openIdx + openTag.length;
            const lower = src.toLowerCase();
            const closeIdx = lower.lastIndexOf('</body>');
            if (closeIdx === -1) {
                return { hasBody: false, prefix: '', bodyInner: src, suffix: '' };
            }

            return {
                hasBody: true,
                prefix: src.slice(0, startInner),
                bodyInner: src.slice(startInner, closeIdx),
                suffix: src.slice(closeIdx)
            };
        }

        function extractBodyInnerFromAnyHtml(translated) {
            const s = String(translated || '');
            const openMatch = s.match(/<body\b[^>]*>/i);
            if (!openMatch) return s;
            const openIdx = openMatch.index ?? s.toLowerCase().indexOf('<body');
            const startInner = openIdx + openMatch[0].length;
            const closeIdx = s.toLowerCase().lastIndexOf('</body>');
            if (closeIdx === -1 || closeIdx < startInner) return s;
            return s.slice(startInner, closeIdx);
        }

        function isContentEffectivelyEmpty(html) {
            const div = document.createElement('div');
            div.innerHTML = String(html || '');
            // remove common non-text nodes
            div.querySelectorAll('img, svg, picture, script, style').forEach(n => n.remove());
            const text = (div.textContent || '').replace(/\s+/g, ' ').trim();
            return text.length === 0;
        }

        function prepareHtmlPlaceholders(bodyInnerHtml) {
            // Inspired by desktop PromptBuilder: preserve media, keep link text but strip attributes.
            const wrapperHtml = `<div id="_wrap">${bodyInnerHtml || ''}</div>`;
            const doc = new DOMParser().parseFromString(wrapperHtml, 'text/html');
            const wrap = doc.getElementById('_wrap');

            const mediaMap = {};
            const media = Array.from(wrap.querySelectorAll('img, svg, picture'));
            media.forEach((el, i) => {
                const key = `MEDIA_${i}`;
                mediaMap[key] = el.outerHTML;
                el.replaceWith(doc.createComment(key));
            });

            const linkMap = {};
            const links = Array.from(wrap.querySelectorAll('a'));
            links.forEach((a, i) => {
                const id = `link_${i}`;
                linkMap[id] = a.outerHTML;
                // keep inner HTML (so text is translated) but strip attributes
                for (const attr of Array.from(a.attributes)) a.removeAttribute(attr.name);
                a.setAttribute('id', id);
            });

            return {
                bodyInnerWithPlaceholders: wrap.innerHTML,
                mediaMap,
                linkMap
            };
        }

        function restorePlaceholders(translatedBodyInner, mediaMap, linkMap) {
            let s = String(translatedBodyInner || '');

            // Restore media placeholders by regex (comment may have spaces)
            for (const [key, tagHtml] of Object.entries(mediaMap || {})) {
                const re = new RegExp(`<!--\\s*${key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*-->`, 'g');
                s = s.replace(re, tagHtml);
            }

            // Restore links (keep translated innerHTML)
            if (linkMap && Object.keys(linkMap).length > 0) {
                const doc = new DOMParser().parseFromString(`<div id="_wrap">${s}</div>`, 'text/html');
                const wrap = doc.getElementById('_wrap');

                const anchors = Array.from(wrap.querySelectorAll('a[id^="link_"]'));
                for (const a of anchors) {
                    const id = a.getAttribute('id');
                    if (!id || !linkMap[id]) continue;

                    const origDoc = new DOMParser().parseFromString(linkMap[id], 'text/html');
                    const origA = origDoc.querySelector('a');
                    if (!origA) continue;

                    origA.innerHTML = a.innerHTML;
                    a.replaceWith(origA);
                }

                s = wrap.innerHTML;
            }

            return s;
        }

        function splitHtmlIntoChunksSmart(html, maxChars) {
            const s = String(html || '');
            if (s.length <= maxChars) return [s];

            const markers = ['</p>', '</div>', '</li>', '</h1>', '</h2>', '</h3>', '</h4>', '</h5>', '</h6>', '</blockquote>', '<br', '\n'];
            const out = [];
            let rest = s;

            while (rest.length > maxChars) {
                let cut = maxChars;
                let best = -1;
                for (const m of markers) {
                    const pos = rest.lastIndexOf(m, maxChars);
                    if (pos > best) best = pos + (m === '<br' ? 0 : m.length);
                }
                if (best > maxChars * 0.3) cut = best;

                out.push(rest.slice(0, cut));
                rest = rest.slice(cut);
            }
            if (rest.length) out.push(rest);
            return out;
        }

        const PLACEHOLDER_INSTRUCTION = `\n\n[СЛУЖЕБНЫЕ ПЛЕЙСХОЛДЕРЫ]\nВ тексте могут встречаться:\n1) HTML-комментарии вида <!--MEDIA_0-->, <!--MEDIA_1-->, ... (это изображения/медиа).\n2) Ссылки вида <a id="link_0">...<\/a> (id служит для восстановления атрибутов).\nОБЯЗАТЕЛЬНО: не удаляй и не изменяй эти комментарии/атрибуты id; не переводи текст внутри самих маркеров.\n`;

        async function translateTextWithPrompt(text, chunkSize) {
            const chunks = splitHtmlIntoChunksSmart(text, chunkSize);

            const parts = [];
            for (const chunk of chunks) {
                let glossaryText = '';
                if (Object.keys(state.glossary).length > 0) {
                    const maxTerms = parseInt(document.getElementById('max-glossary-terms').value) || 60;
                    const relevant = filterGlossary(state.glossary, chunk, maxTerms);
                    glossaryText = Object.entries(relevant).map(([k, v]) => `${k}: ${v.translation}`).join('\n');
                }

                const translationPromptTpl = document.getElementById('translation-prompt')?.value || DEFAULT_TRANSLATION_PROMPT;
                const prompt = translationPromptTpl
                    .replace('{glossary}', (glossaryText || 'Нет') + PLACEHOLDER_INSTRUCTION)
                    .replace('{text}', chunk);

                const translated = await callAI(prompt);
                parts.push(stripCodeFences(translated));
            }
            return parts.join('');
        }

        async function translateChapter(content, chunkSize) {
            const original = String(content || '');
            const parts = extractBodyParts(original);

            const prep = prepareHtmlPlaceholders(parts.bodyInner);
            if (isContentEffectivelyEmpty(prep.bodyInnerWithPlaceholders)) {
                // Nothing to translate (mostly media/empty tags)
                return original;
            }

            // Translate body-inner only; we will keep original head/styles/etc.
            const translatedRaw = await translateTextWithPrompt(prep.bodyInnerWithPlaceholders, chunkSize);
            const translatedBodyInner = extractBodyInnerFromAnyHtml(stripCodeFences(translatedRaw));

            const restoredBodyInner = restorePlaceholders(translatedBodyInner, prep.mediaMap, prep.linkMap);

            if (parts.hasBody) {
                return parts.prefix + restoredBodyInner + parts.suffix;
            }
            return restoredBodyInner;
        }

        function makeBatchPayloadNumeric(batchItems) {
            // batchItems: [{ idx:number, bodyInnerWithPlaceholders:string }]
            // Desktop-like: boundary markers "<!-- 0 --> ... <!-- 1 --> ... <!-- N -->"
            const parts = [];
            for (const item of batchItems) {
                parts.push(`<!-- ${item.idx} -->`);
                parts.push(item.bodyInnerWithPlaceholders);
                parts.push('');
            }
            parts.push(`<!-- ${batchItems.length} -->`);
            return parts.join('\n');
        }

        function findBoundaryMarkers(text) {
            const s = String(text || '');
            const markers = new Map();
            const re = /<!--\s*(\d+)\s*-->/g;
            let m;
            while ((m = re.exec(s)) !== null) {
                const id = Number(m[1]);
                if (!Number.isFinite(id)) continue;
                // store (start,end)
                markers.set(id, { start: m.index, end: m.index + m[0].length });
            }
            return markers;
        }

        function splitBatchedResponseNumeric(responseText, batchCount) {
            const s = String(responseText || '');
            const markers = findBoundaryMarkers(s);
            const map = new Map();

            for (let i = 0; i < batchCount; i++) {
                const a = markers.get(i);
                const b = markers.get(i + 1);
                if (!a || !b) continue;
                const body = s.slice(a.end, b.start).trim();
                map.set(i, body);
            }
            return map;
        }

        async function translateChaptersBatched(chapters, chunkSize) {
            // Batch translates BODY only. Restores media/links and reassembles full XHTML.
            const prepared = []; // array aligned to chapters[]

            for (const ch of chapters) {
                const original = String(ch.content || '');
                const parts = extractBodyParts(original);
                const prep = prepareHtmlPlaceholders(parts.bodyInner);

                if (isContentEffectivelyEmpty(prep.bodyInnerWithPlaceholders)) {
                    prepared.push({ skip: true, finalHtml: original, path: ch.path });
                } else {
                    prepared.push({
                        skip: false,
                        path: ch.path,
                        parts,
                        bodyInnerWithPlaceholders: prep.bodyInnerWithPlaceholders,
                        mediaMap: prep.mediaMap,
                        linkMap: prep.linkMap
                    });
                }
            }

            const batchItems = [];
            for (let i = 0; i < prepared.length; i++) {
                if (!prepared[i].skip) batchItems.push({ idx: batchItems.length, chapIndex: i, bodyInnerWithPlaceholders: prepared[i].bodyInnerWithPlaceholders });
            }

            // Nothing to translate
            if (batchItems.length === 0) {
                const res = new Map();
                for (const p of prepared) res.set(p.path, p.finalHtml);
                return res;
            }

            // Build glossary for whole batch once
            let glossaryText = '';
            if (Object.keys(state.glossary).length > 0) {
                const maxTerms = parseInt(document.getElementById('max-glossary-terms').value) || 60;
                const joined = chapters.map(c => String(c.content || '')).join('\n\n');
                const relevant = filterGlossary(state.glossary, joined, maxTerms);
                glossaryText = Object.entries(relevant).map(([k, v]) => `${k}: ${v.translation}`).join('\n');
            }

            const translationPromptTpl = document.getElementById('translation-prompt')?.value || DEFAULT_TRANSLATION_PROMPT;

            const instructions = `\n\n=== BATCH MODE ===\nНиже несколько документов, разделённых атомарными маркерами: <!-- 0 -->, <!-- 1 -->, ... <!-- N -->\nОБЯЗАТЕЛЬНО сохрани эти маркеры в ответе в том же порядке.\nВнутри каждого сегмента верни ТОЛЬКО переведённый HTML-фрагмент (содержимое body).\nНе добавляй пояснений/markdown/текст вне сегментов.\n`;

            const batchText = makeBatchPayloadNumeric(batchItems);
            const prompt = translationPromptTpl
                .replace('{glossary}', (glossaryText || 'Нет') + PLACEHOLDER_INSTRUCTION + instructions)
                .replace('{text}', batchText);

            const translated = await callAI(prompt);
            const cleaned = stripCodeFences(translated);

            const splitMap = splitBatchedResponseNumeric(cleaned, batchItems.length);

            const result = new Map();

            // Pre-fill skipped
            for (const p of prepared) {
                if (p.skip) result.set(p.path, p.finalHtml);
            }

            // Fill translated
            for (let bi = 0; bi < batchItems.length; bi++) {
                const payload = batchItems[bi];
                const chapIndex = payload.chapIndex;
                const meta = prepared[chapIndex];

                const piece = splitMap.get(bi);
                if (typeof piece !== 'string' || piece.trim().length === 0) continue;

                const translatedBodyInner = extractBodyInnerFromAnyHtml(piece);
                const restoredBodyInner = restorePlaceholders(translatedBodyInner, meta.mediaMap, meta.linkMap);

                if (meta.parts?.hasBody) result.set(meta.path, meta.parts.prefix + restoredBodyInner + meta.parts.suffix);
                else result.set(meta.path, restoredBodyInner);
            }

            return result;
        }

        function pauseTranslation() {
            state.isPaused = !state.isPaused;
            const btn = document.getElementById('pause-btn');
            if (state.isPaused) {
                btn.innerHTML = '<i class="fas fa-play mr-2"></i>Продолжить';
                log('Пауза', 'warning');
            } else {
                btn.innerHTML = '<i class="fas fa-pause mr-2"></i>Пауза';
                log('Продолжение', 'info');
            }
        }

        function cancelTranslation() {
            state.cancelRequested = true;
            state.isPaused = false;
            log('Отмена...', 'warning');
        }

        function updateProgress(percent, status, current, total) {
            document.getElementById('progress-bar').style.width = `${percent}%`;
            document.getElementById('progress-percent').textContent = `${percent}%`;
            document.getElementById('progress-status').textContent = status;
            document.getElementById('current-chapter').textContent = `${current}/${total}`;
            document.getElementById('tokens-in').textContent = formatNumber(state.stats.tokensIn);
            document.getElementById('tokens-out').textContent = formatNumber(state.stats.tokensOut);
        }

        async function callAI(prompt) {
            const provider = state.provider;
            const providerConfig = PROVIDERS_CONFIG[provider];
            const modelConfig = providerConfig.models[state.model];
            const keyManager = state.keys[provider];
            const maxRetries = parseInt(document.getElementById('max-retries').value) || 2;

            state.stats.tokensIn += Math.round(prompt.length / 3.5);

            if (providerConfig.local) {
                const modelConfigLocal = providerConfig.models[state.model];
                const baseUrl = modelConfigLocal.baseUrl || providerConfig.baseUrl;
                const result = await callLocalModel(baseUrl, modelConfigLocal.id, prompt, modelConfigLocal.maxOutputTokens);
                state.stats.tokensOut += Math.round(result.length / 3.5);
                return result;
            }

            const totalAttempts = Math.max(1, keyManager.count()) * maxRetries;

            for (let attempt = 0; attempt < totalAttempts; attempt++) {
                if (state.cancelRequested) throw new OperationCancelledError('Cancelled');

                const lease = await keyManager.acquireKey(modelConfig.id);
                if (!lease) { await sleep(250); attempt--; continue; }

                const apiKey = lease.key;
                document.getElementById('current-key-index').textContent = `${lease.index + 1}/${keyManager.count()}`;

                try {
                    await keyManager.waitForRateLimitFor(modelConfig.id, apiKey, modelConfig.rpm);

                    let result;
                    if (provider === 'gemini' || provider === 'gemini_top') {
                        result = await callGemini(apiKey, modelConfig, prompt);
                    } else {
                        result = await callOpenAICompatible(providerConfig.baseUrl, apiKey, modelConfig, prompt);
                    }

                    await keyManager.incrementRequestFor(modelConfig.id, apiKey, modelConfig.rpd);
                    state.stats.tokensOut += Math.round(result.length / 3.5);
                    saveState();
                    return result;

                } catch (e) {
                    if (e instanceof ContentBlockedError) throw e;

                    if (e instanceof TemporaryRateLimitError) {
                        log(`⏳ 429: пауза ключа ${lease.index + 1} на ${Math.ceil(e.delayMs / 1000)}с`, 'warning');
                        await keyManager.pauseKeyFor(modelConfig.id, apiKey, e.delayMs);
                        saveState();
                        await sleep(500);
                        continue;
                    }

                    if (e instanceof RateLimitExceededError) {
                        log(`⛔ Ключ ${lease.index + 1}: исчерпан/недоступен (${String(e.message || e).slice(0, 90)}...)`, 'warning');
                        await keyManager.markExhaustedFor(modelConfig.id, apiKey);
                        saveState();
                        await sleep(500);
                        continue;
                    }

                    if (e instanceof ModelNotFoundError) throw e;

                    if (e instanceof NetworkError) {
                        log(`🌐 Сеть: ${e.message} (ожидание ${Math.ceil(e.delayMs / 1000)}с)`, 'warning');
                        await sleep(e.delayMs);
                        continue;
                    }

                    const errStr = String(e?.message || e).toLowerCase();
                    if (errStr.includes('blocked') || errStr.includes('safety')) throw new ContentBlockedError(String(e?.message || e));
                    if (errStr.includes('429')) {
                        await keyManager.pauseKeyFor(modelConfig.id, apiKey, 60000);
                        saveState();
                        await sleep(500);
                        continue;
                    }
                    if (errStr.includes('quota') || errStr.includes('exhausted') || errStr.includes('invalid') || errStr.includes('401') || errStr.includes('403')) {
                        await keyManager.markExhaustedFor(modelConfig.id, apiKey);
                        saveState();
                        await sleep(500);
                        continue;
                    }

                    console.error('API Error:', e);
                    await sleep(1200);
                } finally {
                    try { lease.release(); } catch {}
                }
            }

            throw new AllKeysExhaustedError();
        }

        function parseRetryAfterSecondsFromHeaders(headers) {
            const ra = headers.get('retry-after');
            if (!ra) return null;
            const n = Number(ra);
            if (Number.isFinite(n) && n > 0) return n;
            return null;
        }

        function extractGeminiRetryDelayMs(errorText) {
            try {
                const j = JSON.parse(errorText);
                const err = j?.error || j;
                const details = err?.details;
                if (Array.isArray(details) && details[0]?.metadata?.retryInfo?.retryDelay?.seconds != null) {
                    const s = Number(details[0].metadata.retryInfo.retryDelay.seconds);
                    if (Number.isFinite(s) && s > 0) return Math.floor(s * 1000);
                }

                const seen = new Set();
                const stack = [err];
                while (stack.length) {
                    const cur = stack.pop();
                    if (!cur || typeof cur !== 'object') continue;
                    if (seen.has(cur)) continue;
                    seen.add(cur);
                    for (const [k, v] of Object.entries(cur)) {
                        const kl = String(k).toLowerCase();
                        if (kl.includes('retry') && kl.includes('delay')) {
                            if (typeof v === 'string' && v.endsWith('s')) {
                                const s = Number(v.slice(0, -1));
                                if (Number.isFinite(s) && s > 0) return Math.floor(s * 1000);
                            }
                            if (typeof v === 'number' && v > 0) return Math.floor(v * 1000);
                            if (v && typeof v === 'object' && v.seconds != null) {
                                const s = Number(v.seconds);
                                if (Number.isFinite(s) && s > 0) return Math.floor(s * 1000);
                            }
                        }
                        if (v && typeof v === 'object') stack.push(v);
                    }
                }
            } catch {}

            const m = String(errorText).match(/retry in ([\d.]+)s/i);
            if (m?.[1]) {
                const s = Number(m[1]);
                if (Number.isFinite(s) && s > 0) return Math.floor(s * 1000);
            }
            return null;
        }

        async function callGemini(apiKey, modelConfig, prompt) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelConfig.id}:generateContent?key=${apiKey}`;

            const body = {
                contents: [{ parts: [{ text: prompt }] }],
                safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                ],
                generationConfig: { maxOutputTokens: modelConfig.maxOutputTokens }
            };

            const systemPrompt = document.getElementById('system-prompt')?.value?.trim();
            if (systemPrompt) body.systemInstruction = { parts: [{ text: systemPrompt }] };

            if (modelConfig.minThinkingBudget !== undefined && modelConfig.minThinkingBudget !== false) {
                if (typeof modelConfig.minThinkingBudget === 'string') {
                    body.generationConfig.thinkingConfig = { thinkingLevel: String(modelConfig.minThinkingBudget).toUpperCase() };
                } else if (typeof modelConfig.minThinkingBudget === 'number' && modelConfig.minThinkingBudget >= 0) {
                    body.generationConfig.thinkingConfig = { thinkingBudget: modelConfig.minThinkingBudget };
                }
            }

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const text = await response.text();
                if (response.status === 404) throw new ModelNotFoundError(`Gemini 404: ${text}`);
                if (response.status === 401) throw new RateLimitExceededError(`Gemini ${response.status}: ${text}`);
                
                if (response.status === 429) {
                    const delayMsParsed = extractGeminiRetryDelayMs(text);
                    const lower = String(text || '').toLowerCase();

                    // Признаки "квота исчерпана" (не временный RPM)
                    const looksQuota =
                        lower.includes('resource_exhausted') ||
                        lower.includes('quota') ||
                        lower.includes('exceeded') ||
                        lower.includes('daily');

                    // Если сервер явно дал retryDelay — это временный лимит
                    if (delayMsParsed != null && !Number.isNaN(delayMsParsed)) {
                        throw new TemporaryRateLimitError(`Gemini 429: temporary limit`, delayMsParsed);
                    }

                    // Иначе, если похоже на квоту — считаем ключ "исчерпан" до ресета
                    if (looksQuota) {
                        const delayMs = extractGeminiRetryDelayMs(text) ?? 60000;
                    throw new TemporaryRateLimitError(`Gemini 429: temporary limit`, delayMs);
                    }

                    // Фоллбек: временно подождать
                    throw new TemporaryRateLimitError(`Gemini 429: rate limit`, 60000);
                }
    throw new NetworkError(`Gemini ${response.status}: ${text}`, 30000);
            }

            const data = await response.json();
            if (!data.candidates?.length) {
                if (data.promptFeedback?.blockReason) throw new ContentBlockedError(data.promptFeedback.blockReason);
                throw new NetworkError('Gemini: Empty response', 10000);
            }

            const candidate = data.candidates[0];
            if (candidate.finishReason === 'SAFETY' || candidate.finishReason === 'BLOCKED') throw new ContentBlockedError(candidate.finishReason);
            return candidate.content?.parts?.[0]?.text || '';
        }

        async function callOpenAICompatible(baseUrl, apiKey, modelConfig, prompt) {
            const systemPrompt = document.getElementById('system-prompt')?.value?.trim();
            const messages = [];
            if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
            messages.push({ role: 'user', content: prompt });

            const response = await fetch(baseUrl, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ model: modelConfig.id, messages, max_tokens: modelConfig.maxOutputTokens })
            });

            if (!response.ok) {
                const txt = await response.text();
                if (response.status === 404) throw new ModelNotFoundError(`API 404: ${txt}`);
                if (response.status === 401) throw new RateLimitExceededError(`API ${response.status}: ${txt}`);
                if (response.status === 429) {
                    const headerDelaySec = parseRetryAfterSecondsFromHeaders(response.headers);
                    const delayMs = headerDelaySec ? Math.floor(headerDelaySec * 1000) : 20000;
                    throw new TemporaryRateLimitError(`API 429: temporary limit`, delayMs);
                }
                throw new NetworkError(`API ${response.status}: ${txt}`, 30000);
            }

            const data = await response.json();
            if (!data.choices?.[0]?.message?.content) throw new NetworkError('Empty response', 10000);
            return data.choices[0].message.content;
        }

        // =============================================
        // RESULT & DOWNLOAD
        // =============================================
        function showResult() {
            document.getElementById('progress-panel').classList.add('hidden');
            document.getElementById('result-panel').classList.remove('hidden');

            const elapsed = Math.floor((Date.now() - state.stats.startTime) / 1000);
            document.getElementById('result-stats').innerHTML = `
                <div class="bg-white/5 rounded-lg p-3"><div class="text-gray-400">Глав</div><div class="font-medium">${state.translatedChapters.length}</div></div>
                <div class="bg-white/5 rounded-lg p-3"><div class="text-gray-400">Токены (вход)</div><div class="font-medium">${formatNumber(state.stats.tokensIn)}</div></div>
                <div class="bg-white/5 rounded-lg p-3"><div class="text-gray-400">Токены (выход)</div><div class="font-medium">${formatNumber(state.stats.tokensOut)}</div></div>
                <div class="bg-white/5 rounded-lg p-3"><div class="text-gray-400">Время</div><div class="font-medium">${Math.floor(elapsed / 60)}м ${elapsed % 60}с</div></div>
            `;
            log(`Завершено! ${state.translatedChapters.length} глав`, 'success');
            showToast('Перевод завершён!', 'success');
        }

        async function downloadEpub() {
            if (!state.translatedChapters.length) { showToast('Нет глав', 'error'); return; }
            if (!state.epubData?.zip) { showToast('Нет исходного EPUB в памяти', 'error'); return; }

            log('Сборка EPUB (обновление оригинала, сохранение стилей/обложки/картинок)...', 'info');

            const originalZip = state.epubData.zip;
            const outZip = new JSZip();
            const translationMap = new Map(state.translatedChapters.map(ch => [ch.path, ch.content]));

            const names = Object.keys(originalZip.files);
            let processed = 0;

            for (const name of names) {
                const fileObj = originalZip.files[name];
                if (fileObj.dir) { outZip.folder(name); continue; }

                if (translationMap.has(name)) {
                    outZip.file(name, translationMap.get(name));
                    processed++;
                    continue;
                }

                const data = await originalZip.file(name).async('uint8array');
                const opts = (name === 'mimetype') ? { compression: 'STORE' } : undefined;
                outZip.file(name, data, opts);
                processed++;
                if (processed % 25 === 0) await sleep(0);
            }

            const title = (state.currentFile?.name || 'Book').replace(/\.epub$/i, '');
            const blob = await outZip.generateAsync({ type: 'blob', mimeType: 'application/epub+zip' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${title}_RU.epub`;
            a.click();
            URL.revokeObjectURL(a.href);
            log('EPUB скачан (форматирование оригинала сохранено)', 'success');
        }

        function downloadGlossary() {
            if (!Object.keys(state.glossary).length) { showToast('Глоссарий пуст', 'warning'); return; }
            let content = '═'.repeat(60) + '\n  ГЛОССАРИЙ\n' + '═'.repeat(60) + '\n\n';
            content += `Терминов: ${Object.keys(state.glossary).length}\nДата: ${new Date().toLocaleString()}\n\n` + '─'.repeat(60) + '\n\n';

            Object.entries(state.glossary).forEach(([term, data], idx) => {
                content += `${idx + 1}. ${term}\n   → ${data.translation || 'N/A'}\n`;
                if (data.note) content += `   📝 ${data.note}\n`;
                content += '\n';
            });

            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'glossary.txt';
            a.click();
            URL.revokeObjectURL(a.href);
            log('Глоссарий скачан', 'success');
        }

        function openInValidator() {
            const originalByPath = new Map((state.epubData?.chapters || []).map(ch => [ch.path, ch]));
            state.validatorData.chapters = state.translatedChapters.map((ch, i) => ({ ...ch, original: originalByPath.get(ch.path) || null, index: i }));
            state.validatorData.currentIndex = 0;
            state.validatorData.validated = new Set();

            switchTab('validator');
            renderValidatorChapters();
            if (state.validatorData.chapters.length > 0) selectValidatorChapter(0);
        }

        function resetTranslation() {
            if (state.isTranslating) {
                showToast('Сначала остановите перевод', 'warning');
                return;
            }
            state.translatedChapters = [];
            state.stats = { tokensIn: 0, tokensOut: 0, startTime: null };
            state.currentFile = null;
            state.epubData = null;

            document.getElementById('result-panel').classList.add('hidden');
            document.getElementById('progress-panel').classList.add('hidden');
            document.getElementById('upload-area').classList.remove('hidden');
            document.getElementById('file-info').classList.add('hidden');
            document.getElementById('file-input').value = '';
            document.getElementById('dry-run-btn').disabled = true;

            log('Сброс сессии перевода', 'info');
        }

        // =============================================
        // GLOSSARY MANAGEMENT
        // =============================================
        function addGlossaryTerm() {
            const original = document.getElementById('new-term-original').value.trim();
            const translation = document.getElementById('new-term-translation').value.trim();
            const note = document.getElementById('new-term-note').value.trim();

            if (!original || !translation) { showToast('Заполните оригинал и перевод', 'warning'); return; }

            state.glossary[original] = { translation, note };
            saveState();
            updateGlossaryDisplay();

            document.getElementById('new-term-original').value = '';
            document.getElementById('new-term-translation').value = '';
            document.getElementById('new-term-note').value = '';

            showToast('Термин добавлен', 'success');
        }

        function removeGlossaryTerm(term) {
            delete state.glossary[term];
            saveState();
            updateGlossaryDisplay();
        }

        function searchGlossary() { updateGlossaryDisplay(); }

        function clearGlossary() {
            if (!confirm('Очистить глоссарий?')) return;
            state.glossary = {};
            saveState();
            updateGlossaryDisplay();
            log('Глоссарий очищен', 'info');
        }

        function importGlossary(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const text = e.target.result;
                    let parsed;

                    if (file.name.endsWith('.json')) {
                        parsed = JSON.parse(text);
                    } else {
                        parsed = {};
                        const lines = text.split('\n');
                        let currentTerm = null;

                        for (const line of lines) {
                            const termMatch = line.match(/^\d+\.\s*(.+)$/);
                            if (termMatch) {
                                currentTerm = termMatch[1].trim();
                            } else if (currentTerm && line.includes('→')) {
                                const translation = line.split('→')[1]?.trim();
                                if (translation) parsed[currentTerm] = { translation, note: '' };
                            }
                        }
                    }

                    if (typeof parsed === 'object') {
                        state.glossary = { ...state.glossary, ...parsed };
                        saveState();
                        updateGlossaryDisplay();
                        showToast(`Импортировано ${Object.keys(parsed).length} терминов`, 'success');
                    }
                } catch (err) {
                    showToast('Ошибка импорта', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // =============================================
        // VALIDATOR
        // =============================================
        function loadProjectForValidation() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.epub,.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (file.name.endsWith('.epub')) {
                    try {
                        const zip = await JSZip.loadAsync(file);
                        const chapters = await parseEpubStructure(zip);

                        state.validatorData.chapters = [];
                        for (const ch of chapters) {
                            const content = await zip.file(ch.path).async('string');
                            state.validatorData.chapters.push({ ...ch, content, original: null });
                        }

                        renderValidatorChapters();
                        if (state.validatorData.chapters.length > 0) selectValidatorChapter(0);
                        showToast('Проект загружен', 'success');
                    } catch (err) {
                        showToast('Ошибка загрузки', 'error');
                    }
                }
            };
            input.click();
        }

        function renderValidatorChapters() {
            const container = document.getElementById('validator-chapters');
            const chapters = state.validatorData.chapters;

            if (chapters.length === 0) {
                container.innerHTML = '<p class="text-gray-400 text-sm text-center py-8">Загрузите проект для проверки</p>';
                return;
            }

            container.innerHTML = chapters.map((ch, i) => {
                const isValidated = state.validatorData.validated.has(i);
                const isCurrent = state.validatorData.currentIndex === i;
                return `
                    <div onclick="selectValidatorChapter(${i})" class="chapter-row px-3 py-2 rounded-lg cursor-pointer transition ${isCurrent ? 'selected' : ''} ${isValidated ? 'opacity-50' : ''}">
                        <div class="flex items-center gap-2">
                            <i class="fas fa-${isValidated ? 'check-circle text-green-400' : 'circle text-gray-500'} text-xs"></i>
                            <span class="text-sm truncate">${escapeHtml(ch.title || `Глава ${i + 1}`)}</span>
                        </div>
                    </div>
                `;
            }).join('');

            const validatedCount = state.validatorData.validated.size;
            document.getElementById('validated-count').textContent = `${validatedCount}/${chapters.length}`;
            document.getElementById('validation-progress').style.width = `${(validatedCount / chapters.length) * 100}%`;
        }

        async function selectValidatorChapter(index) {
            state.validatorData.currentIndex = index;
            const chapter = state.validatorData.chapters[index];

            document.getElementById('current-chapter-name').textContent = chapter.title || `Глава ${index + 1}`;

            ['text', 'code', 'punct'].forEach(mode => {
                const btn = document.getElementById(`view-${mode}`);
                if (btn) btn.className = `px-3 py-1 rounded text-sm ${validatorViewMode === mode ? 'bg-indigo-600' : 'hover:bg-white/10'}`;
            });

            const translatedDiv = document.getElementById('translated-content');
            if (chapter.content) translatedDiv.innerHTML = formatContentForValidator(chapter.content, validatorViewMode);
            else translatedDiv.innerHTML = '<p class="text-gray-500">Нет перевода</p>';

            const originalDiv = document.getElementById('original-content');
            if (chapter.original && state.epubData) {
                try {
                    const originalContent = await state.epubData.zip.file(chapter.original.path || chapter.path).async('string');
                    originalDiv.innerHTML = formatContentForValidator(originalContent, validatorViewMode);
                } catch {
                    originalDiv.innerHTML = '<p class="text-gray-500">Оригинал недоступен</p>';
                }
            } else {
                originalDiv.innerHTML = '<p class="text-gray-500">Оригинал недоступен</p>';
            }

            const isValidated = state.validatorData.validated.has(index);
            document.getElementById('translation-status').innerHTML = isValidated
                ? '<span class="text-green-400"><i class="fas fa-check-circle mr-1"></i>Проверено</span>'
                : '<span class="text-yellow-400"><i class="fas fa-clock mr-1"></i>Ожидает проверки</span>';

            renderValidatorChapters();
        }

        function formatHtmlForDisplay(html) {
            const div = document.createElement('div');
            div.innerHTML = html;
            div.querySelectorAll('script, style').forEach(el => el.remove());
            return div.innerHTML;
        }

        function prevChapterValidator() {
            if (state.validatorData.currentIndex > 0) selectValidatorChapter(state.validatorData.currentIndex - 1);
        }

        function nextChapterValidator() {
            if (state.validatorData.currentIndex < state.validatorData.chapters.length - 1) selectValidatorChapter(state.validatorData.currentIndex + 1);
        }

        function markAsValidated() {
            state.validatorData.validated.add(state.validatorData.currentIndex);
            renderValidatorChapters();
            if (state.validatorData.currentIndex < state.validatorData.chapters.length - 1) setTimeout(() => nextChapterValidator(), 300);
            showToast('Глава подтверждена', 'success');
        }

        async function retryChapter() {
            try {
                if (!state.provider || !state.model) {
                    showToast('Сначала выберите провайдера и модель', 'warning');
                    switchTab('settings');
                    return;
                }
                if (!state.validatorData?.chapters?.length) {
                    showToast('Нет глав для переперевода', 'warning');
                    return;
                }

                const idx = state.validatorData.currentIndex;
                const chapter = state.validatorData.chapters[idx];

                if (!state.epubData?.zip) {
                    showToast('Оригинал недоступен. Откройте книгу через вкладку «Перевод» и нажмите «Проверить».', 'warning');
                    return;
                }

                const originalPath = chapter.original?.path || chapter.path;
                const fileObj = state.epubData.zip.file(originalPath);
                if (!fileObj) {
                    showToast('Не удалось найти оригинальную главу в EPUB', 'error');
                    return;
                }

                if (state.isTranslating) {
                    showToast('Нельзя перепереводить во время общего перевода', 'warning');
                    return;
                }

                const chunkSize = parseInt(document.getElementById('chunk-size').value) || 50000;

                log(`↻ Переперевод: ${chapter.title || originalPath}`, 'info');
                showToast('Переперевод главы…', 'info');

                // UI feedback
                document.getElementById('translated-content').innerHTML = '<p class="text-gray-400">Переперевод…</p>';

                const originalContent = await fileObj.async('string');
                const translated = await translateChapter(originalContent, chunkSize);

                // Update validator view
                state.validatorData.chapters[idx].content = translated;
                state.validatorData.validated.delete(idx);

                // Update translatedChapters storage (by path)
                const tIdx = state.translatedChapters.findIndex(c => c?.path === chapter.path);
                const record = { ...(chapter.original || chapter), path: chapter.path, title: chapter.title, content: translated };
                if (tIdx >= 0) state.translatedChapters[tIdx] = record;
                else state.translatedChapters.push(record);

                saveProjectState();

                await selectValidatorChapter(idx);
                showToast('Глава перепереведена', 'success');
                log(`↻ Глава перепереведена: ${chapter.title || originalPath}`, 'success');
            } catch (e) {
                console.error(e);
                showToast(`Ошибка переперевода: ${e?.message || e}`, 'error');
                log(`Ошибка переперевода: ${e?.message || e}`, 'error');
            }
        }

        // =============================================
        // PROJECT HISTORY
        // =============================================
        function saveProjectToHistory() {
            const project = {
                id: crypto.randomUUID(),
                name: state.currentFile?.name || 'Unknown',
                date: new Date().toISOString(),
                chapters: state.translatedChapters.length,
                glossaryCount: Object.keys(state.glossary).length,
                provider: state.provider,
                model: state.model
            };

            state.projectHistory.unshift(project);
            state.projectHistory = state.projectHistory.slice(0, 20);
            saveState();
        }

        function saveProjectState() {
            try {
                localStorage.setItem('epubTranslatorCurrentProject', JSON.stringify({
                    chapters: state.translatedChapters,
                    glossary: state.glossary,
                    stats: state.stats,
                    fileName: state.currentFile?.name
                }));
            } catch (e) {
                console.error('Auto-save error:', e);
            }
        }

        function loadProjectHistory() { /* already loaded via loadState */ }

        function showProjectHistory() {
            const modal = document.getElementById('project-history-modal');
            const list = document.getElementById('project-history-list');

            if (state.projectHistory.length === 0) {
                list.innerHTML = '<p class="text-gray-400 text-center py-8">История пуста</p>';
            } else {
                list.innerHTML = state.projectHistory.map(p => `
                    <div class="bg-white/5 rounded-xl p-4 hover:bg-white/10 transition">
                        <div class="flex items-center justify-between">
                            <div>
                                <p class="font-medium">${escapeHtml(p.name)}</p>
                                <p class="text-sm text-gray-400">${new Date(p.date).toLocaleString()}</p>
                            </div>
                            <div class="text-right text-sm">
                                <p>${p.chapters} глав</p>
                                <p class="text-gray-400">${p.glossaryCount} терминов</p>
                            </div>
                        </div>
                        <div class="mt-2 text-xs text-gray-500">
                            ${PROVIDERS_CONFIG[p.provider]?.displayName || p.provider} • ${escapeHtml(p.model)}
                        </div>
                    </div>
                `).join('');
            }

            modal.classList.remove('hidden');
        }

        function hideProjectHistory() { document.getElementById('project-history-modal').classList.add('hidden'); }

        function clearProjectHistory() {
            if (!confirm('Очистить историю проектов?')) return;
            state.projectHistory = [];
            saveState();
            showToast('История очищена', 'info');
        }

        // =============================================
        // SETTINGS
        // =============================================
        function exportSettings() {
            const keysToSave = {};
            for (const [provider, km] of Object.entries(state.keys)) { if (km?.keys) keysToSave[provider] = km.keys; }
            const data = {
                keys: keysToSave,
                provider: state.provider,
                model: state.model,
                glossary: state.glossary,
                projectHistory: state.projectHistory,
                settings: {
                    chunkSize: document.getElementById('chunk-size').value,
                    maxGlossaryTerms: document.getElementById('max-glossary-terms').value,
                    maxRetries: document.getElementById('max-retries').value,
                    createGlossary: document.getElementById('create-glossary').checked,
                    keepCensored: document.getElementById('keep-censored').checked,
                    autoSave: document.getElementById('auto-save').checked
                }
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'translator-settings.json';
            a.click();
            showToast('Настройки экспортированы', 'success');
        }

        function importSettings(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (data.keys) {
                        state.keys = {};
                        for (const [provider, keys] of Object.entries(data.keys)) {
                            if (keys.length > 0 && PROVIDERS_CONFIG[provider]) state.keys[provider] = new KeyManager(keys, PROVIDERS_CONFIG[provider].resetPolicy, provider);
                        }
                    }
                    if (data.provider) state.provider = data.provider;
                    if (data.model) state.model = data.model;
                    if (data.glossary) state.glossary = data.glossary;
                    if (data.projectHistory) state.projectHistory = data.projectHistory;
                    if (data.settings) {
                        document.getElementById('chunk-size').value = data.settings.chunkSize || 50000;
                        document.getElementById('max-glossary-terms').value = data.settings.maxGlossaryTerms || 60;
                        document.getElementById('max-retries').value = data.settings.maxRetries || 2;
                        document.getElementById('create-glossary').checked = data.settings.createGlossary !== false;
                        document.getElementById('keep-censored').checked = data.settings.keepCensored !== false;
                        document.getElementById('auto-save').checked = data.settings.autoSave !== false;
                        if (data.settings.enableBatching != null) document.getElementById('enable-batching').checked = !!data.settings.enableBatching;
                        if (data.settings.batchingMaxChars != null) document.getElementById('batching-max-chars').value = data.settings.batchingMaxChars;
                    }
                    saveState(); updateUI(); renderKeysList(); renderProviderList();
                    showToast('Настройки импортированы', 'success');
                } catch { showToast('Ошибка импорта', 'error'); }
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        function exportProject() {
            if (!state.translatedChapters?.length && !Object.keys(state.glossary || {}).length) {
                showToast('Нет данных проекта для экспорта', 'warning');
                return;
            }
            const payload = {
                version: '9.9.0-web-project',
                exportedAt: new Date().toISOString(),
                fileName: state.currentFile?.name || null,
                provider: state.provider,
                model: state.model,
                stats: state.stats,
                glossary: state.glossary,
                translatedChapters: state.translatedChapters
            };

            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            const base = (state.currentFile?.name || 'project').replace(/\.epub$/i, '');
            a.download = `${base}_project.json`;
            a.click();
            URL.revokeObjectURL(a.href);
            showToast('Проект экспортирован', 'success');
        }

        function importProjectFile(e) {
            const file = e.target.files[0];
            e.target.value = '';
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const data = JSON.parse(ev.target.result);
                    if (!data || typeof data !== 'object') throw new Error('Invalid JSON');

                    // restore safe fields
                    if (data.glossary && typeof data.glossary === 'object') state.glossary = data.glossary;
                    if (Array.isArray(data.translatedChapters)) state.translatedChapters = data.translatedChapters;
                    if (data.stats && typeof data.stats === 'object') state.stats = data.stats;

                    // optionally restore provider/model if available
                    if (data.provider && PROVIDERS_CONFIG[data.provider]) state.provider = data.provider;
                    if (data.model && state.provider && PROVIDERS_CONFIG[state.provider]?.models?.[data.model]) state.model = data.model;

                    // set pseudo current file name
                    if (data.fileName) state.currentFile = { name: data.fileName };

                    saveState();
                    updateUI();
                    renderProviderList();
                    renderModelList();

                    // show result panel if we have translations
                    if (state.translatedChapters?.length) {
                        document.getElementById('upload-area').classList.add('hidden');
                        document.getElementById('file-info').classList.add('hidden');
                        document.getElementById('progress-panel').classList.add('hidden');
                        document.getElementById('result-panel').classList.remove('hidden');
                        showResult();
                    } else {
                        showToast('Проект импортирован (без переводов)', 'success');
                    }

                    showToast('Проект импортирован', 'success');
                    log('Проект импортирован из файла', 'success');
                } catch (err) {
                    console.error(err);
                    showToast('Ошибка импорта проекта', 'error');
                }
            };
            reader.readAsText(file);
        }

        function clearAllData() {
            if (!confirm('Удалить все данные? Это действие необратимо.')) return;
            localStorage.removeItem('epubTranslatorState99');
            localStorage.removeItem('epubTranslatorCurrentProject');
            state = {
                keys: {},
                provider: null,
                model: null,
                glossary: {},
                currentFile: null,
                epubData: null,
                translatedChapters: [],
                isTranslating: false,
                isPaused: false,
                cancelRequested: false,
                stats: { tokensIn: 0, tokensOut: 0, startTime: null },
                projectHistory: [],
                validatorData: { chapters: [], currentIndex: 0, validated: new Set() }
            };
            updateUI(); renderKeysList(); renderProviderList();
            showToast('Данные удалены', 'info');
        }

        // =============================================
        // UTILITIES
        // =============================================
        function filterGlossary(glossary, text, maxTerms = 60) {
            const normalizedText = text.toLowerCase().normalize('NFKC');
            const found = {};
            const isCJK = LanguageDetector.isCJKText(text);

            for (const [term, data] of Object.entries(glossary)) {
                if (Object.keys(found).length >= maxTerms) break;
                const normalizedTerm = term.toLowerCase().normalize('NFKC');
                if (isCJK) {
                    if (normalizedText.replace(/\s+/g, '').includes(normalizedTerm.replace(/\s+/g, ''))) found[term] = data;
                } else {
                    try {
                        if (new RegExp(`\\b${normalizedTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i').test(normalizedText)) found[term] = data;
                    } catch {
                        if (normalizedText.includes(normalizedTerm)) found[term] = data;
                    }
                }
            }
            return found;
        }

        function extractText(html) { const div = document.createElement('div'); div.innerHTML = html; return div.textContent || ''; }

        function parseJSON(str) {
            if (!str || str.length > 1000000) return null;
            let cleaned = str.trim().replace(/```json/g, '').replace(/```/g, '');
            const start = cleaned.indexOf('{'), end = cleaned.lastIndexOf('}');
            if (start === -1 || end === -1) return null;
            cleaned = cleaned.slice(start, end + 1);
            try { return JSON.parse(cleaned); } catch { return repairJSON(cleaned); }
        }

        function repairJSON(str) {
            if (!str || str.length > 1000000) return null;
            const matches = [...str.matchAll(/\"([^\"]+)\":\s*\{/g)];
            if (!matches.length || matches.length > 100) return null;

            const pairs = [];
            for (let i = 0; i < matches.length; i++) {
                const key = matches[i][1];
                const contentStart = matches[i].index + matches[i][0].length;
                const contentEnd = i + 1 < matches.length ? matches[i + 1].index : str.length;
                let raw = str.slice(contentStart, contentEnd);
                if (raw.length > 50000) continue;

                let braces = 0, pos = -1, inStr = false;
                for (let j = 0; j < Math.min(raw.length, 10000); j++) {
                    if (raw[j] === '"' && (j === 0 || raw[j - 1] !== '\\')) inStr = !inStr;
                    else if (!inStr) {
                        if (raw[j] === '{') braces++;
                        else if (raw[j] === '}') { braces--; if (braces === -1) { pos = j; break; } }
                    }
                }

                if (pos !== -1) {
                    try {
                        JSON.parse('{' + raw.slice(0, pos + 1));
                        pairs.push([`\"${key}\"`, '{' + raw.slice(0, pos + 1)]);
                        continue;
                    } catch {}
                }

                for (let attempt = 1; attempt < 6; attempt++) {
                    const test = '{' + raw.rstrip(' \t\n\r,') + '}'.repeat(attempt);
                    try { JSON.parse(test); pairs.push([`\"${key}\"`, test]); break; } catch {}
                }
            }

            if (!pairs.length) return null;
            try { return JSON.parse(`{${pairs.map(([k, v]) => `${k}:${v}`).join(',')}}`); } catch { return null; }
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024, sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatNumber(num) { return Number(num || 0).toLocaleString(); }
        function escapeHtml(str) { const div = document.createElement('div'); div.textContent = String(str ?? ''); return div.innerHTML; }
        function escapeXml(str) { return String(str ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;'); }
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        String.prototype.rstrip = function(chars) {
            let end = this.length;
            while (end > 0 && chars.includes(this[end - 1])) end--;
            return this.slice(0, end);
        };

        // =============================================
        // PROMPT MANAGEMENT
        // =============================================
        const DEFAULT_TRANSLATION_PROMPT = `## РОЛЬ\n\nТы – **элитный локализатор-адаптолог**, чье мышление фундаментально русское. \nТвоя цель – **абсолютная естественность**: текст должен читаться так, будто изначально написан русским автором.\n\n## ГЛОССАРИЙ\n{glossary}\n\n## ПРАВИЛА ОФОРМЛЕНИЯ\n*   **Прямая речь:** Начинается с оператора \`─\`. Никогда не заключается в кавычки.\n*   **Мысли, цитаты:** Заключаются в кавычки-ёлочки \`«»\`.\n*   **Запрещено:** длинное тире \`—\`\n\n**Примеры:**\n\`\"Hello,\" he said.\` → \`─ Привет, ─ сказал он.\`\n\`'What a fool,' he thought.\` → \`«Какой же я дурак», – подумал он.\`\n\n## ТЕКСТ ДЛЯ ПЕРЕВОДА\n{text}\n\n**ВЫВОД:** Только XHTML код результата.`;

        const DEFAULT_GLOSSARY_PROMPT = `## РОЛЬ И АРХИТЕКТУРА СИСТЕМЫ\n\nТы – **Компилятор Глоссария**. Твоя задача – создать **конфигурационный JSON-файл** для последующей программной обработки.\n\n**ГЛАВНАЯ ПРОБЛЕМА: \"АМНЕЗИЯ ПЕРЕВОДЧИКА\"**\nИтоговый ИИ-Переводчик, который будет использовать твой глоссарий, **не имеет памяти**. Он видит только одну главу за раз.\nТвоя Задача: Создать глоссарий, который будет **внешней памятью** для этого \"слепого\" переводчика.\n\n**ПРИНЦИП ОТБОРА:**\n🟢 РАЗРЕШЕНО: Имена/Клички, Локации, Организации, Артефакты, Титулы, Способности\n🔴 ЗАПРЕЩЕНО: Глаголы, прилагательные, местоимения, обычные предметы\n\n**ПРАВИЛА:**\n1. Ключ = точная копия из текста\n2. translation = перевод на русский\n3. note = тип; пол/род; склонение\n\n**ТЕКСТ:**\n{text}\n\n**ФОРМАТ ВЫВОДА:** Только JSON без markdown:\n{\n  \"Term\": { \"translation\": \"Перевод\", \"note\": \"тип; род; описание\" }\n}`;

        const SYSTEM_PROMPT_PRESETS = {
            literary: `Ты — профессиональный литературный переводчик с многолетним опытом. Твой стиль — богатый, образный, избегающий канцеляризмов. Ты мастерски адаптируешь идиомы и культурные реалии, сохраняя дух оригинала.`,
            technical: `Ты — технический переводчик, специализирующийся на точности терминологии. Сохраняй все технические термины, числа и единицы измерения в точности. Избегай вольностей в переводе.`,
            fantasy: `Ты — переводчик фэнтези-литературы. Используй возвышенный, архаичный стиль для речи благородных персонажей. Сохраняй атмосферу магии и приключений. Имена и названия адаптируй с учётом благозвучности.`,
            wuxia: `Ты — переводчик китайских романов в жанре уся/культивация. Знаешь терминологию: культивация, ци, даньтянь, секты. Титулы переводи (Старейшина, Патриарх), имена транслитерируй. Сохраняй восточный колорит.`
        };

        function initPrompts() {
            document.getElementById('translation-prompt').value = localStorage.getItem('translationPrompt') || DEFAULT_TRANSLATION_PROMPT;
            document.getElementById('glossary-prompt').value = localStorage.getItem('glossaryPrompt') || DEFAULT_GLOSSARY_PROMPT;
            document.getElementById('system-prompt').value = localStorage.getItem('systemPrompt') || '';

            const keyMap = { 'translation-prompt': 'translationPrompt', 'glossary-prompt': 'glossaryPrompt', 'system-prompt': 'systemPrompt' };
            ['translation-prompt', 'glossary-prompt', 'system-prompt'].forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    localStorage.setItem(keyMap[id], document.getElementById(id).value);
                });
            });
        }

        function loadSystemPromptPreset() {
            const preset = document.getElementById('system-prompt-preset').value;
            if (preset && SYSTEM_PROMPT_PRESETS[preset]) {
                document.getElementById('system-prompt').value = SYSTEM_PROMPT_PRESETS[preset];
                localStorage.setItem('systemPrompt', SYSTEM_PROMPT_PRESETS[preset]);
            }
        }

        function resetTranslationPrompt() {
            document.getElementById('translation-prompt').value = DEFAULT_TRANSLATION_PROMPT;
            localStorage.setItem('translationPrompt', DEFAULT_TRANSLATION_PROMPT);
            showToast('Промпт сброшен', 'info');
        }

        function resetGlossaryPrompt() {
            document.getElementById('glossary-prompt').value = DEFAULT_GLOSSARY_PROMPT;
            localStorage.setItem('glossaryPrompt', DEFAULT_GLOSSARY_PROMPT);
            showToast('Промпт сброшен', 'info');
        }

        // =============================================
        // DRY RUN
        // =============================================
        let dryRunChapterIndex = 0;

        function showDryRunModal() {
            if (!state.epubData?.chapters?.length) { showToast('Сначала загрузите EPUB', 'warning'); return; }

            const select = document.getElementById('dry-run-chapter');
            select.innerHTML = state.epubData.chapters.map((ch, i) =>
                `<option value="${i}">Глава ${i + 1}: ${escapeHtml(ch.title || ch.path.split('/').pop())}</option>`
            ).join('');

            document.getElementById('dry-run-modal').classList.remove('hidden');
            document.getElementById('manual-response-section').classList.add('hidden');
        }

        function hideDryRunModal() { document.getElementById('dry-run-modal').classList.add('hidden'); }

        async function generateDryRunPrompt() {
            const chapterIdx = parseInt(document.getElementById('dry-run-chapter').value);
            dryRunChapterIndex = chapterIdx;
            if (!state.epubData?.chapters?.[chapterIdx]) return;

            const chapter = state.epubData.chapters[chapterIdx];
            const content = await state.epubData.zip.file(chapter.path).async('string');

            let glossaryText = 'Нет';
            if (Object.keys(state.glossary).length > 0) {
                const maxTerms = parseInt(document.getElementById('max-glossary-terms').value) || 60;
                const relevant = filterGlossary(state.glossary, content, maxTerms);
                glossaryText = Object.entries(relevant).map(([k, v]) => `${k}: ${v.translation}`).join('\n');
            }

            const translationPrompt = document.getElementById('translation-prompt').value || DEFAULT_TRANSLATION_PROMPT;
            const systemPrompt = document.getElementById('system-prompt').value;

            let fullPrompt = '';
            if (systemPrompt) fullPrompt += `=== СИСТЕМНАЯ ИНСТРУКЦИЯ ===\n${systemPrompt}\n\n=== ПРОМПТ ПЕРЕВОДА ===\n`;

            fullPrompt += translationPrompt
                .replace('{glossary}', glossaryText)
                .replace('{text}', content.slice(0, 5000) + (content.length > 5000 ? '\n\n... [текст обрезан для превью] ...' : ''));

            document.getElementById('dry-run-content').textContent = fullPrompt;
        }

        function copyDryRunPrompt() {
            const content = document.getElementById('dry-run-content').textContent;
            navigator.clipboard.writeText(content);
            showToast('Промпт скопирован в буфер', 'success');
        }

        function showManualResponseInput() { document.getElementById('manual-response-section').classList.remove('hidden'); }
        function hideManualResponseInput() { document.getElementById('manual-response-section').classList.add('hidden'); }

        async function applyManualResponse() {
            const response = document.getElementById('manual-response-input').value.trim();
            if (!response) { showToast('Введите ответ', 'warning'); return; }
            if (!state.epubData?.chapters?.[dryRunChapterIndex]) { showToast('Глава не найдена', 'error'); return; }

            const chapter = state.epubData.chapters[dryRunChapterIndex];
            const existingIdx = state.translatedChapters.findIndex(c => c?.path === chapter.path);
            const record = { ...chapter, content: response };

            if (existingIdx >= 0) state.translatedChapters[existingIdx] = record;
            else state.translatedChapters.push(record);

            showToast(`Глава ${dryRunChapterIndex + 1} сохранена из ручного ввода`, 'success');
            hideDryRunModal();

            if (state.translatedChapters.filter(Boolean).length > 0) {
                document.getElementById('result-panel').classList.remove('hidden');
            }
        }

        // =============================================
        // GLOSSARY CONFLICT ANALYSIS
        // =============================================
        function analyzeGlossaryConflicts() {
            if (Object.keys(state.glossary).length < 2) { showToast('Недостаточно терминов для анализа', 'info'); return; }

            const conflicts = { direct: [], reverse: [], overlap: [] };
            const terms = Object.entries(state.glossary);
            const translationMap = {};

            for (const [term, data] of terms) {
                const translation = data.translation?.toLowerCase() || '';
                if (translationMap[translation]) {
                    conflicts.reverse.push({ term1: translationMap[translation], term2: term, translation });
                } else {
                    translationMap[translation] = term;
                }

                for (const [otherTerm] of terms) {
                    if (term !== otherTerm && term.length > 3 && otherTerm.includes(term)) conflicts.overlap.push({ shorter: term, longer: otherTerm });
                }
            }

            const totalConflicts = conflicts.direct.length + conflicts.reverse.length + conflicts.overlap.length;

            if (totalConflicts === 0) {
                showToast('Конфликтов не найдено ✓', 'success');
                document.getElementById('glossary-conflicts').classList.add('hidden');
                return;
            }

            const listHtml = [];
            if (conflicts.reverse.length > 0) {
                listHtml.push(`<div class="text-purple-400 font-medium">Обратные конфликты (одинаковый перевод):</div>`);
                conflicts.reverse.slice(0, 5).forEach(c => {
                    listHtml.push(`<div class="conflict-reverse pl-3 py-1">"${escapeHtml(c.term1)}" и "${escapeHtml(c.term2)}" → "${escapeHtml(c.translation)}"</div>`);
                });
            }

            if (conflicts.overlap.length > 0) {
                listHtml.push(`<div class="text-yellow-400 font-medium mt-2">Наложения (термин внутри другого):</div>`);
                conflicts.overlap.slice(0, 5).forEach(c => {
                    listHtml.push(`<div class="conflict-overlap pl-3 py-1">"${escapeHtml(c.shorter)}" ⊂ "${escapeHtml(c.longer)}"</div>`);
                });
            }

            document.getElementById('conflicts-list').innerHTML = listHtml.join('');
            document.getElementById('glossary-conflicts').classList.remove('hidden');
            showToast(`Найдено ${totalConflicts} потенциальных проблем`, 'warning');
        }

        // =============================================

        // =============================================
        // GLOSSARY MANUAL RESOLVER (desktop-inspired conflict_resolvers.py)
        // =============================================
        const glossaryResolverState = {
            visible: false,
            mode: 'reverse',
            overlapView: 'short_to_long',
            groups: [],
            selectedGroupId: null,
            checkedIds: new Set(),
            wizard: false,
            wizardOrder: [],
            wizardIndex: -1
        };

        function toB64(str) {
            try { return btoa(unescape(encodeURIComponent(String(str ?? '')))); }
            catch { return btoa(String(str ?? '')); }
        }
        function fromB64(b64) {
            try { return decodeURIComponent(escape(atob(String(b64 || '')))); }
            catch { return atob(String(b64 || '')); }
        }

        function showGlossaryResolverModal() {
            if (!Object.keys(state.glossary || {}).length) {
                showToast('Глоссарий пуст', 'warning');
                return;
            }

            // init state
            glossaryResolverState.visible = true;
            glossaryResolverState.mode = document.getElementById('gr-mode')?.value || 'reverse';
            glossaryResolverState.overlapView = 'short_to_long';
            glossaryResolverState.selectedGroupId = null;
            glossaryResolverState.checkedIds = new Set(loadGlossaryResolverChecked(glossaryResolverState.mode));
            glossaryResolverState.wizard = !!document.getElementById('gr-wizard')?.checked;
            glossaryResolverState.wizardOrder = [];
            glossaryResolverState.wizardIndex = -1;

            // bind events (idempotent)
            const modeEl = document.getElementById('gr-mode');
            if (modeEl && !modeEl._bound) {
                modeEl.addEventListener('change', () => glossaryResolverSetMode(modeEl.value));
                modeEl._bound = true;
            }
            const searchEl = document.getElementById('gr-search');
            if (searchEl && !searchEl._bound) {
                searchEl.addEventListener('input', () => glossaryResolverRenderList());
                searchEl._bound = true;
            }
            const wizardEl = document.getElementById('gr-wizard');
            if (wizardEl && !wizardEl._bound) {
                wizardEl.addEventListener('change', () => {
                    glossaryResolverState.wizard = wizardEl.checked;
                    glossaryResolverUpdateWizardMode();
                });
                wizardEl._bound = true;
            }
            const checkedEl = document.getElementById('gr-checked');
            if (checkedEl && !checkedEl._bound) {
                checkedEl.addEventListener('change', () => {
                    if (!glossaryResolverState.selectedGroupId) return;
                    if (checkedEl.checked) glossaryResolverState.checkedIds.add(glossaryResolverState.selectedGroupId);
                    else glossaryResolverState.checkedIds.delete(glossaryResolverState.selectedGroupId);
                    saveGlossaryResolverChecked(glossaryResolverState.mode, glossaryResolverState.checkedIds);
                    glossaryResolverRenderList();
                    if (glossaryResolverState.wizard) glossaryResolverUpdateWizardMode(true);
                });
                checkedEl._bound = true;
            }

            // show
            document.getElementById('glossary-resolver-modal').classList.remove('hidden');
            glossaryResolverBuildGroups();
            glossaryResolverRenderList();
            glossaryResolverSelectFirstVisible();
            glossaryResolverUpdateWizardMode();
        }

        function hideGlossaryResolverModal() {
            glossaryResolverState.visible = false;
            document.getElementById('glossary-resolver-modal').classList.add('hidden');
        }

        function loadGlossaryResolverChecked(mode) {
            try {
                const raw = localStorage.getItem(`glossaryResolverChecked:${mode}`);
                if (!raw) return [];
                const arr = JSON.parse(raw);
                return Array.isArray(arr) ? arr : [];
            } catch {
                return [];
            }
        }

        function saveGlossaryResolverChecked(mode, checkedSet) {
            try {
                localStorage.setItem(`glossaryResolverChecked:${mode}`, JSON.stringify(Array.from(checkedSet || [])));
            } catch {}
        }

        function glossaryResolverSetMode(mode) {
            glossaryResolverState.mode = mode || 'reverse';
            glossaryResolverState.overlapView = 'short_to_long';
            glossaryResolverState.checkedIds = new Set(loadGlossaryResolverChecked(glossaryResolverState.mode));
            glossaryResolverState.selectedGroupId = null;
            glossaryResolverBuildGroups();
            glossaryResolverRenderList();
            glossaryResolverSelectFirstVisible();
            glossaryResolverUpdateWizardMode();
        }

        function glossaryResolverToggleOverlapView() {
            if (glossaryResolverState.mode !== 'overlap') return;
            glossaryResolverState.overlapView = (glossaryResolverState.overlapView === 'short_to_long') ? 'long_to_short' : 'short_to_long';
            glossaryResolverBuildGroups();
            glossaryResolverRenderList();
            glossaryResolverSelectFirstVisible();
            glossaryResolverUpdateWizardMode();
        }

        function glossaryResolverBuildGroups() {
            const mode = glossaryResolverState.mode;
            const g = state.glossary || {};
            const entries = Object.entries(g);

            const groups = [];

            if (mode === 'reverse') {
                // translation -> terms
                const map = new Map();
                for (const [term, data] of entries) {
                    const tr = String(data?.translation || '').trim();
                    if (!tr) continue;
                    const k = tr.toLowerCase();
                    if (!map.has(k)) map.set(k, { translation: tr, terms: [] });
                    map.get(k).terms.push(term);
                }
                for (const { translation, terms } of map.values()) {
                    if (terms.length < 2) continue;
                    const id = `reverse:${translation.toLowerCase()}`;
                    groups.push({
                        id,
                        kind: 'reverse',
                        title: translation,
                        subtitle: `${terms.length} оригиналов`,
                        terms: terms.slice().sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
                    });
                }
                groups.sort((a, b) => b.terms.length - a.terms.length || a.title.localeCompare(b.title, 'ru'));
            } else if (mode === 'direct') {
                // group Term#2-like duplicates by base name
                const baseMap = new Map();
                for (const [term] of entries) {
                    const m = String(term).match(/^(.*?)(?:#(\d+))$/);
                    if (!m) continue;
                    const base = m[1].trim();
                    if (!base) continue;
                    if (!baseMap.has(base)) baseMap.set(base, new Set([base]));
                    baseMap.get(base).add(term);
                }
                for (const [base, set] of baseMap.entries()) {
                    // include base itself only if exists in glossary
                    const terms = Array.from(set).filter(t => g[t]);
                    if (terms.length < 2) continue;
                    const id = `direct:${base.toLowerCase()}`;
                    groups.push({
                        id,
                        kind: 'direct',
                        title: base,
                        subtitle: `${terms.length} версий`,
                        terms: terms.slice().sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
                    });
                }
                groups.sort((a, b) => b.terms.length - a.terms.length || a.title.localeCompare(b.title, 'ru'));
            } else {
                // overlap
                const terms = entries.map(([t]) => String(t));
                const minLen = 3;
                // sort by length
                const sorted = terms.slice().sort((a, b) => a.length - b.length || a.localeCompare(b, undefined, { numeric: true }));

                const shortToLong = new Map();
                const longToShort = new Map();

                // O(n^2) but glossary usually manageable. Add safety cap.
                const maxPairs = 60000;
                let pairs = 0;
                for (let i = 0; i < sorted.length; i++) {
                    const a = sorted[i];
                    if (!a || a.length < minLen) continue;
                    for (let j = i + 1; j < sorted.length; j++) {
                        const b = sorted[j];
                        if (!b || b.length < minLen) continue;
                        if (pairs++ > maxPairs) break;
                        if (b.includes(a)) {
                            if (!shortToLong.has(a)) shortToLong.set(a, new Set());
                            shortToLong.get(a).add(b);

                            if (!longToShort.has(b)) longToShort.set(b, new Set());
                            longToShort.get(b).add(a);
                        }
                    }
                    if (pairs > maxPairs) break;
                }

                const view = glossaryResolverState.overlapView;
                const source = (view === 'short_to_long') ? shortToLong : longToShort;
                for (const [k, set] of source.entries()) {
                    const list = Array.from(set);
                    if (list.length === 0) continue;
                    const id = `overlap:${view}:${k.toLowerCase()}`;
                    groups.push({
                        id,
                        kind: 'overlap',
                        view,
                        title: k,
                        subtitle: (view === 'short_to_long') ? `внутри ${list.length} терминов` : `включает ${list.length} терминов`,
                        terms: [k, ...list.sort((a, b) => a.length - b.length || a.localeCompare(b, undefined, { numeric: true }))]
                    });
                }
                groups.sort((a, b) => (b.terms.length - a.terms.length) || a.title.localeCompare(b.title, 'ru'));

                // toggle button state
                const toggleBtn = document.getElementById('gr-toggle-view');
                if (toggleBtn) toggleBtn.disabled = false;
            }

            if (mode !== 'overlap') {
                const toggleBtn = document.getElementById('gr-toggle-view');
                if (toggleBtn) toggleBtn.disabled = true;
            }

            glossaryResolverState.groups = groups;
            const summary = document.getElementById('gr-summary');
            if (summary) summary.textContent = `${groups.length} групп`;
        }

        function glossaryResolverRenderList() {
            const list = document.getElementById('gr-list');
            if (!list) return;

            const q = String(document.getElementById('gr-search')?.value || '').trim().toLowerCase();
            const groups = glossaryResolverState.groups.filter(g => {
                if (!q) return true;
                return (g.title || '').toLowerCase().includes(q) || (g.subtitle || '').toLowerCase().includes(q) || (g.terms || []).some(t => String(t).toLowerCase().includes(q));
            });

            if (groups.length === 0) {
                list.innerHTML = '<div class="text-gray-500 text-sm text-center py-10">Группы не найдены</div>';
                return;
            }

            list.innerHTML = groups.map(g => {
                const isSelected = glossaryResolverState.selectedGroupId === g.id;
                const isChecked = glossaryResolverState.checkedIds.has(g.id);
                return `
                    <div class="chapter-row px-3 py-2 rounded-lg cursor-pointer transition ${isSelected ? 'selected' : ''} ${isChecked ? 'opacity-60' : ''}" onclick="glossaryResolverSelectGroup('${escapeXml(g.id)}')">
                        <div class="flex items-center gap-2">
                            <i class="fas fa-${isChecked ? 'check-circle text-green-400' : 'circle text-gray-500'} text-xs"></i>
                            <div class="flex-1 min-w-0">
                                <div class="text-sm font-medium truncate">${escapeHtml(g.title)}</div>
                                <div class="text-xs text-gray-500 truncate">${escapeHtml(g.subtitle || '')}</div>
                            </div>
                            <span class="text-xs text-gray-500">${g.terms?.length || 0}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function glossaryResolverSelectFirstVisible() {
            const q = String(document.getElementById('gr-search')?.value || '').trim().toLowerCase();
            const groups = glossaryResolverState.groups.filter(g => {
                if (!q) return true;
                return (g.title || '').toLowerCase().includes(q) || (g.subtitle || '').toLowerCase().includes(q) || (g.terms || []).some(t => String(t).toLowerCase().includes(q));
            });
            if (groups.length === 0) {
                glossaryResolverState.selectedGroupId = null;
                glossaryResolverRenderEditor(null);
                return;
            }
            glossaryResolverSelectGroup(groups[0].id);
        }

        function glossaryResolverSelectGroup(groupId) {
            glossaryResolverState.selectedGroupId = groupId;
            const g = glossaryResolverState.groups.find(x => x.id === groupId) || null;

            // update checked box
            const checkedEl = document.getElementById('gr-checked');
            if (checkedEl) checkedEl.checked = glossaryResolverState.checkedIds.has(groupId);

            // update header
            document.getElementById('gr-current-title').textContent = g ? g.title : '—';
            document.getElementById('gr-current-subtitle').textContent = g ? (g.subtitle || '') : '—';

            glossaryResolverRenderList();
            glossaryResolverRenderEditor(g);
        }

        function glossaryResolverRenderEditor(group) {
            const editor = document.getElementById('gr-editor');
            if (!editor) return;
            if (!group) {
                editor.innerHTML = '<div class="text-gray-400">Выберите группу слева.</div>';
                return;
            }

            const g = state.glossary || {};
            const rowsHtml = (group.terms || []).map((term, idx) => {
                const data = g[term] || {};
                const tr = String(data.translation || '');
                const note = String(data.note || '');
                const termB64 = toB64(term);

                const emphasize = (idx === 0 && group.kind === 'overlap');
                const rowClass = emphasize ? 'border-emerald-500/40 bg-emerald-500/5' : 'border-white/10 bg-white/5';

                return `
                    <div class="border ${rowClass} rounded-xl p-3 mb-3">
                        <div class="flex items-center justify-between gap-3 mb-2">
                            <div class="min-w-0">
                                <div class="text-xs text-gray-400">Оригинал</div>
                                <div class="font-mono text-sm truncate">${escapeHtml(term)}</div>
                            </div>
                            <label class="flex items-center gap-2 text-sm cursor-pointer">
                                <input type="checkbox" class="w-4 h-4" data-del-term="${escapeXml(termB64)}">
                                <span class="text-gray-300">Удалить</span>
                            </label>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Перевод</div>
                                <input class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm" data-term-tr="${escapeXml(termB64)}" value="${escapeXml(tr)}" placeholder="Перевод...">
                            </div>
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Примечание</div>
                                <input class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm" data-term-note="${escapeXml(termB64)}" value="${escapeXml(note)}" placeholder="Примечание...">
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Direct duplicates: offer "keep only one" helper
            let directHint = '';
            if (group.kind === 'direct') {
                directHint = `
                    <div class="mb-3 p-3 rounded-xl bg-yellow-500/10 border border-yellow-500/30 text-yellow-200 text-sm">
                        Это группа «версий» (например, <code class="bg-white/10 px-1 rounded">Term</code> и <code class="bg-white/10 px-1 rounded">Term#2</code>). Обычно нужно оставить одну и удалить остальные.
                        <div class="mt-2">
                            <button onclick="glossaryResolverKeepFirstDeleteRest()" class="px-3 py-2 bg-yellow-600/20 hover:bg-yellow-600/30 rounded-lg transition text-sm">
                                <i class="fas fa-broom mr-1"></i>Оставить первую, удалить остальные
                            </button>
                        </div>
                    </div>
                `;
            }

            editor.innerHTML = `
                <div class="text-sm text-gray-300 mb-3">Отредактируйте перевод/примечание и нажмите «Применить».</div>
                ${directHint}
                ${rowsHtml || '<div class="text-gray-500">Нет терминов</div>'}
            `;
        }

        function glossaryResolverKeepFirstDeleteRest() {
            const g = glossaryResolverState.groups.find(x => x.id === glossaryResolverState.selectedGroupId);
            if (!g || !g.terms?.length) return;
            const terms = g.terms;
            // keep first, delete rest
            for (let i = 1; i < terms.length; i++) {
                const termB64 = toB64(terms[i]);
                const box = document.querySelector(`input[data-del-term="${CSS.escape(termB64)}"]`);
                if (box) box.checked = true;
            }
        }

        function glossaryResolverApplyEdits() {
            const groupId = glossaryResolverState.selectedGroupId;
            const group = glossaryResolverState.groups.find(x => x.id === groupId);
            if (!group) {
                showToast('Группа не выбрана', 'warning');
                return;
            }

            let changed = 0;
            let deleted = 0;

            // apply edits
            for (const term of (group.terms || [])) {
                const termB64 = toB64(term);
                const delBox = document.querySelector(`input[data-del-term="${CSS.escape(termB64)}"]`);
                const wantDelete = !!delBox?.checked;

                if (wantDelete) {
                    if (state.glossary[term]) {
                        delete state.glossary[term];
                        deleted++;
                        changed++;
                    }
                    continue;
                }

                const trEl = document.querySelector(`input[data-term-tr="${CSS.escape(termB64)}"]`);
                const noteEl = document.querySelector(`input[data-term-note="${CSS.escape(termB64)}"]`);
                const newTr = String(trEl?.value || '').trim();
                const newNote = String(noteEl?.value || '').trim();

                if (!newTr) {
                    // protect from accidental wipe
                    continue;
                }

                const before = state.glossary[term] || { translation: '', note: '' };
                const beforeT = String(before.translation || '').trim();
                const beforeN = String(before.note || '').trim();
                if (beforeT !== newTr || beforeN !== newNote) {
                    state.glossary[term] = { translation: newTr, note: newNote };
                    changed++;
                }
            }

            if (changed === 0) {
                showToast('Нет изменений', 'info');
                return;
            }

            saveState();
            updateGlossaryDisplay();
            showToast(`Применено: ${changed} (удалено ${deleted})`, 'success');
            log(`[Resolver] Применено: ${changed} изменений`, 'success');

            // mark checked
            glossaryResolverState.checkedIds.add(groupId);
            saveGlossaryResolverChecked(glossaryResolverState.mode, glossaryResolverState.checkedIds);
            glossaryResolverRenderList();
            if (glossaryResolverState.wizard) glossaryResolverUpdateWizardMode(true);
        }

        function glossaryResolverUpdateWizardMode(keepPosition = false) {
            const ctr = document.getElementById('gr-wizard-controls');
            const list = document.getElementById('gr-list');
            if (!ctr || !list) return;

            if (!glossaryResolverState.wizard) {
                ctr.classList.add('hidden');
                list.classList.remove('opacity-80', 'pointer-events-none');
                return;
            }

            ctr.classList.remove('hidden');
            list.classList.add('opacity-80', 'pointer-events-none');

            glossaryResolverState.wizardOrder = glossaryResolverState.groups
                .map(g => g.id)
                .filter(id => !glossaryResolverState.checkedIds.has(id));

            if (!keepPosition) glossaryResolverState.wizardIndex = 0;
            if (glossaryResolverState.wizardOrder.length === 0) {
                showToast('Все группы уже помечены как проверенные', 'success');
                glossaryResolverState.wizardIndex = -1;
                return;
            }

            if (glossaryResolverState.wizardIndex < 0) glossaryResolverState.wizardIndex = 0;
            if (glossaryResolverState.wizardIndex >= glossaryResolverState.wizardOrder.length) glossaryResolverState.wizardIndex = glossaryResolverState.wizardOrder.length - 1;

            glossaryResolverSelectGroup(glossaryResolverState.wizardOrder[glossaryResolverState.wizardIndex]);
        }

        function glossaryResolverWizardNext() {
            if (!glossaryResolverState.wizard) return;
            if (glossaryResolverState.wizardOrder.length === 0) return;
            glossaryResolverState.wizardIndex = Math.min(glossaryResolverState.wizardOrder.length - 1, glossaryResolverState.wizardIndex + 1);
            glossaryResolverSelectGroup(glossaryResolverState.wizardOrder[glossaryResolverState.wizardIndex]);
        }

        function glossaryResolverWizardPrev() {
            if (!glossaryResolverState.wizard) return;
            if (glossaryResolverState.wizardOrder.length === 0) return;
            glossaryResolverState.wizardIndex = Math.max(0, glossaryResolverState.wizardIndex - 1);
            glossaryResolverSelectGroup(glossaryResolverState.wizardOrder[glossaryResolverState.wizardIndex]);
        }

        // =============================================
        // GROUP ANALYZER (web port of group_analyzer.py)
        // =============================================
        const groupAnalyzerState = {
            visible: false,
            wordToTerms: new Map(),
            wordCounts: new Map(),
            lastItems: [],
            selectedWords: new Set(),
            ignoreWords: new Set(['для','или','под','над','без','при','про','как','the','and','for','with','of','in']),
            minLen: 3,
            minCount: 3,
            maxCount: 10,
        };

        function showGroupAnalyzerModal() {
            if (!Object.keys(state.glossary || {}).length) {
                showToast('Глоссарий пуст', 'warning');
                return;
            }

            // auto maxCount = max(10, len * 0.3)
            const total = Object.keys(state.glossary || {}).length;
            const autoMax = Math.max(10, Math.floor(total * 0.3));
            const maxEl = document.getElementById('ga-max-count');
            if (maxEl) maxEl.value = String(autoMax);

            document.getElementById('group-analyzer-modal').classList.remove('hidden');
            groupAnalyzerState.visible = true;

            // bind once
            const selAll = document.getElementById('ga-select-all');
            if (selAll && !selAll._bound) {
                selAll.addEventListener('change', () => {
                    const checked = selAll.checked;
                    groupAnalyzerState.selectedWords = new Set();
                    for (const it of groupAnalyzerState.lastItems) {
                        if (checked) groupAnalyzerState.selectedWords.add(it.word);
                    }
                    groupAnalyzerRenderTable();
                });
                selAll._bound = true;
            }

            groupAnalyzerRefresh(true);
        }

        function hideGroupAnalyzerModal() {
            groupAnalyzerState.visible = false;
            document.getElementById('group-analyzer-modal').classList.add('hidden');
        }

        function groupAnalyzerReadFilters() {
            const minLen = parseInt(document.getElementById('ga-min-len')?.value || '3');
            const minCount = parseInt(document.getElementById('ga-min-count')?.value || '3');
            const maxCount = parseInt(document.getElementById('ga-max-count')?.value || '10');
            groupAnalyzerState.minLen = Math.max(1, Math.min(20, minLen));
            groupAnalyzerState.minCount = Math.max(1, minCount);
            groupAnalyzerState.maxCount = Math.max(1, maxCount);
        }

        function groupAnalyzerRunAnalysis() {
            // Build word -> [terms]
            groupAnalyzerState.wordToTerms = new Map();
            groupAnalyzerState.wordCounts = new Map();

            const splitter = /[\p{L}\p{N}'-]+/gu; // unicode words

            const entries = Object.entries(state.glossary || {});
            const minLen = groupAnalyzerState.minLen;

            for (const [original, data] of entries) {
                const originalS = String(original || '');
                const translationS = String(data?.translation || '');
                const noteS = String(data?.note || '');

                const text = `${originalS} ${translationS} ${noteS}`.toLowerCase();
                const words = text.match(splitter) || [];

                const unique = new Set();
                for (const w of words) {
                    if (w.length < minLen) continue;
                    if (groupAnalyzerState.ignoreWords.has(w)) continue;
                    unique.add(w);
                }

                for (const w of unique) {
                    if (!groupAnalyzerState.wordToTerms.has(w)) groupAnalyzerState.wordToTerms.set(w, []);
                    groupAnalyzerState.wordToTerms.get(w).push(original);
                }
            }

            for (const [w, arr] of groupAnalyzerState.wordToTerms.entries()) {
                groupAnalyzerState.wordCounts.set(w, arr.length);
            }
        }

        function groupAnalyzerApplyFilters() {
            const minVal = groupAnalyzerState.minCount;
            const maxVal = groupAnalyzerState.maxCount;

            const items = [];
            for (const [w, count] of groupAnalyzerState.wordCounts.entries()) {
                if (count >= minVal && count <= maxVal) items.push({ word: w, count });
            }
            items.sort((a, b) => b.count - a.count || a.word.localeCompare(b.word, 'ru'));
            groupAnalyzerState.lastItems = items;
        }

        function groupAnalyzerMakeExamples(word) {
            const terms = groupAnalyzerState.wordToTerms.get(word) || [];
            const examples = [];
            for (const term of terms.slice(0, 4)) {
                const entry = state.glossary[term] || {};
                const tr = String(entry.translation || '').trim();
                const note = String(entry.note || '').trim();

                let display = tr;
                if (!display) {
                    display = note ? `[${note}]` : term;
                } else if (note && display.length < 20) {
                    const shortNote = note.length > 10 ? (note.slice(0, 10) + '..') : note;
                    display += ` (${shortNote})`;
                }
                examples.push(display);
            }
            let s = examples.join('; ');
            if (terms.length > 4) s += '; ...';
            return s;
        }

        function groupAnalyzerRenderTable() {
            const tbody = document.getElementById('ga-table');
            if (!tbody) return;

            const totalGroups = groupAnalyzerState.lastItems.length;
            const selected = groupAnalyzerState.selectedWords.size;
            document.getElementById('ga-summary').textContent = `Групп: ${totalGroups} • выбрано: ${selected}`;

            tbody.innerHTML = groupAnalyzerState.lastItems.map(it => {
                const isChecked = groupAnalyzerState.selectedWords.has(it.word);
                const examples = groupAnalyzerMakeExamples(it.word);
                return `
                    <tr class="hover:bg-white/5">
                        <td class="px-3 py-2"><input type="checkbox" class="ga-word" data-word="${escapeXml(it.word)}" ${isChecked ? 'checked' : ''}></td>
                        <td class="px-3 py-2 font-mono text-gray-200">${escapeHtml(it.word)}</td>
                        <td class="px-3 py-2 text-gray-300">${it.count}</td>
                        <td class="px-3 py-2 text-gray-400" title="${escapeXml(examples)}">${escapeHtml(examples)}</td>
                    </tr>
                `;
            }).join('');

            // bind change events
            tbody.querySelectorAll('input.ga-word').forEach(cb => {
                cb.addEventListener('change', () => {
                    const w = cb.getAttribute('data-word');
                    if (!w) return;
                    if (cb.checked) groupAnalyzerState.selectedWords.add(w);
                    else groupAnalyzerState.selectedWords.delete(w);
                    const selAll = document.getElementById('ga-select-all');
                    if (selAll) selAll.checked = (groupAnalyzerState.selectedWords.size === groupAnalyzerState.lastItems.length && groupAnalyzerState.lastItems.length > 0);
                    document.getElementById('ga-summary').textContent = `Групп: ${groupAnalyzerState.lastItems.length} • выбрано: ${groupAnalyzerState.selectedWords.size}`;
                });
            });

            const selAll = document.getElementById('ga-select-all');
            if (selAll) selAll.checked = (groupAnalyzerState.lastItems.length > 0 && groupAnalyzerState.selectedWords.size === groupAnalyzerState.lastItems.length);
        }

        function groupAnalyzerRefresh(full = false) {
            groupAnalyzerReadFilters();
            // Any change requires re-run because minLen affects tokenization
            groupAnalyzerRunAnalysis();
            groupAnalyzerApplyFilters();

            // preserve selections that still exist
            const still = new Set();
            for (const w of groupAnalyzerState.selectedWords) {
                if (groupAnalyzerState.wordCounts.has(w)) still.add(w);
            }
            groupAnalyzerState.selectedWords = still;

            groupAnalyzerRenderTable();
        }

        function groupAnalyzerOpenEditor() {
            if (groupAnalyzerState.selectedWords.size === 0) {
                showToast('Выберите хотя бы одну группу', 'warning');
                return;
            }

            // collect unique terms from chosen words
            const termSet = new Set();
            for (const w of groupAnalyzerState.selectedWords) {
                for (const t of (groupAnalyzerState.wordToTerms.get(w) || [])) termSet.add(t);
            }
            const terms = Array.from(termSet);
            terms.sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));

            // For web simplicity: open glossary tab filtered by the first selected word
            hideGroupAnalyzerModal();
            switchTab('glossary');
            const q = Array.from(groupAnalyzerState.selectedWords)[0] || '';
            const search = document.getElementById('glossary-search');
            if (search) {
                search.value = q;
                updateGlossaryDisplay();
            }
            showToast(`Открыт глоссарий. Быстрый фильтр: "${q}" (терминов: ${terms.length})`, 'info');
        }

        // =============================================
        // GLOSSARY AI CORRECTOR (web-inspired by desktop ai_correction.py)
        // =============================================
        let glossaryCorrectorPreviewPrompt = '';

        function showGlossaryCorrectorModal() {
            if (!Object.keys(state.glossary || {}).length) {
                showToast('Глоссарий пуст', 'warning');
                return;
            }
            document.getElementById('gc-preview').textContent = 'Нажмите «Собрать превью»';
            document.getElementById('gc-patch').value = '';
            document.getElementById('gc-preview-warn').classList.add('hidden');
            glossaryCorrectorPreviewPrompt = '';
            document.getElementById('glossary-corrector-modal').classList.remove('hidden');
        }

        function hideGlossaryCorrectorModal() {
            document.getElementById('glossary-corrector-modal').classList.add('hidden');
        }

        // =============================================
        // GLOSSARY AI GENERATOR (web-inspired by desktop ai_generation.py)
        // =============================================
        let glossaryGeneratorPreviewPrompt = '';
        let glossaryGeneratorLastResult = null;

        function showGlossaryGeneratorModal() {
            if (!state.epubData?.chapters?.length) {
                showToast('Сначала загрузите EPUB во вкладке «Перевод»', 'warning');
                switchTab('translate');
                return;
            }
            const total = state.epubData.chapters.length;
            const ggStart = document.getElementById('gg-start');
            const ggEnd = document.getElementById('gg-end');

            ggStart.max = total;
            ggEnd.max = total;

            if (!ggStart.value) ggStart.value = Math.min(1, total);
            if (!ggEnd.value) ggEnd.value = Math.min(2, total);

            const clampRange = () => {
                let s = parseInt(ggStart.value) || 1;
                let e = parseInt(ggEnd.value) || s;
                s = Math.max(1, Math.min(s, total));
                e = Math.max(1, Math.min(e, total));
                ggStart.value = s;
                ggEnd.value = e;
                document.getElementById('gg-total-info').textContent = `Доступно глав: ${total}. Выбрано: ${Math.min(s, e)}–${Math.max(s, e)}.`;
            };

            ggStart.oninput = clampRange;
            ggEnd.oninput = clampRange;
            clampRange();

            document.getElementById('gg-preview').textContent = 'Нажмите «Собрать превью»';
            document.getElementById('gg-result').value = '';
            document.getElementById('gg-preview-warn').classList.add('hidden');
            glossaryGeneratorPreviewPrompt = '';
            glossaryGeneratorLastResult = null;

            document.getElementById('glossary-generator-modal').classList.remove('hidden');
        }

        function hideGlossaryGeneratorModal() {
            document.getElementById('glossary-generator-modal').classList.add('hidden');
        }

        function glossaryGeneratorCopyPreview() {
            if (!glossaryGeneratorPreviewPrompt.trim()) {
                showToast('Сначала соберите превью', 'warning');
                return;
            }
            navigator.clipboard.writeText(glossaryGeneratorPreviewPrompt);
            showToast('Превью скопировано', 'success');
        }

        function getGlossaryGeneratorMergeMode() {
            const el = document.querySelector('input[name="gg-merge"]:checked');
            return el ? el.value : 'supplement';
        }

        async function glossaryGeneratorCollectTextFromChapters(startChapter, endChapter) {
            // startChapter/endChapter are 1-based inclusive
            const total = state.epubData?.chapters?.length || 0;
            const s = Math.max(1, Math.min(startChapter, total));
            const e = Math.max(1, Math.min(endChapter, total));
            const from = Math.min(s, e);
            const to = Math.max(s, e);

            const selected = state.epubData.chapters.slice(from - 1, to);
            let combined = '';

            for (const ch of selected) {
                const html = await state.epubData.zip.file(ch.path).async('string');
                // For glossary generation: use plain text (like desktop) to reduce tokens
                const text = extractText(html).trim();
                if (text) {
                    combined += text.slice(0, 20000) + '\n\n-----\n\n';
                }
            }

            combined = combined.trim();
            return { from, to, combinedText: combined };
        }

        function buildGlossaryGeneratorPrompt(textForAi) {
            const tpl = document.getElementById('glossary-prompt')?.value || DEFAULT_GLOSSARY_PROMPT;

            // Optional context injection inspired by desktop (not strict JSON; compact lines)
            // For web: keep small (max 150 terms), optionally include notes.
            const includeNotes = !!document.getElementById('gg-include-notes')?.checked;

            let contextBlock = '';
            const allTerms = Object.entries(state.glossary || {});
            if (allTerms.length) {
                const maxTerms = 120;
                const slice = allTerms.slice(0, maxTerms);
                const lines = [];
                lines.push('--- КОНТЕКСТ: УЖЕ СУЩЕСТВУЮЩИЙ ГЛОССАРИЙ ---');
                for (const [orig, data] of slice) {
                    const tr = String(data?.translation || '').trim();
                    const note = String(data?.note || '').trim();
                    if (!tr) continue;
                    lines.push(`"${orig}" = "${tr}"`);
                    if (includeNotes && note) lines.push(`"${tr}" - "${note}"`);
                }
                contextBlock = lines.join('\n') + '\n\n';
            }

            return tpl.replace('{text}', contextBlock + textForAi);
        }

        function glossaryGeneratorBuildPreview() {
            const warnEl = document.getElementById('gg-preview-warn');
            warnEl.classList.add('hidden');
            warnEl.textContent = '';

            if (!state.epubData?.chapters?.length) {
                showToast('Сначала загрузите EPUB', 'warning');
                return;
            }

            const start = parseInt(document.getElementById('gg-start').value) || 1;
            const end = parseInt(document.getElementById('gg-end').value) || start;

            // Build with placeholder text for preview quickly (without reading full chapters)
            const total = state.epubData.chapters.length;
            const from = Math.max(1, Math.min(Math.min(start, end), total));
            const to = Math.max(1, Math.min(Math.max(start, end), total));

            const fakeText = `[ТЕКСТ БУДЕТ СОБРАН ИЗ ГЛАВ ${from}–${to}]\n(превью показывает структуру промпта; реальный текст будет подставлен при запуске)`;
            const prompt = buildGlossaryGeneratorPrompt(fakeText);

            glossaryGeneratorPreviewPrompt = prompt;
            document.getElementById('gg-preview').textContent = prompt;

            const estTokens = Math.round(prompt.length / 3.5);
            const lim = Math.max(1000, parseInt(document.getElementById('gg-token-limit')?.value) || 60000);
            if (estTokens > lim) {
                warnEl.innerHTML = `<b>Предупреждение:</b> превью ≈ <b>${formatNumber(estTokens)}</b> токенов, больше лимита <b>${formatNumber(lim)}</b>.\nУменьшите диапазон глав или отключите примечания.`;
                warnEl.classList.remove('hidden');
            } else {
                showToast(`Превью собрано (≈ ${formatNumber(estTokens)} токенов)`, 'success');
            }
        }

        async function glossaryGeneratorRun() {
            if (!state.provider || !state.model) {
                showToast('Сначала выберите провайдера и модель', 'warning');
                switchTab('settings');
                return;
            }
            if (!state.epubData?.chapters?.length) {
                showToast('Сначала загрузите EPUB', 'warning');
                switchTab('translate');
                return;
            }

            const start = parseInt(document.getElementById('gg-start').value) || 1;
            const end = parseInt(document.getElementById('gg-end').value) || start;

            const { from, to, combinedText } = await glossaryGeneratorCollectTextFromChapters(start, end);
            if (!combinedText.trim()) {
                showToast('Не удалось собрать текст из выбранных глав', 'error');
                return;
            }

            const prompt = buildGlossaryGeneratorPrompt(combinedText);
            glossaryGeneratorPreviewPrompt = prompt;
            document.getElementById('gg-preview').textContent = prompt;

            const estTokens = Math.round(prompt.length / 3.5);
            const lim = Math.max(1000, parseInt(document.getElementById('gg-token-limit')?.value) || 60000);
            if (estTokens > lim) {
                document.getElementById('gg-preview-warn').innerHTML = `<b>Предупреждение:</b> запрос ≈ <b>${formatNumber(estTokens)}</b> токенов, больше лимита <b>${formatNumber(lim)}</b>.\nУменьшите диапазон глав.`;
                document.getElementById('gg-preview-warn').classList.remove('hidden');
                showToast('Запрос слишком большой — уменьшите диапазон', 'warning');
                return;
            }

            try {
                showToast(`AI‑генерация: главы ${from}–${to}…`, 'info');
                log(`AI‑генерация глоссария: главы ${from}–${to}…`, 'info');

                const response = await callAI(prompt);
                const cleaned = stripCodeFences(response);
                const parsed = parseJSON(cleaned);

                if (!parsed || typeof parsed !== 'object') {
                    document.getElementById('gg-result').value = cleaned;
                    showToast('Ответ получен, но JSON не распознан. Проверьте вручную.', 'warning');
                    return;
                }

                glossaryGeneratorLastResult = parsed;
                document.getElementById('gg-result').value = JSON.stringify(parsed, null, 2);

                showToast(`Готово: ${Object.keys(parsed).length} терминов`, 'success');
                log(`AI‑генерация: получено ${Object.keys(parsed).length} терминов`, 'success');
            } catch (e) {
                console.error(e);
                showToast(`Ошибка AI‑генерации: ${e?.message || e}`, 'error');
                log(`AI‑генерация: ошибка: ${e?.message || e}`, 'error');
            }
        }

        function glossaryGeneratorMergeResult() {
            const txt = document.getElementById('gg-result').value || '';
            const parsed = parseJSON(txt);
            if (!parsed || typeof parsed !== 'object') {
                showToast('Не удалось распарсить JSON', 'error');
                return;
            }

            const mode = getGlossaryGeneratorMergeMode();

            let added = 0;
            let updated = 0;
            let total = 0;

            for (const [orig, data] of Object.entries(parsed)) {
                if (!orig || typeof data !== 'object' || data === null) continue;
                const translation = String(data.translation || '').trim();
                const note = String(data.note || '').trim();
                if (!translation) continue;

                total++;

                const exists = !!state.glossary[orig];

                if (mode === 'supplement') {
                    if (!exists) {
                        state.glossary[orig] = { translation, note };
                        added++;
                    }
                } else if (mode === 'update') {
                    if (exists) updated++;
                    else added++;
                    state.glossary[orig] = { translation, note };
                } else {
                    // accumulate: in web dict structure we cannot store duplicates.
                    // So we approximate: keep new key if free, otherwise store as "orig#2".
                    if (!exists) {
                        state.glossary[orig] = { translation, note };
                        added++;
                    } else {
                        let n = 2;
                        let key = `${orig}#${n}`;
                        while (state.glossary[key]) { n++; key = `${orig}#${n}`; }
                        state.glossary[key] = { translation, note };
                        added++;
                    }
                }
            }

            saveState();
            updateGlossaryDisplay();
            showToast(`Применено: ${total} (добавлено ${added}, обновлено ${updated})`, 'success');
            log(`AI‑генерация: применено ${total} терминов`, 'success');
        }

        function glossaryCorrectorCopyPreview() {
            if (!glossaryCorrectorPreviewPrompt.trim()) { showToast('Сначала соберите превью', 'warning'); return; }
            navigator.clipboard.writeText(glossaryCorrectorPreviewPrompt);
            showToast('Превью скопировано', 'success');
        }

        function glossaryCorrectorCopyPatch() {
            const v = document.getElementById('gc-patch').value || '';
            if (!v.trim()) { showToast('Патч пуст', 'warning'); return; }
            navigator.clipboard.writeText(v);
            showToast('Патч скопирован', 'success');
        }

        function getGlossaryCorrectorSourceMode() {
            const el = document.querySelector('input[name="gc-source"]:checked');
            return el ? el.value : 'conflicts';
        }

        function analyzeGlossaryIssuesForCorrector(glossaryObj) {
            const entries = Object.entries(glossaryObj || {});
            const reverseGroups = new Map(); // translationLower -> [terms]
            const overlaps = []; // {shorter,longer}

            for (const [term, data] of entries) {
                const translation = String(data?.translation || '').trim();
                const tKey = translation.toLowerCase();
                if (!translation) continue;
                if (!reverseGroups.has(tKey)) reverseGroups.set(tKey, []);
                reverseGroups.get(tKey).push(term);
            }

            // overlaps: one term contains another
            const terms = entries.map(([t]) => t);
            for (const a of terms) {
                if (!a || a.length < 3) continue;
                for (const b of terms) {
                    if (a === b) continue;
                    if (b.includes(a)) overlaps.push({ shorter: a, longer: b });
                }
            }

            const reverseConflicts = [];
            for (const [translationLower, termsList] of reverseGroups.entries()) {
                if (termsList.length >= 2) reverseConflicts.push({ translation: translationLower, terms: termsList });
            }

            // de-dup overlaps
            const seen = new Set();
            const overlapUnique = [];
            for (const o of overlaps) {
                const k = `${o.shorter}@@${o.longer}`;
                if (seen.has(k)) continue;
                seen.add(k);
                overlapUnique.push(o);
            }

            return { reverseConflicts, overlaps: overlapUnique };
        }

        function buildGlossaryCorrectorPrompt() {
            const noNotes = document.getElementById('gc-no-notes')?.checked;
            const allowAdditions = document.getElementById('gc-allow-additions')?.checked;
            const sourceMode = getGlossaryCorrectorSourceMode();

            const issues = analyzeGlossaryIssuesForCorrector(state.glossary);

            // choose terms
            let termSet = new Set();
            if (sourceMode === 'all') {
                Object.keys(state.glossary).forEach(t => termSet.add(t));
            } else {
                issues.reverseConflicts.forEach(g => g.terms.forEach(t => termSet.add(t)));
                issues.overlaps.forEach(o => { termSet.add(o.shorter); termSet.add(o.longer); });
            }

            const picked = Array.from(termSet);
            picked.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base', numeric: true }));

            const glossaryLines = [];
            for (const term of picked) {
                const entry = state.glossary[term] || {};
                const tr = String(entry.translation || '').trim();
                const note = String(entry.note || '').trim();
                if (!tr) continue;
                glossaryLines.push(`"${term}" = "${tr}"`);
                if (!noNotes && note) glossaryLines.push(`"${tr}" - "${note}"`);
            }

            const issueLines = [];
            if (issues.reverseConflicts.length) {
                issueLines.push('--- REVERSE CONFLICTS (same translation, different originals) ---');
                for (const g of issues.reverseConflicts.slice(0, 50)) {
                    issueLines.push(`"${g.translation}" <= ${g.terms.map(t => `"${t}"`).join(', ')}`);
                }
            }
            if (issues.overlaps.length) {
                issueLines.push('--- OVERLAPS (original contains another original) ---');
                for (const o of issues.overlaps.slice(0, 80)) {
                    issueLines.push(`"${o.shorter}" ⊂ "${o.longer}"`);
                }
            }

            const inputBlock = `--- GLOSSARY DATA ---\n${glossaryLines.join('\n') || '(empty)'}\n\n--- ISSUES ---\n${issueLines.join('\n') || '(no issues found by heuristic)'}\n`;

            const instruction = `Ты — AI‑корректор глоссария переводчика.\n\nЗадача:\n1) Найди и исправь несогласованности перевода терминов, особенно:\n   - Разные оригиналы имеют одинаковый перевод (REVERSE CONFLICTS).\n   - Наложения терминов (OVERLAPS): проверь согласованность переводов.\n2) Сохраняй смысл и стиль, но стремись к консистентности.\n3) НЕ меняй оригиналы (ключи). Меняй только translation и (опционально) note.\n4) Верни ТОЛЬКО JSON‑патч без markdown.\n\nФормат патча (включай ТОЛЬКО то, что нужно изменить):\n{\n  "Original term": { "translation": "Новый перевод"${noNotes ? '' : ', "note": "Новое/исправленное примечание или пустая строка для удаления"'} }\n}\n\n${allowAdditions ? 'Разрешено добавлять новые термины, если они очевидно нужны и короткие (в том же формате).' : 'НЕ добавляй новые термины.'}\n\nВходные данные ниже.\n`;

            return instruction + '\n' + inputBlock;
        }

        function glossaryCorrectorBuildPreview() {
            const warnEl = document.getElementById('gc-preview-warn');
            warnEl.classList.add('hidden');
            warnEl.textContent = '';

            const prompt = buildGlossaryCorrectorPrompt();
            glossaryCorrectorPreviewPrompt = prompt;
            document.getElementById('gc-preview').textContent = prompt;

            const estTokens = Math.round(prompt.length / 3.5);
            const lim = Math.max(1000, parseInt(document.getElementById('gc-token-limit')?.value) || 60000);
            if (estTokens > lim) {
                warnEl.innerHTML = `<b>Предупреждение:</b> превью запроса ≈ <b>${formatNumber(estTokens)}</b> токенов, что больше лимита <b>${formatNumber(lim)}</b>.\nРекомендуется переключить «Источник данных» на проблемные термины или включить «Игнорировать примечания».`;
                warnEl.classList.remove('hidden');
            } else {
                showToast(`Превью собрано (≈ ${formatNumber(estTokens)} токенов)`, 'success');
            }
        }

        async function glossaryCorrectorRun() {
            if (!state.provider || !state.model) {
                showToast('Сначала выберите провайдера и модель', 'warning');
                switchTab('settings');
                return;
            }
            if (!Object.keys(state.glossary || {}).length) {
                showToast('Глоссарий пуст', 'warning');
                return;
            }

            if (!glossaryCorrectorPreviewPrompt.trim()) glossaryCorrectorBuildPreview();

            const warnEl = document.getElementById('gc-preview-warn');
            const prompt = glossaryCorrectorPreviewPrompt;

            const estTokens = Math.round(prompt.length / 3.5);
            const lim = Math.max(1000, parseInt(document.getElementById('gc-token-limit')?.value) || 60000);
            if (estTokens > lim) {
                warnEl.classList.remove('hidden');
                showToast('Запрос слишком большой — сузьте входные данные', 'warning');
                return;
            }

            try {
                showToast('AI‑корректор: запрос отправлен…', 'info');
                log('AI‑корректор глоссария: запрос…', 'info');

                const response = await callAI(prompt);
                const cleaned = stripCodeFences(response);

                // Try parse JSON; if can't — still show raw
                const parsed = parseJSON(cleaned);
                if (parsed && typeof parsed === 'object') {
                    document.getElementById('gc-patch').value = JSON.stringify(parsed, null, 2);
                    showToast('Патч получен ✓', 'success');
                } else {
                    document.getElementById('gc-patch').value = cleaned;
                    showToast('Ответ получен, но JSON не распознан. Проверьте вручную.', 'warning');
                }
            } catch (e) {
                console.error(e);
                showToast(`Ошибка AI‑корректора: ${e?.message || e}`, 'error');
                log(`AI‑корректор: ошибка: ${e?.message || e}`, 'error');
            }
        }

        function glossaryCorrectorApplyPatch() {
            const txt = document.getElementById('gc-patch').value || '';
            if (!txt.trim()) { showToast('Патч пуст', 'warning'); return; }

            const allowAdditions = document.getElementById('gc-allow-additions')?.checked;

            const patch = parseJSON(txt);
            if (!patch || typeof patch !== 'object') {
                showToast('Не удалось распарсить JSON‑патч', 'error');
                return;
            }

            let changed = 0;
            let added = 0;
            let removed = 0;

            for (const [orig, data] of Object.entries(patch)) {
                if (!orig || typeof data !== 'object' || data === null) continue;

                if (data.delete === true) {
                    if (state.glossary[orig]) {
                        delete state.glossary[orig];
                        removed++;
                        changed++;
                    }
                    continue;
                }

                const hasExisting = !!state.glossary[orig];
                if (!hasExisting && !allowAdditions) continue;

                const newTranslation = (data.translation != null) ? String(data.translation).trim() : '';
                const newNote = (data.note != null) ? String(data.note).trim() : undefined;

                if (!newTranslation) continue; // require translation

                if (!hasExisting) {
                    state.glossary[orig] = { translation: newTranslation, note: newNote || '' };
                    added++;
                    changed++;
                } else {
                    const before = state.glossary[orig];
                    const beforeT = String(before.translation || '').trim();
                    const beforeN = String(before.note || '').trim();
                    const afterN = (newNote === undefined) ? beforeN : newNote;

                    if (beforeT !== newTranslation || beforeN !== afterN) {
                        state.glossary[orig] = { translation: newTranslation, note: afterN };
                        changed++;
                    }
                }
            }

            saveState();
            updateGlossaryDisplay();
            showToast(`Патч применён: ${changed} изменений (добавлено ${added}, удалено ${removed})`, 'success');
            log(`AI‑корректор: патч применён: ${changed} изменений`, 'success');
        }

        // =============================================
        // VALIDATOR ENHANCEMENTS
        // =============================================
        let validatorViewMode = 'text';

        function setValidatorViewMode(mode) {
            validatorViewMode = mode;
            if (state.validatorData.chapters.length > 0) selectValidatorChapter(state.validatorData.currentIndex);
        }

        function highlightPunctuation(html) {
            return html
                .replace(/─/g, '<span class="punct-operator">─</span>')
                .replace(/—/g, '<span class="punct-forbidden">—</span>')
                .replace(/«/g, '<span class="punct-quote">«</span>')
                .replace(/»/g, '<span class="punct-quote">»</span>')
                .replace(/–/g, '<span class="punct-dash">–</span>')
                .replace(/…/g, '<span class="punct-dash">…</span>');
        }

        function formatContentForValidator(content, mode) {
            if (mode === 'code') {
                const highlighted = hljs.highlight(content, { language: 'xml' }).value;
                return `<pre class="code-view"><code>${highlighted}</code></pre>`;
            } else if (mode === 'punct') {
                return highlightPunctuation(escapeHtml(content));
            } else {
                return formatHtmlForDisplay(content);
            }
        }

        // =============================================
        // LOCAL MODEL SUPPORT
        // =============================================
        async function callLocalModel(baseUrl, modelId, prompt, maxTokens = null) {
            const systemPrompt = document.getElementById('system-prompt')?.value?.trim();
            const messages = [];
            if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
            messages.push({ role: 'user', content: prompt });

            const payload = { model: modelId, messages, stream: false };
            if (maxTokens) payload.max_tokens = maxTokens;

            const response = await fetch(baseUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const txt = await response.text();
                if (response.status === 404) throw new ModelNotFoundError(`Local 404: ${txt}`);
                throw new NetworkError(`Local API ${response.status}: ${txt}`, 30000);
            }
            const data = await response.json();
            if (!data.choices?.[0]?.message?.content) throw new NetworkError('Empty response from local model', 10000);
            return data.choices[0].message.content;
        }

        // =============================================
        // DOCTOR TOOL (Text & EPUB Doctor)
        // =============================================
        const doctorState = { epubFile: null, outBlob: null, outName: null, processing: false, processedHtmlFiles: 0, totalFiles: 0 };

        function doctorLog(msg, type = 'info') {
            const el = document.getElementById('doctor-epub-log');
            const colors = { info: 'text-blue-300', success: 'text-green-300', warning: 'text-yellow-300', error: 'text-red-300' };
            if (el.querySelector('.text-gray-500:only-child')) el.innerHTML = '';
            const row = document.createElement('div');
            row.className = `log-entry py-1 ${colors[type] || colors.info}`;
            row.innerHTML = `<span class="text-gray-500">[${new Date().toLocaleTimeString()}]</span> ${escapeHtml(msg)}`;
            el.appendChild(row);
            el.scrollTop = el.scrollHeight;
        }

        function doctorSetProgress(pct, statusText = null) {
            const bar = document.getElementById('doctor-epub-progress');
            const pctEl = document.getElementById('doctor-epub-percent');
            const statusEl = document.getElementById('doctor-epub-status');
            bar.style.width = `${pct}%`;
            pctEl.textContent = `${pct}%`;
            if (statusText !== null) statusEl.textContent = statusText;
        }

        function doctorClearFragment() {
            document.getElementById('doctor-input').value = '';
            document.getElementById('doctor-output').value = '';
        }

        function doctorCopyOutput() {
            const text = document.getElementById('doctor-output').value || '';
            if (!text.trim()) { showToast('Нечего копировать', 'warning'); return; }
            navigator.clipboard.writeText(text);
            showToast('Результат скопирован', 'success');
        }

        function doctorPrettifyHtmlString(input) {
            let s = String(input ?? '');
            s = s.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            s = s.split('\n').map(line => line.replace(/[\t ]+$/g, '')).join('\n');

            const protectedBlocks = [];
            const protect = (re) => {
                s = s.replace(re, (m) => {
                    const token = `__PROTECTED_BLOCK_${protectedBlocks.length}__`;
                    protectedBlocks.push(m);
                    return token;
                });
            };
            protect(/<script[\s\S]*?<\/script>/gi);
            protect(/<style[\s\S]*?<\/style>/gi);
            protect(/<pre[\s\S]*?<\/pre>/gi);

            s = s.replace(/>\s*</g, '>\n<');

            const voidTag = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i;
            let indent = 0;
            const lines = s.split('\n').map(rawLine => rawLine.trim()).filter(l => l.length > 0);
            const out = [];
            for (const line of lines) {
                if (line.startsWith('</')) indent = Math.max(0, indent - 1);

                const m = line.match(/^<\/?\s*([a-zA-Z0-9:_-]+)/);
                const tag = m ? m[1] : null;
                const isOpen = line.startsWith('<') && !line.startsWith('</') && !line.endsWith('/>');
                const isClose = line.startsWith('</');
                const isVoid = tag ? voidTag.test(tag) : false;

                out.push('  '.repeat(indent) + line);

                if (isOpen && !isVoid && !isClose && !line.startsWith('<?') && !line.startsWith('<!')) indent += 1;
            }

            s = out.join('\n');

            protectedBlocks.forEach((block, i) => { s = s.replace(`__PROTECTED_BLOCK_${i}__`, block); });
            s = s.replace(/\n{3,}/g, '\n\n');
            return s.trim() + '\n';
        }

        function doctorPrettifyFragment() {
            const src = document.getElementById('doctor-input').value;
            if (!src.trim()) { showToast('Вставьте HTML во входное поле', 'warning'); return; }
            try {
                const out = doctorPrettifyHtmlString(src);
                document.getElementById('doctor-output').value = out;
                showToast('Готово', 'success');
            } catch (e) {
                document.getElementById('doctor-output').value = `Ошибка: ${e.message}`;
                showToast('Ошибка prettify', 'error');
            }
        }

        async function doctorHandleEpub(event) {
            const file = event.target.files[0];
            event.target.value = '';
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.epub')) { showToast('Нужен .epub', 'error'); return; }
            if (doctorState.processing) { showToast('Операция уже выполняется', 'warning'); return; }

            doctorState.epubFile = file;
            doctorState.outBlob = null;
            doctorState.outName = null;
            doctorState.processedHtmlFiles = 0;
            doctorState.totalFiles = 0;

            document.getElementById('doctor-epub-filename').textContent = file.name;
            document.getElementById('doctor-download-btn').disabled = true;
            document.getElementById('doctor-epub-log').innerHTML = '<div class="text-gray-500">Подготовка...</div>';
            doctorSetProgress(0, 'Загрузка...');
            doctorLog(`Начинаем операцию над: ${file.name}`);

            doctorState.processing = true;

            try {
                const inZip = await JSZip.loadAsync(file);
                const outZip = new JSZip();
                const entries = Object.keys(inZip.files);
                doctorState.totalFiles = entries.length;

                doctorLog('Вскрытие пациента (unzipping)...');

                let idx = 0;
                for (const name of entries) {
                    const entry = inZip.files[name];
                    if (entry.dir) { outZip.folder(name); idx++; continue; }

                    const lower = name.toLowerCase();
                    const isHtml = lower.endsWith('.html') || lower.endsWith('.xhtml') || lower.endsWith('.htm');

                    const data = await inZip.file(name).async('uint8array');
                    if (isHtml) {
                        try {
                            const text = new TextDecoder('utf-8', { fatal: false }).decode(data);
                            const healed = doctorPrettifyHtmlString(text);
                            outZip.file(name, healed);
                            doctorState.processedHtmlFiles++;
                        } catch (e) {
                            doctorLog(`❌ Ошибка в ${name}: ${e.message}`, 'error');
                            outZip.file(name, data);
                        }
                    } else {
                        const opts = (name === 'mimetype') ? { compression: 'STORE' } : undefined;
                        outZip.file(name, data, opts);
                    }

                    idx++;
                    const pct = Math.floor((idx / doctorState.totalFiles) * 100);
                    doctorSetProgress(pct, `Обработка... (${idx}/${doctorState.totalFiles})`);
                    if (idx % 25 === 0) await sleep(0);
                }

                doctorSetProgress(100, 'Готово');
                doctorLog(`Готово! Обработано HTML файлов: ${doctorState.processedHtmlFiles}`, 'success');

                const base = file.name.replace(/\.epub$/i, '');
                doctorState.outName = `${base}_prettified.epub`;
                doctorState.outBlob = await outZip.generateAsync({ type: 'blob', mimeType: 'application/epub+zip' });
                document.getElementById('doctor-download-btn').disabled = false;
                showToast('EPUB Doctor: готово', 'success');
            } catch (e) {
                doctorLog(`Ошибка: ${e.message}`, 'error');
                showToast('EPUB Doctor: ошибка', 'error');
                doctorSetProgress(0, 'Ошибка');
            } finally {
                doctorState.processing = false;
            }
        }

        function doctorDownloadEpub() {
            if (!doctorState.outBlob || !doctorState.outName) { showToast('Нет результата для скачивания', 'warning'); return; }
            const a = document.createElement('a');
            a.href = URL.createObjectURL(doctorState.outBlob);
            a.download = doctorState.outName;
            a.click();
            setTimeout(() => URL.revokeObjectURL(a.href), 1000);
            showToast('Скачивание началось', 'success');
        }

        // =============================================
        // INITIALIZATION
        // =============================================
        document.addEventListener('DOMContentLoaded', () => {
            loadState();
            populateProviderSelect();
            updateUI();
            updateKeyProviderInfo();
            renderProviderList();
            renderKeysList();
            loadProjectHistory();
            initPrompts();

            // Group analyzer defaults (auto max)
            try {
                const total = Object.keys(state.glossary || {}).length;
                const autoMax = Math.max(10, Math.floor(total * 0.3));
                const maxEl = document.getElementById('ga-max-count');
                if (maxEl) maxEl.value = String(autoMax);
            } catch {}

            log('EPUB Translator v9.9.0 Web инициализирован', 'info');
        });

        // =============================================
    </script>

    <script type="text/plain" id="legacy-scaffold">
        // =====================================================================
        // Legacy scaffold (disabled after integration)
        // =====================================================================
        const $ = (id) => document.getElementById(id);

        const STORAGE_KEYS = {
            settings: 'epubTranslator.settings.v1',
            keys: 'epubTranslator.keys.v1',
            glossary: 'epubTranslator.glossary.v1',
            projects: 'epubTranslator.projects.v1',
            log: 'epubTranslator.log.v1'
        };

        const PROVIDERS = [
            {
                id: 'local',
                name: 'Local / Manual',
                badge: 'badge-local',
                info: 'Локальный/ручной режим: перевод не отправляется в API. Используйте Dry Run и вставляйте ответы вручную.',
                needsKey: false,
                rpd: '—',
                models: [
                    { id: 'manual', name: 'Manual (paste)', free: true, inPrice: 0, outPrice: 0 },
                    { id: 'mock', name: 'Mock Translate (demo)', free: true, inPrice: 0, outPrice: 0 }
                ]
            },
            {
                id: 'openai',
                name: 'OpenAI',
                badge: 'badge-paid',
                info: 'Требуется API key. В этой web-версии вызовы API не реализованы — используйте как хранилище ключей/настроек.',
                needsKey: true,
                rpd: 'зависит от аккаунта',
                models: [
                    { id: 'gpt-4o-mini', name: 'gpt-4o-mini', free: false, inPrice: 0.15, outPrice: 0.60 },
                    { id: 'gpt-4o', name: 'gpt-4o', free: false, inPrice: 2.50, outPrice: 10.00 }
                ]
            },
            {
                id: 'google',
                name: 'Google (Gemini)',
                badge: 'badge-free',
                info: 'Требуется API key (AI Studio). Вызовы API в демо не реализованы.',
                needsKey: true,
                rpd: '—',
                models: [
                    { id: 'gemini-1.5-flash', name: 'gemini-1.5-flash', free: true, inPrice: 0.0, outPrice: 0.0 },
                    { id: 'gemini-1.5-pro', name: 'gemini-1.5-pro', free: false, inPrice: 1.25, outPrice: 5.0 }
                ]
            }
        ];

        const DEFAULT_PROMPTS = {
            system: 'Ты — профессиональный литературный переводчик. Переводи бережно, сохраняя стиль и смысл. Не добавляй пояснений.',
            translation: [
                'Переведи следующий фрагмент XHTML/HTML на русский язык.',
                'Сохрани структуру HTML и теги, не ломай разметку. Не добавляй новый текст, которого нет в оригинале.',
                '',
                'Глоссарий (используй строго):',
                '{glossary}',
                '',
                'Текст:',
                '{text}'
            ].join('\n'),
            glossary: [
                'Составь глоссарий терминов/имен/топонимов и устойчивых выражений из текста.',
                'Верни строго JSON вида: {"Term": {"translation": "...", "note": "..."}}.',
                '',
                'Текст:',
                '{text}'
            ].join('\n')
        };

        const SYSTEM_PRESET = {
            literary: 'Ты — профессиональный литературный переводчик. Переводи естественно, художественно, сохраняя стиль, ритм и голос автора.',
            technical: 'Ты — технический переводчик. Переводи точно, термины единообразно, избегай художественных вольностей.',
            fantasy: 'Ты — литературный переводчик фэнтези. Сохраняй поэтичность, имена/термины согласуй с глоссарием.',
            wuxia: 'Ты — переводчик уся/сянься. Сохраняй терминологию культивации, титулы и обращения; используй глоссарий строго.'
        };

        // Runtime state
        const app = {
            settings: {
                providerId: 'local',
                modelId: 'manual'
            },
            keys: {},
            glossary: {},
            projectHistory: [],
            log: [],

            currentFile: null,
            zip: null,
            chapters: [], // {path, name, originalHtml, translatedHtml, validated}
            translatedBlob: null,

            translation: {
                running: false,
                paused: false,
                cancelled: false,
                startedAt: null,
                currentIndex: 0
            },

            validator: {
                selectedIndex: -1,
                viewMode: 'text'
            },

            doctor: {
                outputEpubBlob: null,
                outputName: null
            }
        };

        // ----------------- Utilities -----------------
        function save(key, value) {
            localStorage.setItem(key, JSON.stringify(value));
        }
        function load(key, fallback) {
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return fallback;
                return JSON.parse(raw);
            } catch { return fallback; }
        }
        function clamp(n, a, b) {
            return Math.max(a, Math.min(b, n));
        }
        function bytesToSize(bytes) {
            const units = ['B', 'KB', 'MB', 'GB'];
            let i = 0;
            let val = bytes;
            while (val >= 1024 && i < units.length - 1) { val /= 1024; i++; }
            return `${val.toFixed(i === 0 ? 0 : 2)} ${units[i]}`;
        }
        function escapeHtml(str) {
            return String(str)
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#39;');
        }
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(url), 2000);
        }
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        function nowTs() { return new Date().toISOString(); }

        // ----------------- Toasts & Log -----------------
        function showToast(message, type = 'info') {
            const container = $('toast-container');
            const el = document.createElement('div');
            const color = type === 'success' ? 'bg-green-500/20 border-green-500/40 text-green-200'
                        : type === 'error' ? 'bg-red-500/20 border-red-500/40 text-red-200'
                        : type === 'warn' ? 'bg-yellow-500/20 border-yellow-500/40 text-yellow-200'
                        : 'bg-white/10 border-white/20 text-gray-100';
            el.className = `border ${color} backdrop-blur rounded-xl px-4 py-3 shadow-lg max-w-sm`;
            el.textContent = message;
            container.appendChild(el);
            setTimeout(() => {
                el.style.opacity = '0';
                el.style.transition = 'opacity .3s';
                setTimeout(() => el.remove(), 350);
            }, 3000);
        }

        function addLog(message, level = 'info') {
            const entry = { t: Date.now(), ts: nowTs(), level, message };
            app.log.push(entry);
            if (app.log.length > 2000) app.log.shift();
            save(STORAGE_KEYS.log, app.log);
            renderLog();
        }

        function renderLog() {
            const c = $('log-container');
            if (!c) return;
            c.innerHTML = '';
            if (!app.log.length) {
                c.innerHTML = '<div class="text-gray-500">Лог пуст. Загрузите файл для начала.</div>';
                return;
            }
            for (const e of app.log.slice(-400)) {
                const div = document.createElement('div');
                div.className = 'log-entry py-1';
                const color = e.level === 'error' ? 'text-red-300'
                            : e.level === 'warn' ? 'text-yellow-300'
                            : e.level === 'success' ? 'text-green-300'
                            : 'text-gray-200';
                div.innerHTML = `<span class="text-gray-500">[${escapeHtml(e.ts)}]</span> <span class="${color}">${escapeHtml(e.message)}</span>`;
                c.appendChild(div);
            }
            c.scrollTop = c.scrollHeight;
        }

        function clearLog() {
            app.log = [];
            save(STORAGE_KEYS.log, app.log);
            renderLog();
            showToast('Лог очищен', 'success');
        }

        function downloadLog() {
            const text = app.log.map(e => `[${e.ts}] ${e.level.toUpperCase()}: ${e.message}`).join('\n');
            downloadBlob(new Blob([text], { type: 'text/plain;charset=utf-8' }), `epub_translator_log_${Date.now()}.txt`);
        }

        // ----------------- Tabs -----------------
        function switchTab(tab) {
            document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden'));
            document.querySelectorAll('[id^="tab-"]').forEach(b => {
                b.classList.remove('tab-active');
                b.classList.add('bg-white/10');
            });
            const panel = $(`panel-${tab}`);
            const btn = $(`tab-${tab}`);
            if (panel) panel.classList.remove('hidden');
            if (btn) {
                btn.classList.add('tab-active');
                btn.classList.remove('bg-white/10');
            }
            if (tab === 'keys') renderKeysList();
            if (tab === 'glossary') renderGlossary();
            if (tab === 'validator') renderValidatorChapters();
        }

        // ----------------- Status -----------------
        function getProvider() {
            return PROVIDERS.find(p => p.id === app.settings.providerId) || PROVIDERS[0];
        }
        function getModel() {
            const p = getProvider();
            return p.models.find(m => m.id === app.settings.modelId) || p.models[0];
        }
        function getKeys(providerId) {
            return Array.isArray(app.keys[providerId]) ? app.keys[providerId] : [];
        }
        function updateHeaderInfo() {
            $('current-provider').textContent = getProvider().name;
            $('current-model').textContent = getModel().name;
            const keysCount = getKeys(app.settings.providerId).length;
            $('current-keys-count').textContent = String(keysCount);
            $('rpd-info').textContent = getProvider().rpd || '-';

            const ind = $('status-indicator');
            if (!ind) return;
            ind.innerHTML = '';
            const ok = app.settings.providerId && app.settings.modelId;
            const keyNeeded = getProvider().needsKey;
            const hasKey = getKeys(app.settings.providerId).length > 0;
            const state = ok && (!keyNeeded || hasKey) ? 'ok' : (ok ? 'warn' : 'pending');
            const dot = document.createElement('span');
            dot.className = `w-2 h-2 rounded-full ${state === 'ok' ? 'bg-green-500' : state === 'warn' ? 'bg-yellow-500' : 'bg-gray-500'} pulse-dot`;
            const text = document.createElement('span');
            text.className = state === 'ok' ? 'text-green-400' : state === 'warn' ? 'text-yellow-400' : 'text-gray-400';
            text.textContent = state === 'ok' ? 'Готово' : state === 'warn' ? 'Нужны ключи' : 'Не настроено';
            ind.appendChild(dot);
            ind.appendChild(text);
        }

        // ----------------- Settings UI -----------------
        function renderProviders() {
            const list = $('provider-list');
            if (!list) return;
            list.innerHTML = '';
            for (const p of PROVIDERS) {
                const btn = document.createElement('button');
                btn.className = `provider-btn w-full text-left border rounded-xl p-4 transition ${p.id === app.settings.providerId ? 'active border-indigo-500' : 'border-white/10 hover:border-white/20'}`;
                btn.onclick = () => selectProvider(p.id);
                btn.innerHTML = `
                    <div class="flex items-start justify-between gap-3">
                        <div>
                            <div class="font-semibold">${escapeHtml(p.name)}</div>
                            <div class="text-xs text-gray-400 mt-1">${escapeHtml(p.info)}</div>
                        </div>
                        <span class="text-xs px-2 py-1 rounded-full ${p.badge}">${p.needsKey ? 'API' : 'LOCAL'}</span>
                    </div>
                `;
                list.appendChild(btn);
            }
        }

        function renderModels() {
            const list = $('model-list');
            list.innerHTML = '';
            const p = getProvider();
            for (const m of p.models) {
                const btn = document.createElement('button');
                btn.className = `model-btn w-full text-left rounded-xl p-4 transition ${m.id === app.settings.modelId ? 'active' : 'bg-white/5 hover:bg-white/10'}`;
                btn.onclick = () => selectModel(m.id);
                btn.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="font-semibold">${escapeHtml(m.name)}</div>
                            <div class="text-xs text-gray-400">in: ${m.inPrice ?? 0}$ /1M • out: ${m.outPrice ?? 0}$ /1M</div>
                        </div>
                        <span class="text-xs px-2 py-1 rounded-full ${m.free ? 'badge-free' : 'badge-paid'}">${m.free ? 'FREE' : 'PAID'}</span>
                    </div>
                `;
                list.appendChild(btn);
            }
        }

        function selectProvider(providerId) {
            app.settings.providerId = providerId;
            const p = getProvider();
            app.settings.modelId = p.models[0]?.id || '';
            persistSettings();
            renderProviders();
            renderModels();
            updateHeaderInfo();
            renderKeyProviderSelect();
            showToast(`Провайдер: ${p.name}`, 'success');
        }

        function selectModel(modelId) {
            app.settings.modelId = modelId;
            persistSettings();
            renderModels();
            updateHeaderInfo();
            showToast(`Модель: ${getModel().name}`, 'success');
        }

        function persistSettings() {
            // Read toggles/inputs into settings (only if present)
            const pick = (id, def) => $(id) ? $(id).value : def;
            const pickBool = (id, def) => $(id) ? $(id).checked : def;
            app.settings = {
                ...app.settings,
                chunkSize: Number(pick('chunk-size', 50000)),
                maxGlossaryTerms: Number(pick('max-glossary-terms', 60)),
                maxRetries: Number(pick('max-retries', 2)),
                numInstances: Number(pick('num-instances', 1)),
                createGlossary: pickBool('create-glossary', true),
                keepCensored: pickBool('keep-censored', true),
                autoSave: pickBool('auto-save', true),
                enableBatching: pickBool('enable-batching', false),
                batchingMaxChars: Number(pick('batching-max-chars', 120000)),
                systemPrompt: $('system-prompt')?.value ?? DEFAULT_PROMPTS.system,
                translationPrompt: $('translation-prompt')?.value ?? DEFAULT_PROMPTS.translation,
                glossaryPrompt: $('glossary-prompt')?.value ?? DEFAULT_PROMPTS.glossary
            };
            save(STORAGE_KEYS.settings, app.settings);
        }

        function restoreSettingsToUI() {
            if ($('chunk-size')) $('chunk-size').value = app.settings.chunkSize ?? 50000;
            if ($('max-glossary-terms')) $('max-glossary-terms').value = app.settings.maxGlossaryTerms ?? 60;
            if ($('max-retries')) $('max-retries').value = app.settings.maxRetries ?? 2;
            if ($('num-instances')) $('num-instances').value = app.settings.numInstances ?? 1;
            if ($('create-glossary')) $('create-glossary').checked = app.settings.createGlossary ?? true;
            if ($('keep-censored')) $('keep-censored').checked = app.settings.keepCensored ?? true;
            if ($('auto-save')) $('auto-save').checked = app.settings.autoSave ?? true;
            if ($('enable-batching')) $('enable-batching').checked = app.settings.enableBatching ?? false;
            if ($('batching-max-chars')) $('batching-max-chars').value = app.settings.batchingMaxChars ?? 120000;

            if ($('system-prompt')) $('system-prompt').value = app.settings.systemPrompt ?? DEFAULT_PROMPTS.system;
            if ($('translation-prompt')) $('translation-prompt').value = app.settings.translationPrompt ?? DEFAULT_PROMPTS.translation;
            if ($('glossary-prompt')) $('glossary-prompt').value = app.settings.glossaryPrompt ?? DEFAULT_PROMPTS.glossary;
        }

        // ----------------- Keys -----------------
        function renderKeyProviderSelect() {
            const sel = $('key-provider-select');
            if (!sel) return;
            sel.innerHTML = '';
            for (const p of PROVIDERS) {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = p.name;
                sel.appendChild(opt);
            }
            sel.value = app.settings.providerId || 'local';
            updateKeyProviderInfo();
        }

        function updateKeyProviderInfo() {
            const sel = $('key-provider-select');
            if (!sel) return;
            const p = PROVIDERS.find(x => x.id === sel.value) || PROVIDERS[0];
            const info = $('key-provider-info');
            info.innerHTML = `
                <div class="flex items-start justify-between gap-3">
                    <div>
                        <div class="font-medium text-gray-200">${escapeHtml(p.name)}</div>
                        <div class="text-xs text-gray-400 mt-1">${escapeHtml(p.info)}</div>
                    </div>
                    <div class="text-xs px-2 py-1 rounded-full ${p.badge}">${p.needsKey ? 'KEY' : 'LOCAL'}</div>
                </div>
                <div class="mt-2 text-xs text-gray-500">Сохранено ключей: <b class="text-gray-200">${getKeys(p.id).length}</b></div>
            `;
        }

        function addKeys() {
            const sel = $('key-provider-select');
            const input = $('keys-input');
            if (!sel || !input) return;
            const providerId = sel.value;
            const lines = input.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
            if (!lines.length) {
                showToast('Вставьте ключи (по одному на строку)', 'warn');
                return;
            }
            const cur = new Set(getKeys(providerId));
            for (const k of lines) cur.add(k);
            app.keys[providerId] = Array.from(cur);
            save(STORAGE_KEYS.keys, app.keys);
            input.value = '';
            renderKeysList();
            updateKeyProviderInfo();
            updateHeaderInfo();
            showToast(`Добавлено ключей: ${lines.length}`, 'success');
        }

        function removeKey(providerId, key) {
            app.keys[providerId] = getKeys(providerId).filter(k => k !== key);
            save(STORAGE_KEYS.keys, app.keys);
            renderKeysList();
            updateKeyProviderInfo();
            updateHeaderInfo();
        }

        function renderKeysList() {
            const list = $('keys-list');
            if (!list) return;
            list.innerHTML = '';

            for (const p of PROVIDERS) {
                const keys = getKeys(p.id);
                const block = document.createElement('div');
                block.className = 'bg-white/5 border border-white/10 rounded-xl overflow-hidden';
                block.innerHTML = `
                    <div class="p-4 border-b border-white/10 flex items-center justify-between">
                        <div class="font-semibold">${escapeHtml(p.name)}</div>
                        <div class="text-xs text-gray-400">${keys.length} ключ(ей)</div>
                    </div>
                    <div class="p-2" id="keys-${p.id}"></div>
                `;
                list.appendChild(block);
                const inner = block.querySelector(`#keys-${p.id}`);
                if (!keys.length) {
                    inner.innerHTML = '<div class="text-gray-500 text-sm p-3">Нет ключей</div>';
                    continue;
                }
                for (const k of keys) {
                    const row = document.createElement('div');
                    row.className = 'key-item flex items-center justify-between gap-3 p-3 rounded-lg hover:bg-white/5';
                    const masked = k.length <= 8 ? k : `${k.slice(0, 4)}…${k.slice(-4)}`;
                    row.innerHTML = `
                        <div class="font-mono text-sm text-gray-200">${escapeHtml(masked)}</div>
                        <button class="text-xs text-red-300 hover:text-red-200">Удалить</button>
                    `;
                    row.querySelector('button').onclick = () => removeKey(p.id, k);
                    inner.appendChild(row);
                }
            }
        }

        // ----------------- File upload & EPUB parsing -----------------
        function handleDragOver(e) { e.preventDefault(); $('upload-area').classList.add('border-indigo-500'); }
        function handleDragLeave(e) { e.preventDefault(); $('upload-area').classList.remove('border-indigo-500'); }
        function handleDrop(e) {
            e.preventDefault();
            $('upload-area').classList.remove('border-indigo-500');
            const file = e.dataTransfer.files?.[0];
            if (file) loadEpubFile(file);
        }
        function handleFileSelect(e) {
            const file = e.target.files?.[0];
            if (file) loadEpubFile(file);
        }

        async function loadEpubFile(file) {
            try {
                persistSettings();
                addLog(`Загрузка файла: ${file.name}`);
                app.currentFile = file;
                $('file-name').textContent = file.name;
                $('file-size').textContent = bytesToSize(file.size);

                const buf = await file.arrayBuffer();
                app.zip = await JSZip.loadAsync(buf);

                const htmlPaths = Object.keys(app.zip.files)
                    .filter(p => /\.(xhtml|html|htm)$/i.test(p))
                    .filter(p => !/\/toc\b/i.test(p) && !/nav\b/i.test(p))
                    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));

                if (!htmlPaths.length) {
                    showToast('В EPUB не найдено .html/.xhtml', 'error');
                    addLog('Не найдено html/xhtml внутри EPUB', 'error');
                    return;
                }

                app.chapters = [];
                let totalChars = 0;
                for (let i = 0; i < htmlPaths.length; i++) {
                    const path = htmlPaths[i];
                    const txt = await app.zip.file(path).async('string');
                    totalChars += txt.length;
                    app.chapters.push({
                        path,
                        name: `Глава ${i + 1}`,
                        originalHtml: txt,
                        translatedHtml: null,
                        validated: false
                    });
                }

                $('chapter-count').textContent = String(app.chapters.length);
                $('char-count').textContent = totalChars.toLocaleString('ru-RU');
                const tokens = Math.ceil(totalChars / 4);
                $('token-estimate').textContent = tokens.toLocaleString('ru-RU');

                const m = getModel();
                const cost = ((tokens / 1_000_000) * (m.inPrice + m.outPrice)).toFixed(4);
                $('cost-estimate').textContent = (Number(cost) ? `$${cost}` : '—');

                $('upload-area').classList.add('hidden');
                $('file-info').classList.remove('hidden');
                $('result-panel').classList.add('hidden');
                $('progress-panel').classList.add('hidden');

                $('start-chapter').value = 1;
                $('start-chapter').max = app.chapters.length;
                $('end-chapter').value = app.chapters.length;
                $('end-chapter').max = app.chapters.length;

                // Dry run chapter selector
                updateDryRunChapterSelect();
                $('dry-run-btn').disabled = false;

                // Generator modal range
                $('gg-start').value = 1;
                $('gg-end').value = Math.min(app.chapters.length, 1);
                $('gg-total-info').textContent = `Доступно глав: ${app.chapters.length}`;

                addLog(`EPUB распакован. Глав: ${app.chapters.length}.`, 'success');
                showToast('EPUB загружен', 'success');

            } catch (err) {
                console.error(err);
                showToast('Ошибка при загрузке EPUB', 'error');
                addLog(`Ошибка загрузки EPUB: ${err?.message || err}`, 'error');
            }
        }

        function clearFile() {
            app.currentFile = null;
            app.zip = null;
            app.chapters = [];
            app.translatedBlob = null;
            $('file-info').classList.add('hidden');
            $('upload-area').classList.remove('hidden');
            $('dry-run-btn').disabled = true;
            $('validator-chapters').innerHTML = '<p class="text-gray-400 text-sm text-center py-8">Загрузите проект для проверки</p>';
            $('original-content').innerHTML = '<p class="text-gray-500">Выберите главу для просмотра</p>';
            $('translated-content').innerHTML = '<p class="text-gray-500">Выберите главу для просмотра</p>';
            addLog('Файл очищен');
        }

        function togglePartialTranslation() {
            const enabled = $('partial-translation').checked;
            $('chapter-range').classList.toggle('hidden', !enabled);
        }

        // ----------------- Translation (demo) -----------------
        function estimateTokens(text) { return Math.ceil((text?.length || 0) / 4); }

        function buildGlossaryText() {
            const entries = Object.entries(app.glossary);
            if (!entries.length) return '(пусто)';
            return entries
                .slice(0, 200)
                .map(([term, v]) => `- ${term} => ${v.translation || ''}${v.note ? ` (${v.note})` : ''}`)
                .join('\n');
        }

        function simulateTranslateHtml(html, mode = 'mock') {
            // Safe demo: keep HTML as-is, but add a marker comment.
            const marker = `<!-- translated:${mode}:${Date.now()} -->\n`;
            if (html.trim().startsWith('<!-- translated:')) return html;
            return marker + html;
        }

        function maybeAutoBuildGlossaryFromChapters(chapterIndices) {
            if (!app.settings.createGlossary) return;
            const limit = clamp(Number(app.settings.maxGlossaryTerms ?? 60), 10, 300);
            const text = chapterIndices
                .slice(0, 3)
                .map(i => app.chapters[i]?.originalHtml || '')
                .join('\n');
            // very naive term extraction: capitalized words 3+ letters
            const matches = text.match(/\b[A-Z][A-Za-z]{2,}(?:\s+[A-Z][A-Za-z]{2,})*\b/g) || [];
            const freq = new Map();
            for (const t of matches) freq.set(t, (freq.get(t) || 0) + 1);
            const sorted = Array.from(freq.entries()).sort((a, b) => b[1] - a[1]).slice(0, limit);
            let added = 0;
            for (const [term] of sorted) {
                if (!app.glossary[term]) {
                    app.glossary[term] = { translation: '', note: 'auto' };
                    added++;
                }
            }
            if (added) {
                save(STORAGE_KEYS.glossary, app.glossary);
                renderGlossary();
                addLog(`Автоглоссарий: добавлено терминов ${added}`, 'success');
            }
        }

        async function startTranslation() {
            if (!app.currentFile || !app.zip || !app.chapters.length) {
                showToast('Сначала загрузите EPUB', 'warn');
                return;
            }
            persistSettings();

            const provider = getProvider();
            const model = getModel();
            if (provider.needsKey && getKeys(provider.id).length === 0) {
                showToast('Для выбранного провайдера нужны ключи (вкладка API Ключи)', 'warn');
                return;
            }

            app.translation.running = true;
            app.translation.paused = false;
            app.translation.cancelled = false;
            app.translation.startedAt = Date.now();

            $('progress-panel').classList.remove('hidden');
            $('result-panel').classList.add('hidden');

            const partial = $('partial-translation').checked;
            let start = 1, end = app.chapters.length;
            if (partial) {
                start = clamp(Number($('start-chapter').value || 1), 1, app.chapters.length);
                end = clamp(Number($('end-chapter').value || start), start, app.chapters.length);
            }
            const indices = [];
            for (let i = start - 1; i <= end - 1; i++) indices.push(i);

            maybeAutoBuildGlossaryFromChapters(indices);

            addLog(`Старт перевода: ${provider.name} / ${model.name}. Диапазон: ${start}-${end}.`);

            const total = indices.length;
            let tokensIn = 0;
            let tokensOut = 0;

            for (let k = 0; k < total; k++) {
                const idx = indices[k];
                app.translation.currentIndex = idx;

                while (app.translation.paused) {
                    $('progress-status').textContent = 'Пауза…';
                    await sleep(200);
                    if (app.translation.cancelled) break;
                }
                if (app.translation.cancelled) break;

                $('progress-status').textContent = `Перевод главы ${idx + 1}…`;
                $('current-chapter').textContent = `${k + 1}/${total}`;

                const original = app.chapters[idx].originalHtml;
                tokensIn += estimateTokens(original);

                // Demo translation: keep the HTML, just mark.
                const translated = simulateTranslateHtml(original, model.id);
                tokensOut += Math.ceil(estimateTokens(original) * 1.05);
                app.chapters[idx].translatedHtml = translated;

                // Update progress
                const pct = Math.floor(((k + 1) / total) * 100);
                $('progress-percent').textContent = `${pct}%`;
                $('progress-bar').style.width = `${pct}%`;
                $('tokens-in').textContent = tokensIn.toLocaleString('ru-RU');
                $('tokens-out').textContent = tokensOut.toLocaleString('ru-RU');
                const elapsed = Math.floor((Date.now() - app.translation.startedAt) / 1000);
                $('elapsed-time').textContent = `${String(Math.floor(elapsed / 60)).padStart(2,'0')}:${String(elapsed % 60).padStart(2,'0')}`;
                $('current-key-index').textContent = `${Math.min(1, getKeys(provider.id).length || 1)}/${Math.max(1, getKeys(provider.id).length || 1)}`;

                addLog(`Глава ${idx + 1} переведена (demo).`, 'success');
                await sleep(80);
            }

            if (!app.translation.cancelled) {
                $('progress-status').textContent = 'Сборка EPUB…';
                await rebuildTranslatedEpub();
                showResult(tokensIn, tokensOut);
                addLog('Перевод завершён.', 'success');
                // Save to history
                pushProjectHistory({
                    name: app.currentFile.name,
                    chapters: app.chapters.length,
                    translated: app.chapters.filter(c => c.translatedHtml).length
                });
            } else {
                $('progress-status').textContent = 'Отменено.';
                addLog('Перевод отменён.', 'warn');
                showToast('Перевод отменён', 'warn');
            }

            app.translation.running = false;
            app.translation.paused = false;
        }

        function pauseTranslation() {
            if (!app.translation.running) return;
            app.translation.paused = !app.translation.paused;
            $('pause-btn').innerHTML = app.translation.paused
                ? '<i class="fas fa-play mr-2"></i>Продолжить'
                : '<i class="fas fa-pause mr-2"></i>Пауза';
        }

        function cancelTranslation() {
            if (!app.translation.running) return;
            app.translation.cancelled = true;
        }

        async function rebuildTranslatedEpub() {
            if (!app.zip) return;
            // Clone zip by creating a new instance and copying all files
            const newZip = new JSZip();
            const files = Object.keys(app.zip.files);
            for (const p of files) {
                const f = app.zip.files[p];
                if (f.dir) {
                    newZip.folder(p);
                    continue;
                }
                const isHtml = /\.(xhtml|html|htm)$/i.test(p);
                const chapter = app.chapters.find(c => c.path === p);
                if (isHtml && chapter?.translatedHtml) {
                    newZip.file(p, chapter.translatedHtml);
                } else {
                    const data = await f.async('arraybuffer');
                    newZip.file(p, data);
                }
            }
            app.translatedBlob = await newZip.generateAsync({ type: 'blob' });
        }

        function showResult(tokensIn, tokensOut) {
            $('progress-panel').classList.add('hidden');
            $('result-panel').classList.remove('hidden');
            const elapsed = Math.floor((Date.now() - app.translation.startedAt) / 1000);
            const translatedCount = app.chapters.filter(c => c.translatedHtml).length;
            const stats = [
                { label: 'Глав переведено', value: `${translatedCount}/${app.chapters.length}` },
                { label: 'Токены (вход)', value: tokensIn.toLocaleString('ru-RU') },
                { label: 'Токены (выход)', value: tokensOut.toLocaleString('ru-RU') },
                { label: 'Время', value: `${String(Math.floor(elapsed / 60)).padStart(2,'0')}:${String(elapsed % 60).padStart(2,'0')}` }
            ];
            $('result-stats').innerHTML = stats.map(s => `
                <div class="bg-white/5 rounded-lg p-3">
                    <div class="text-gray-400">${escapeHtml(s.label)}</div>
                    <div class="font-medium">${escapeHtml(s.value)}</div>
                </div>
            `).join('');
        }

        function resetTranslation() {
            $('result-panel').classList.add('hidden');
            $('progress-panel').classList.add('hidden');
            $('file-info').classList.toggle('hidden', !app.currentFile);
            showToast('Готово к новому переводу', 'success');
        }

        function downloadEpub() {
            if (!app.translatedBlob) {
                showToast('Нет готового EPUB. Сначала выполните перевод.', 'warn');
                return;
            }
            const name = app.currentFile?.name?.replace(/\.epub$/i, '') || 'book';
            downloadBlob(app.translatedBlob, `${name}_translated.epub`);
        }

        function downloadGlossary() {
            const data = JSON.stringify(app.glossary, null, 2);
            downloadBlob(new Blob([data], { type: 'application/json;charset=utf-8' }), `glossary_${Date.now()}.json`);
        }

        function openInValidator() {
            switchTab('validator');
            loadProjectForValidation(true);
        }

        // ----------------- Validator -----------------
        function renderValidatorChapters() {
            const container = $('validator-chapters');
            if (!container) return;
            if (!app.chapters.length) {
                container.innerHTML = '<p class="text-gray-400 text-sm text-center py-8">Загрузите проект для проверки</p>';
                return;
            }
            container.innerHTML = '';
            app.chapters.forEach((ch, idx) => {
                const row = document.createElement('button');
                row.className = `chapter-row w-full text-left px-3 py-2 rounded-lg transition ${idx === app.validator.selectedIndex ? 'selected' : ''}`;
                const has = !!ch.translatedHtml;
                row.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="text-sm font-medium">${escapeHtml(ch.name)}</div>
                        <div class="text-xs ${ch.validated ? 'text-green-400' : has ? 'text-yellow-400' : 'text-gray-500'}">${ch.validated ? 'OK' : has ? 'переведено' : 'нет'}</div>
                    </div>
                    <div class="text-xs text-gray-500">${escapeHtml(ch.path)}</div>
                `;
                row.onclick = () => selectValidatorChapter(idx);
                container.appendChild(row);
            });
            updateValidationProgress();
        }

        function loadProjectForValidation(fromCurrent = false) {
            if (app.chapters.length) {
                showToast('Проект загружен из текущей сессии', 'success');
                renderValidatorChapters();
                if (app.validator.selectedIndex < 0) selectValidatorChapter(0);
                return;
            }
            if (!fromCurrent) showToast('Импортируйте проект через Настройки → Импорт проекта', 'warn');
        }

        function setValidatorViewMode(mode) {
            app.validator.viewMode = mode;
            ['text', 'code', 'punct'].forEach(m => {
                const btn = $(`view-${m}`);
                if (!btn) return;
                if (m === mode) {
                    btn.classList.add('bg-indigo-600');
                    btn.classList.remove('hover:bg-white/10');
                } else {
                    btn.classList.remove('bg-indigo-600');
                    btn.classList.add('hover:bg-white/10');
                }
            });
            if (app.validator.selectedIndex >= 0) selectValidatorChapter(app.validator.selectedIndex);
        }

        function punctHighlight(html) {
            // very lightweight highlighting in rendered HTML
            return html
                .replaceAll('—', '<span class="punct-dash">—</span>')
                .replaceAll('–', '<span class="punct-dash">–</span>')
                .replaceAll('“', '<span class="punct-quote">“</span>')
                .replaceAll('”', '<span class="punct-quote">”</span>')
                .replaceAll('«', '<span class="punct-quote">«</span>')
                .replaceAll('»', '<span class="punct-quote">»</span>');
        }

        function selectValidatorChapter(idx) {
            app.validator.selectedIndex = idx;
            renderValidatorChapters();

            const ch = app.chapters[idx];
            $('current-chapter-name').textContent = ch?.name || '';

            const original = ch?.originalHtml || '';
            const translated = ch?.translatedHtml || '';

            const status = $('translation-status');
            if (status) {
                status.textContent = ch?.validated ? 'Подтверждено' : (translated ? 'Есть перевод' : 'Нет перевода');
                status.className = 'ml-auto text-xs ' + (ch?.validated ? 'text-green-400' : (translated ? 'text-yellow-400' : 'text-gray-500'));
            }

            const view = app.validator.viewMode;
            if (view === 'text') {
                $('original-content').classList.remove('code-view');
                $('translated-content').classList.remove('code-view');
                $('original-content').innerHTML = original;
                $('translated-content').innerHTML = translated || '<p class="text-gray-500">Нет перевода</p>';
            } else if (view === 'punct') {
                $('original-content').classList.remove('code-view');
                $('translated-content').classList.remove('code-view');
                $('original-content').innerHTML = punctHighlight(original);
                $('translated-content').innerHTML = translated ? punctHighlight(translated) : '<p class="text-gray-500">Нет перевода</p>';
            } else {
                $('original-content').classList.add('code-view');
                $('translated-content').classList.add('code-view');
                $('original-content').innerHTML = `<pre><code class="language-xml">${escapeHtml(original)}</code></pre>`;
                $('translated-content').innerHTML = translated
                    ? `<pre><code class="language-xml">${escapeHtml(translated)}</code></pre>`
                    : '<p class="text-gray-500">Нет перевода</p>';
                $('original-content').querySelectorAll('code').forEach(el => hljs.highlightElement(el));
                $('translated-content').querySelectorAll('code').forEach(el => hljs.highlightElement(el));
            }

            // very basic issues detection (demo)
            const issues = [];
            if (!translated) issues.push('Нет перевода для главы.');
            if (translated && /<script\b/i.test(translated)) issues.push('Обнаружен <script> в переводе (подозрительно).');
            const issuesPanel = $('issues-panel');
            const issuesList = $('issues-list');
            if (issues.length) {
                issuesPanel.classList.remove('hidden');
                issuesList.innerHTML = issues.map(i => `<div class="bg-white/5 border border-white/10 rounded-lg p-2">${escapeHtml(i)}</div>`).join('');
            } else {
                issuesPanel.classList.add('hidden');
                issuesList.innerHTML = '';
            }
        }

        function updateValidationProgress() {
            const total = app.chapters.length || 0;
            const ok = app.chapters.filter(c => c.validated).length;
            $('validated-count').textContent = `${ok}/${total}`;
            const pct = total ? Math.round((ok / total) * 100) : 0;
            $('validation-progress').style.width = `${pct}%`;
        }

        function prevChapterValidator() {
            if (!app.chapters.length) return;
            selectValidatorChapter((app.validator.selectedIndex <= 0 ? 0 : app.validator.selectedIndex - 1));
        }
        function nextChapterValidator() {
            if (!app.chapters.length) return;
            selectValidatorChapter((app.validator.selectedIndex >= app.chapters.length - 1 ? app.chapters.length - 1 : app.validator.selectedIndex + 1));
        }
        function markAsValidated() {
            const idx = app.validator.selectedIndex;
            if (idx < 0) return;
            app.chapters[idx].validated = true;
            updateValidationProgress();
            renderValidatorChapters();
            showToast('Глава подтверждена', 'success');
        }
        function retryChapter() {
            const idx = app.validator.selectedIndex;
            if (idx < 0) return;
            app.chapters[idx].translatedHtml = null;
            app.chapters[idx].validated = false;
            selectValidatorChapter(idx);
            updateValidationProgress();
            showToast('Перевод для главы сброшен', 'warn');
        }

        // ----------------- Glossary -----------------
        function renderGlossary() {
            const cont = $('glossary-content');
            if (!cont) return;

            const q = ($('glossary-search')?.value || '').trim().toLowerCase();
            const entries = Object.entries(app.glossary)
                .filter(([term, v]) => {
                    if (!q) return true;
                    return term.toLowerCase().includes(q) || (v.translation || '').toLowerCase().includes(q) || (v.note || '').toLowerCase().includes(q);
                })
                .sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }));

            $('glossary-count').textContent = `(${entries.length} терминов)`;

            if (!entries.length) {
                cont.innerHTML = '<p class="text-gray-400 text-center py-8">Глоссарий пуст</p>';
                return;
            }

            cont.innerHTML = '';
            for (const [term, v] of entries) {
                const row = document.createElement('div');
                row.className = 'bg-white/5 border border-white/10 rounded-xl p-4';
                row.innerHTML = `
                    <div class="flex items-start justify-between gap-3">
                        <div class="flex-1 min-w-0">
                            <div class="font-semibold truncate">${escapeHtml(term)}</div>
                            <div class="text-sm text-gray-300 mt-2">Перевод:</div>
                            <input class="mt-1 w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm" value="${escapeHtml(v.translation || '')}" data-gterm="${escapeHtml(term)}" data-field="translation" />
                            <div class="text-sm text-gray-300 mt-3">Примечание:</div>
                            <input class="mt-1 w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm" value="${escapeHtml(v.note || '')}" data-gterm="${escapeHtml(term)}" data-field="note" />
                        </div>
                        <button class="text-red-300 hover:text-red-200 text-sm">Удалить</button>
                    </div>
                `;
                row.querySelector('button').onclick = () => {
                    delete app.glossary[term];
                    save(STORAGE_KEYS.glossary, app.glossary);
                    renderGlossary();
                    showToast('Термин удалён', 'success');
                };
                row.querySelectorAll('input').forEach(inp => {
                    inp.addEventListener('input', () => {
                        const t = inp.getAttribute('data-gterm');
                        const field = inp.getAttribute('data-field');
                        if (!app.glossary[t]) return;
                        app.glossary[t][field] = inp.value;
                        save(STORAGE_KEYS.glossary, app.glossary);
                    });
                });
                cont.appendChild(row);
            }
        }

        function addGlossaryTerm() {
            const term = ($('new-term-original').value || '').trim();
            const translation = ($('new-term-translation').value || '').trim();
            const note = ($('new-term-note').value || '').trim();
            if (!term) {
                showToast('Укажите оригинал термина', 'warn');
                return;
            }
            app.glossary[term] = { translation, note };
            save(STORAGE_KEYS.glossary, app.glossary);
            $('new-term-original').value = '';
            $('new-term-translation').value = '';
            $('new-term-note').value = '';
            renderGlossary();
            showToast('Термин добавлен', 'success');
        }

        function clearGlossary() {
            if (!confirm('Очистить глоссарий?')) return;
            app.glossary = {};
            save(STORAGE_KEYS.glossary, app.glossary);
            renderGlossary();
            showToast('Глоссарий очищен', 'success');
        }

        function searchGlossary() { renderGlossary(); }

        function analyzeGlossaryConflicts() {
            const conflicts = [];
            const byTranslation = new Map();
            for (const [term, v] of Object.entries(app.glossary)) {
                const tr = (v.translation || '').trim();
                if (!tr) continue;
                if (!byTranslation.has(tr)) byTranslation.set(tr, []);
                byTranslation.get(tr).push(term);
            }
            for (const [tr, terms] of byTranslation.entries()) {
                if (terms.length > 1) {
                    conflicts.push({ type: 'reverse', title: tr, items: terms });
                }
            }
            // overlap (term inside another)
            const terms = Object.keys(app.glossary);
            for (let i = 0; i < terms.length; i++) {
                for (let j = 0; j < terms.length; j++) {
                    if (i === j) continue;
                    const a = terms[i], b = terms[j];
                    if (a.length >= 4 && b.includes(a) && b !== a) {
                        conflicts.push({ type: 'overlap', title: a, items: [a, b] });
                    }
                }
            }

            const panel = $('glossary-conflicts');
            const list = $('conflicts-list');
            if (!conflicts.length) {
                panel.classList.add('hidden');
                list.innerHTML = '';
                showToast('Конфликтов не найдено', 'success');
                return;
            }
            panel.classList.remove('hidden');
            list.innerHTML = conflicts.slice(0, 200).map(c => {
                const cls = c.type === 'reverse' ? 'conflict-reverse' : 'conflict-overlap';
                return `
                    <div class="${cls} bg-white/5 border border-white/10 rounded-lg p-3">
                        <div class="font-medium">${escapeHtml(c.type)}: ${escapeHtml(c.title)}</div>
                        <div class="text-xs text-gray-400 mt-1">${escapeHtml(c.items.join(' • '))}</div>
                    </div>
                `;
            }).join('');
            showToast(`Найдено конфликтов: ${conflicts.length}`, 'warn');
        }

        // ----------------- Prompt UI & Dry Run -----------------
        function loadSystemPromptPreset() {
            const preset = $('system-prompt-preset').value;
            if (!preset || !SYSTEM_PRESET[preset]) return;
            $('system-prompt').value = SYSTEM_PRESET[preset];
            persistSettings();
            showToast('Пресет применён', 'success');
        }

        function resetTranslationPrompt() {
            $('translation-prompt').value = DEFAULT_PROMPTS.translation;
            persistSettings();
            showToast('Промпт перевода сброшен', 'success');
        }

        function resetGlossaryPrompt() {
            $('glossary-prompt').value = DEFAULT_PROMPTS.glossary;
            persistSettings();
            showToast('Промпт глоссария сброшен', 'success');
        }

        function updateDryRunChapterSelect() {
            const sel = $('dry-run-chapter');
            if (!sel) return;
            sel.innerHTML = '';
            app.chapters.forEach((ch, idx) => {
                const opt = document.createElement('option');
                opt.value = String(idx);
                opt.textContent = ch.name;
                sel.appendChild(opt);
            });
        }

        function showDryRunModal() {
            if (!app.chapters.length) return;
            $('dry-run-modal').classList.remove('hidden');
            $('manual-response-section').classList.add('hidden');
        }
        function hideDryRunModal() {
            $('dry-run-modal').classList.add('hidden');
        }
        function generateDryRunPrompt() {
            if (!app.chapters.length) return;
            persistSettings();
            const idx = Number($('dry-run-chapter').value || 0);
            const text = app.chapters[idx]?.originalHtml || '';
            const glossary = buildGlossaryText();
            const prompt = [
                '### SYSTEM',
                app.settings.systemPrompt || DEFAULT_PROMPTS.system,
                '',
                '### USER',
                (app.settings.translationPrompt || DEFAULT_PROMPTS.translation)
                    .replaceAll('{glossary}', glossary)
                    .replaceAll('{text}', text)
            ].join('\n');
            $('dry-run-content').textContent = prompt;
            showToast('Промпт собран', 'success');
        }
        function copyDryRunPrompt() {
            const txt = $('dry-run-content').textContent || '';
            navigator.clipboard.writeText(txt);
            showToast('Скопировано', 'success');
        }
        function showManualResponseInput() {
            $('manual-response-section').classList.remove('hidden');
        }
        function hideManualResponseInput() {
            $('manual-response-section').classList.add('hidden');
        }
        function applyManualResponse() {
            const idx = Number($('dry-run-chapter').value || 0);
            const html = ($('manual-response-input').value || '').trim();
            if (!html) {
                showToast('Вставьте HTML перевода', 'warn');
                return;
            }
            app.chapters[idx].translatedHtml = html;
            addLog(`Ручной перевод применён к главе ${idx + 1}`, 'success');
            $('manual-response-input').value = '';
            showToast('Перевод применён', 'success');
        }

        // ----------------- Doctor -----------------
        function doctorClearFragment() {
            $('doctor-input').value = '';
            $('doctor-output').value = '';
        }

        function prettifyHtmlFragment(input) {
            // A conservative formatter: parse as XML-ish if possible; otherwise keep.
            const src = (input || '').replace(/\r\n/g, '\n');
            if (!src.trim()) return '';
            try {
                const parser = new DOMParser();
                // Try XML first (XHTML)
                let doc = parser.parseFromString(src, 'application/xhtml+xml');
                if (doc.querySelector('parsererror')) {
                    doc = parser.parseFromString(src, 'text/html');
                }

                // Serialize body/whole
                if (doc.contentType === 'text/html') {
                    // Pretty-print by indenting nodes (simple)
                    const body = doc.body;
                    return formatNode(body, 0).trim() + '\n';
                }

                const ser = new XMLSerializer();
                return ser.serializeToString(doc).replace(/></g, '>\n<') + '\n';
            } catch {
                return src;
            }
        }

        function formatNode(node, depth) {
            const pad = '  '.repeat(depth);
            let out = '';
            node.childNodes.forEach(ch => {
                if (ch.nodeType === Node.TEXT_NODE) {
                    const t = ch.textContent.replace(/\s+/g, ' ').trim();
                    if (t) out += pad + t + '\n';
                } else if (ch.nodeType === Node.ELEMENT_NODE) {
                    const tag = ch.tagName.toLowerCase();
                    const attrs = Array.from(ch.attributes).map(a => `${a.name}="${a.value}"`).join(' ');
                    const open = attrs ? `<${tag} ${attrs}>` : `<${tag}>`;
                    const close = `</${tag}>`;
                    out += pad + open + '\n';
                    out += formatNode(ch, depth + 1);
                    out += pad + close + '\n';
                } else if (ch.nodeType === Node.COMMENT_NODE) {
                    out += pad + `<!--${ch.textContent}-->` + '\n';
                }
            });
            return out;
        }

        function doctorPrettifyFragment() {
            const input = $('doctor-input').value;
            const out = prettifyHtmlFragment(input);
            $('doctor-output').value = out;
            showToast('Prettify выполнен', 'success');
        }

        function doctorCopyOutput() {
            navigator.clipboard.writeText($('doctor-output').value || '');
            showToast('Скопировано', 'success');
        }

        function doctorEpubLog(msg, level = 'info') {
            const c = $('doctor-epub-log');
            if (!c) return;
            if (c.querySelector('.text-gray-500')) c.innerHTML = '';
            const div = document.createElement('div');
            const color = level === 'error' ? 'text-red-300' : level === 'success' ? 'text-green-300' : 'text-gray-200';
            div.className = 'log-entry py-1';
            div.innerHTML = `<span class="text-gray-500">[${escapeHtml(nowTs())}]</span> <span class="${color}">${escapeHtml(msg)}</span>`;
            c.appendChild(div);
            c.scrollTop = c.scrollHeight;
        }

        async function doctorHandleEpub(e) {
            const file = e.target.files?.[0];
            if (!file) return;
            $('doctor-download-btn').disabled = true;
            $('doctor-epub-filename').textContent = file.name;
            $('doctor-epub-status').textContent = 'Загрузка…';
            $('doctor-epub-progress').style.width = '0%';
            $('doctor-epub-percent').textContent = '0%';
            $('doctor-epub-log').innerHTML = '';

            doctorEpubLog(`Открываю EPUB: ${file.name}`);
            try {
                const buf = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(buf);
                const paths = Object.keys(zip.files).filter(p => /\.(xhtml|html|htm)$/i.test(p));
                const outZip = new JSZip();
                const all = Object.keys(zip.files);
                let done = 0;

                for (const p of all) {
                    const f = zip.files[p];
                    if (f.dir) {
                        outZip.folder(p);
                        continue;
                    }
                    const isHtml = paths.includes(p);
                    if (isHtml) {
                        const txt = await f.async('string');
                        const pretty = prettifyHtmlFragment(txt);
                        outZip.file(p, pretty);
                    } else {
                        outZip.file(p, await f.async('arraybuffer'));
                    }
                    done++;
                    const pct = Math.floor((done / all.length) * 100);
                    $('doctor-epub-progress').style.width = `${pct}%`;
                    $('doctor-epub-percent').textContent = `${pct}%`;
                    $('doctor-epub-status').textContent = `Обработано ${done}/${all.length}`;
                    if (done % 25 === 0) await sleep(0);
                }

                $('doctor-epub-status').textContent = 'Сборка…';
                const blob = await outZip.generateAsync({ type: 'blob' });
                app.doctor.outputEpubBlob = blob;
                const base = file.name.replace(/\.epub$/i, '');
                app.doctor.outputName = `${base}_prettified.epub`;
                $('doctor-download-btn').disabled = false;
                $('doctor-epub-status').textContent = 'Готово';
                $('doctor-epub-progress').style.width = '100%';
                $('doctor-epub-percent').textContent = '100%';
                doctorEpubLog('Готово. Можно скачать результат.', 'success');
                showToast('EPUB Doctor завершён', 'success');
            } catch (err) {
                console.error(err);
                $('doctor-epub-status').textContent = 'Ошибка';
                doctorEpubLog(`Ошибка: ${err?.message || err}`, 'error');
                showToast('Ошибка EPUB Doctor', 'error');
            }
        }

        function doctorDownloadEpub() {
            if (!app.doctor.outputEpubBlob) return;
            downloadBlob(app.doctor.outputEpubBlob, app.doctor.outputName || `prettified_${Date.now()}.epub`);
        }

        // ----------------- Modals: Project history -----------------
        function showProjectHistory() {
            renderProjectHistory();
            $('project-history-modal').classList.remove('hidden');
        }
        function hideProjectHistory() {
            $('project-history-modal').classList.add('hidden');
        }
        function pushProjectHistory(meta) {
            const item = {
                id: crypto.randomUUID?.() || String(Date.now()),
                ts: Date.now(),
                ...meta
            };
            app.projectHistory.unshift(item);
            app.projectHistory = app.projectHistory.slice(0, 30);
            save(STORAGE_KEYS.projects, app.projectHistory);
        }
        function renderProjectHistory() {
            const c = $('project-history-list');
            if (!c) return;
            if (!app.projectHistory.length) {
                c.innerHTML = '<p class="text-gray-400 text-center py-8">История пуста</p>';
                return;
            }
            c.innerHTML = '';
            for (const it of app.projectHistory) {
                const div = document.createElement('div');
                div.className = 'bg-white/5 border border-white/10 rounded-xl p-4';
                const dt = new Date(it.ts).toLocaleString('ru-RU');
                div.innerHTML = `
                    <div class="flex items-center justify-between gap-3">
                        <div>
                            <div class="font-semibold">${escapeHtml(it.name || 'Проект')}</div>
                            <div class="text-xs text-gray-500">${escapeHtml(dt)} • глав: ${it.chapters ?? '-'} • переведено: ${it.translated ?? '-'}</div>
                        </div>
                        <button class="text-xs bg-white/10 hover:bg-white/20 px-3 py-1 rounded-lg transition">Удалить</button>
                    </div>
                `;
                div.querySelector('button').onclick = () => {
                    app.projectHistory = app.projectHistory.filter(x => x.id !== it.id);
                    save(STORAGE_KEYS.projects, app.projectHistory);
                    renderProjectHistory();
                };
                c.appendChild(div);
            }
        }
        function clearProjectHistory() {
            if (!confirm('Очистить историю проектов?')) return;
            app.projectHistory = [];
            save(STORAGE_KEYS.projects, app.projectHistory);
            renderProjectHistory();
            showToast('История очищена', 'success');
        }

        // ----------------- Export / Import -----------------
        function exportSettings() {
            persistSettings();
            const payload = {
                settings: app.settings,
                keys: app.keys
            };
            downloadBlob(new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json;charset=utf-8' }), `epub_translator_settings_${Date.now()}.json`);
        }

        function importSettings(e) {
            const file = e.target.files?.[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const data = JSON.parse(String(reader.result));
                    if (data.settings) app.settings = { ...app.settings, ...data.settings };
                    if (data.keys) app.keys = data.keys;
                    save(STORAGE_KEYS.settings, app.settings);
                    save(STORAGE_KEYS.keys, app.keys);
                    restoreSettingsToUI();
                    renderProviders();
                    renderModels();
                    renderKeyProviderSelect();
                    updateHeaderInfo();
                    showToast('Настройки импортированы', 'success');
                } catch {
                    showToast('Некорректный JSON', 'error');
                }
            };
            reader.readAsText(file);
        }

        function exportProject() {
            persistSettings();
            const payload = {
                version: 1,
                ts: Date.now(),
                fileName: app.currentFile?.name || null,
                settings: app.settings,
                glossary: app.glossary,
                chapters: app.chapters.map(c => ({
                    path: c.path,
                    name: c.name,
                    originalHtml: c.originalHtml,
                    translatedHtml: c.translatedHtml,
                    validated: c.validated
                }))
            };
            downloadBlob(new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json;charset=utf-8' }), `epub_project_${Date.now()}.json`);
            showToast('Проект экспортирован', 'success');
        }

        function importProjectFile(e) {
            const file = e.target.files?.[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const data = JSON.parse(String(reader.result));
                    if (!Array.isArray(data.chapters)) throw new Error('Нет chapters');
                    app.settings = { ...app.settings, ...(data.settings || {}) };
                    app.glossary = data.glossary || {};
                    app.chapters = data.chapters.map((c, i) => ({
                        path: c.path || `chapter_${i + 1}.xhtml`,
                        name: c.name || `Глава ${i + 1}`,
                        originalHtml: c.originalHtml || '',
                        translatedHtml: c.translatedHtml || null,
                        validated: !!c.validated
                    }));
                    save(STORAGE_KEYS.settings, app.settings);
                    save(STORAGE_KEYS.glossary, app.glossary);
                    restoreSettingsToUI();
                    renderProviders();
                    renderModels();
                    updateHeaderInfo();
                    renderGlossary();
                    renderValidatorChapters();
                    showToast('Проект импортирован', 'success');
                    switchTab('validator');
                } catch (err) {
                    showToast('Не удалось импортировать проект', 'error');
                    console.error(err);
                }
            };
            reader.readAsText(file);
        }

        function clearAllData() {
            if (!confirm('Очистить все данные (настройки, ключи, глоссарий, историю)?')) return;
            localStorage.removeItem(STORAGE_KEYS.settings);
            localStorage.removeItem(STORAGE_KEYS.keys);
            localStorage.removeItem(STORAGE_KEYS.glossary);
            localStorage.removeItem(STORAGE_KEYS.projects);
            localStorage.removeItem(STORAGE_KEYS.log);
            location.reload();
        }

        // ----------------- Glossary AI modals (preview-only) -----------------
        function showGlossaryGeneratorModal() {
            $('glossary-generator-modal').classList.remove('hidden');
            if (app.chapters.length) $('gg-total-info').textContent = `Доступно глав: ${app.chapters.length}`;
        }
        function hideGlossaryGeneratorModal() {
            $('glossary-generator-modal').classList.add('hidden');
        }
        function glossaryGeneratorBuildPreview() {
            if (!app.chapters.length) {
                $('gg-preview').textContent = 'Сначала загрузите EPUB во вкладке «Перевод».\n';
                return;
            }
            persistSettings();
            const start = clamp(Number($('gg-start').value || 1), 1, app.chapters.length);
            const end = clamp(Number($('gg-end').value || start), start, app.chapters.length);
            const text = app.chapters.slice(start - 1, end).map(c => c.originalHtml).join('\n\n');
            const prompt = (app.settings.glossaryPrompt || DEFAULT_PROMPTS.glossary).replaceAll('{text}', text);
            $('gg-preview').textContent = prompt;
            const tokens = estimateTokens(prompt);
            const limit = Number($('gg-token-limit').value || 60000);
            const warn = $('gg-preview-warn');
            if (tokens > limit) {
                warn.classList.remove('hidden');
                warn.textContent = `Превью ≈ ${tokens} токенов, это больше лимита ${limit}. Уменьшите диапазон глав.`;
            } else {
                warn.classList.add('hidden');
            }
        }
        function glossaryGeneratorCopyPreview() {
            navigator.clipboard.writeText($('gg-preview').textContent || '');
            showToast('Превью скопировано', 'success');
        }
        function glossaryGeneratorRun() {
            showToast('В web-демо генерация не вызывает API. Используйте превью и вставьте JSON в поле результата.', 'warn');
        }
        function glossaryGeneratorMergeResult() {
            const txt = $('gg-result').value || '';
            if (!txt.trim()) {
                showToast('Вставьте JSON результата', 'warn');
                return;
            }
            let data;
            try { data = JSON.parse(txt); } catch { showToast('Некорректный JSON', 'error'); return; }
            const mode = document.querySelector('input[name="gg-merge"]:checked')?.value || 'supplement';
            const includeNotes = $('gg-include-notes').checked;

            let changed = 0;
            for (const [term, obj] of Object.entries(data)) {
                const item = {
                    translation: obj?.translation ?? obj?.Translation ?? '',
                    note: includeNotes ? (obj?.note ?? obj?.Note ?? '') : ''
                };
                if (mode === 'supplement') {
                    if (!app.glossary[term]) { app.glossary[term] = item; changed++; }
                } else if (mode === 'update') {
                    app.glossary[term] = item; changed++;
                } else {
                    // accumulate: if exists, create unique key
                    if (!app.glossary[term]) { app.glossary[term] = item; changed++; }
                    else {
                        let k = 2;
                        while (app.glossary[`${term}#${k}`]) k++;
                        app.glossary[`${term}#${k}`] = item;
                        changed++;
                    }
                }
            }

            save(STORAGE_KEYS.glossary, app.glossary);
            renderGlossary();
            showToast(`Применено терминов: ${changed}`, 'success');
        }

        function showGlossaryCorrectorModal() {
            $('glossary-corrector-modal').classList.remove('hidden');
        }
        function hideGlossaryCorrectorModal() {
            $('glossary-corrector-modal').classList.add('hidden');
        }
        function glossaryCorrectorBuildPreview() {
            const src = document.querySelector('input[name="gc-source"]:checked')?.value || 'conflicts';
            const noNotes = $('gc-no-notes').checked;
            const allowAdd = $('gc-allow-additions').checked;
            const entries = Object.entries(app.glossary);
            let input = {};
            if (src === 'all') {
                input = Object.fromEntries(entries.map(([t, v]) => [t, { translation: v.translation || '', note: noNotes ? '' : (v.note || '') }]));
            } else {
                // conflicts only: same translation used by multiple terms
                const byTr = new Map();
                for (const [t, v] of entries) {
                    const tr = (v.translation || '').trim();
                    if (!tr) continue;
                    if (!byTr.has(tr)) byTr.set(tr, []);
                    byTr.get(tr).push([t, v]);
                }
                for (const [tr, arr] of byTr.entries()) {
                    if (arr.length > 1) {
                        for (const [t, v] of arr) input[t] = { translation: v.translation || '', note: noNotes ? '' : (v.note || '') };
                    }
                }
            }
            const prompt = [
                'Исправь и унифицируй глоссарий. Верни JSON-патч формата:',
                '{"updates": {"Term": {"translation":"...","note":"..."}}, "additions": {"NewTerm": {...}} }',
                `Разрешить добавления: ${allowAdd ? 'да' : 'нет'}.`,
                '',
                'Входные данные:',
                JSON.stringify(input, null, 2)
            ].join('\n');
            $('gc-preview').textContent = prompt;
            const tokens = estimateTokens(prompt);
            const limit = Number($('gc-token-limit').value || 60000);
            const warn = $('gc-preview-warn');
            if (tokens > limit) {
                warn.classList.remove('hidden');
                warn.textContent = `Превью ≈ ${tokens} токенов, больше лимита ${limit}. Сузьте вход.`;
            } else warn.classList.add('hidden');
        }
        function glossaryCorrectorCopyPreview() {
            navigator.clipboard.writeText($('gc-preview').textContent || '');
            showToast('Превью скопировано', 'success');
        }
        function glossaryCorrectorRun() {
            showToast('В web-демо корректор не вызывает API. Вставьте JSON-патч вручную.', 'warn');
        }
        function glossaryCorrectorCopyPatch() {
            navigator.clipboard.writeText($('gc-patch').value || '');
            showToast('Патч скопирован', 'success');
        }
        function glossaryCorrectorApplyPatch() {
            const txt = $('gc-patch').value || '';
            if (!txt.trim()) { showToast('Вставьте JSON-патч', 'warn'); return; }
            let patch;
            try { patch = JSON.parse(txt); } catch { showToast('Некорректный JSON', 'error'); return; }
            const updates = patch.updates || {};
            const additions = patch.additions || {};
            let changed = 0;
            for (const [t, v] of Object.entries(updates)) {
                if (!app.glossary[t]) app.glossary[t] = { translation: '', note: '' };
                app.glossary[t].translation = v.translation ?? app.glossary[t].translation;
                app.glossary[t].note = v.note ?? app.glossary[t].note;
                changed++;
            }
            for (const [t, v] of Object.entries(additions)) {
                if (!app.glossary[t]) {
                    app.glossary[t] = { translation: v.translation || '', note: v.note || '' };
                    changed++;
                }
            }
            save(STORAGE_KEYS.glossary, app.glossary);
            renderGlossary();
            showToast(`Патч применён. Изменений: ${changed}`, 'success');
        }

        // ----------------- Glossary Resolver (minimal stub UI) -----------------
        function showGlossaryResolverModal() {
            $('glossary-resolver-modal').classList.remove('hidden');
            buildResolverGroups();
        }
        function hideGlossaryResolverModal() {
            $('glossary-resolver-modal').classList.add('hidden');
        }
        let resolverState = { groups: [], selected: -1, overlapView: 'termInTerm' };

        function buildResolverGroups() {
            const mode = $('gr-mode').value;
            const entries = Object.entries(app.glossary);
            const groups = [];

            if (mode === 'reverse') {
                const map = new Map();
                for (const [t, v] of entries) {
                    const tr = (v.translation || '').trim();
                    if (!tr) continue;
                    if (!map.has(tr)) map.set(tr, []);
                    map.get(tr).push(t);
                }
                for (const [tr, terms] of map.entries()) {
                    if (terms.length > 1) groups.push({ id: tr, title: tr, subtitle: `${terms.length} терминов`, terms });
                }
            } else if (mode === 'direct') {
                // group terms that look like Term#2
                const baseMap = new Map();
                for (const [t] of entries) {
                    const base = t.replace(/#\d+$/,'');
                    if (!baseMap.has(base)) baseMap.set(base, []);
                    baseMap.get(base).push(t);
                }
                for (const [base, terms] of baseMap.entries()) {
                    if (terms.length > 1) groups.push({ id: base, title: base, subtitle: `${terms.length} версии`, terms });
                }
            } else {
                const terms = entries.map(e => e[0]);
                for (let i = 0; i < terms.length; i++) {
                    for (let j = 0; j < terms.length; j++) {
                        if (i === j) continue;
                        const a = terms[i], b = terms[j];
                        if (a.length >= 4 && b.includes(a) && b !== a) {
                            groups.push({ id: `${a}⊂${b}`, title: a, subtitle: `внутри ${b}`, terms: [a, b] });
                        }
                    }
                }
            }

            resolverState.groups = groups;
            resolverState.selected = groups.length ? 0 : -1;
            $('gr-summary').textContent = `Групп: ${groups.length}`;
            $('gr-toggle-view').disabled = mode !== 'overlap';

            renderResolverList();
            renderResolverEditor();
        }

        function renderResolverList() {
            const q = ($('gr-search').value || '').trim().toLowerCase();
            const list = $('gr-list');
            const mode = $('gr-mode').value;
            let groups = resolverState.groups;
            if (q) groups = groups.filter(g => g.title.toLowerCase().includes(q) || g.subtitle.toLowerCase().includes(q) || g.terms.some(t => t.toLowerCase().includes(q)));

            list.innerHTML = '';
            if (!groups.length) {
                list.innerHTML = '<div class="text-gray-500 text-sm text-center py-10">Нет данных</div>';
                return;
            }
            groups.forEach((g, i) => {
                const btn = document.createElement('button');
                const selected = i === resolverState.selected;
                btn.className = `chapter-row w-full text-left p-3 rounded-lg transition ${selected ? 'selected' : ''}`;
                btn.innerHTML = `
                    <div class="font-medium">${escapeHtml(g.title)}</div>
                    <div class="text-xs text-gray-500">${escapeHtml(g.subtitle)} • ${escapeHtml(mode)}</div>
                `;
                btn.onclick = () => { resolverState.selected = i; renderResolverList(); renderResolverEditor(); };
                list.appendChild(btn);
            });
        }

        function renderResolverEditor() {
            const idx = resolverState.selected;
            if (idx < 0 || idx >= resolverState.groups.length) {
                $('gr-current-title').textContent = '—';
                $('gr-current-subtitle').textContent = '—';
                $('gr-editor').innerHTML = '<div class="text-sm text-gray-400">Выберите группу слева.</div>';
                return;
            }
            const g = resolverState.groups[idx];
            $('gr-current-title').textContent = g.title;
            $('gr-current-subtitle').textContent = g.subtitle;

            const html = g.terms.map(term => {
                const v = app.glossary[term] || {};
                return `
                    <div class="bg-white/5 border border-white/10 rounded-xl p-4 mb-3">
                        <div class="font-semibold">${escapeHtml(term)}</div>
                        <div class="mt-2 grid grid-cols-1 md:grid-cols-2 gap-3">
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Перевод</div>
                                <input class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm" data-gr-term="${escapeHtml(term)}" data-gr-field="translation" value="${escapeHtml(v.translation || '')}" />
                            </div>
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Примечание</div>
                                <input class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm" data-gr-term="${escapeHtml(term)}" data-gr-field="note" value="${escapeHtml(v.note || '')}" />
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            $('gr-editor').innerHTML = html;
            $('gr-editor').querySelectorAll('input').forEach(inp => {
                inp.addEventListener('input', () => {
                    const t = inp.getAttribute('data-gr-term');
                    const field = inp.getAttribute('data-gr-field');
                    if (!app.glossary[t]) app.glossary[t] = { translation: '', note: '' };
                    app.glossary[t][field] = inp.value;
                });
            });
        }

        function glossaryResolverApplyEdits() {
            save(STORAGE_KEYS.glossary, app.glossary);
            renderGlossary();
            buildResolverGroups();
            showToast('Изменения применены', 'success');
        }

        function glossaryResolverToggleOverlapView() {
            showToast('Переключатель вида наложений — заглушка (логика добавится позже)', 'warn');
        }
        function glossaryResolverWizardPrev() { showToast('Wizard: Назад (заглушка)', 'warn'); }
        function glossaryResolverWizardNext() { showToast('Wizard: Далее (заглушка)', 'warn'); }

        // Keep resolver list in sync
        document.addEventListener('input', (e) => {
            if (e.target && e.target.id === 'gr-search') renderResolverList();
        });
        document.addEventListener('change', (e) => {
            if (e.target && e.target.id === 'gr-mode') buildResolverGroups();
            if (e.target && e.target.id === 'gr-wizard') $('gr-wizard-controls').classList.toggle('hidden', !e.target.checked);
        });

        // ----------------- Glossary import -----------------
        function importGlossary(e) {
            const file = e.target.files?.[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                const raw = String(reader.result);
                let parsed = null;
                try { parsed = JSON.parse(raw); } catch { parsed = null; }
                if (parsed && typeof parsed === 'object') {
                    // accept either {term:{translation,note}} or array of entries
                    let count = 0;
                    if (Array.isArray(parsed)) {
                        for (const it of parsed) {
                            if (it && it.term) {
                                app.glossary[it.term] = { translation: it.translation || '', note: it.note || '' };
                                count++;
                            }
                        }
                    } else {
                        for (const [t, v] of Object.entries(parsed)) {
                            app.glossary[t] = { translation: v.translation || v.Translation || '', note: v.note || v.Note || '' };
                            count++;
                        }
                    }
                    save(STORAGE_KEYS.glossary, app.glossary);
                    renderGlossary();
                    showToast(`Импортировано терминов: ${count}`, 'success');
                } else {
                    // try txt: each line "term => translation"
                    const lines = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                    let count = 0;
                    for (const line of lines) {
                        const m = line.split(/=>|->|\t/).map(s => s.trim());
                        if (!m[0]) continue;
                        app.glossary[m[0]] = { translation: m[1] || '', note: '' };
                        count++;
                    }
                    save(STORAGE_KEYS.glossary, app.glossary);
                    renderGlossary();
                    showToast(`Импортировано терминов: ${count}`, 'success');
                }
            };
            reader.readAsText(file);
        }

        // ----------------- App init -----------------
        function init() {
            app.settings = { ...app.settings, ...(load(STORAGE_KEYS.settings, {}) || {}) };
            app.keys = load(STORAGE_KEYS.keys, {}) || {};
            app.glossary = load(STORAGE_KEYS.glossary, {}) || {};
            app.projectHistory = load(STORAGE_KEYS.projects, []) || [];
            app.log = load(STORAGE_KEYS.log, []) || [];

            restoreSettingsToUI();
            renderProviders();
            renderModels();
            renderKeyProviderSelect();
            updateHeaderInfo();
            renderGlossary();
            renderLog();

            // Save on change for settings inputs
            ['chunk-size','max-glossary-terms','max-retries','num-instances','batching-max-chars'].forEach(id => {
                const el = $(id);
                if (el) el.addEventListener('change', persistSettings);
            });
            ['create-glossary','keep-censored','auto-save','enable-batching'].forEach(id => {
                const el = $(id);
                if (el) el.addEventListener('change', persistSettings);
            });
            ['system-prompt','translation-prompt','glossary-prompt'].forEach(id => {
                const el = $(id);
                if (el) el.addEventListener('input', () => { persistSettings(); });
            });
        }

        window.addEventListener('DOMContentLoaded', init);

        // Expose required functions globally (onclick handlers)
        Object.assign(window, {
            switchTab,
            showProjectHistory,
            hideProjectHistory,
            handleDragOver,
            handleDragLeave,
            handleDrop,
            handleFileSelect,
            clearFile,
            togglePartialTranslation,
            startTranslation,
            pauseTranslation,
            cancelTranslation,
            downloadEpub,
            downloadGlossary,
            openInValidator,
            resetTranslation,
            downloadLog,
            clearLog,
            loadProjectForValidation,
            setValidatorViewMode,
            prevChapterValidator,
            nextChapterValidator,
            markAsValidated,
            retryChapter,
            updateKeyProviderInfo,
            addKeys,
            exportSettings,
            importSettings,
            exportProject,
            importProjectFile,
            clearProjectHistory,
            clearAllData,
            analyzeGlossaryConflicts,
            showGlossaryResolverModal,
            showGlossaryGeneratorModal,
            showGlossaryCorrectorModal,
            hideGlossaryGeneratorModal,
            hideGlossaryCorrectorModal,
            hideGlossaryResolverModal,
            importGlossary,
            clearGlossary,
            downloadGlossary,
            addGlossaryTerm,
            searchGlossary,
            loadSystemPromptPreset,
            resetTranslationPrompt,
            resetGlossaryPrompt,
            showDryRunModal,
            hideDryRunModal,
            generateDryRunPrompt,
            copyDryRunPrompt,
            showManualResponseInput,
            hideManualResponseInput,
            applyManualResponse,
            doctorCopyOutput,
            doctorPrettifyFragment,
            doctorClearFragment,
            doctorHandleEpub,
            doctorDownloadEpub,
            glossaryGeneratorBuildPreview,
            glossaryGeneratorRun,
            glossaryGeneratorCopyPreview,
            glossaryGeneratorMergeResult,
            glossaryCorrectorBuildPreview,
            glossaryCorrectorRun,
            glossaryCorrectorCopyPreview,
            glossaryCorrectorCopyPatch,
            glossaryCorrectorApplyPatch,
            glossaryResolverToggleOverlapView,
            glossaryResolverWizardPrev,
            glossaryResolverWizardNext,
            glossaryResolverApplyEdits
        });
    </script>

<script id="PATCH_EXTRAS_V3">
(function () {
  "use strict";

  // -------- helpers --------
  function $(id){ return document.getElementById(id); }

  function getLogContainer() {
    return $("log-container")
        || $("log-output")
        || document.querySelector("[data-log-container]")
        || document.querySelector(".log-container");
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  // -------- LOG (fast) --------
  var MAX_LINES = 350;          // меньше = быстрее
  var FLUSH_EVERY_MS = 120;     // батч-обновление UI
  var SANITY_EVERY_MS = 1500;   // редкая проверка, что лог не "перетёрли"

  window.__logBuffer = Array.isArray(window.__logBuffer) ? window.__logBuffer : [];
  var pending = [];            // новые записи, которые надо дорисовать
  var flushTimer = null;
  var lastDrawnCount = 0;

  function normalizeEntry(payload, fallbackType) {
    if (payload && typeof payload === "object") {
      return {
        message: (payload.message ?? payload.msg ?? JSON.stringify(payload)),
        type: (payload.type ?? fallbackType ?? "info"),
        time: payload.time ? new Date(payload.time) : new Date()
      };
    }
    return { message: String(payload), type: (fallbackType ?? "info"), time: new Date() };
  }

  function ensureLogScrollable(c) {
    c.style.overflowY = "auto";
    if (!c.style.maxHeight) c.style.maxHeight = "240px";
    if (!c.style.minHeight) c.style.minHeight = "80px";
  }

  function makeRow(entry) {
    var t = new Date(entry.time || Date.now()).toLocaleTimeString();
    var type = entry.type || "info";

    var color = "#9CA3AF"; // gray
    if (type === "error") color = "#F87171";
    if (type === "success") color = "#34D399";
    if (type === "warning") color = "#FBBF24";

    var div = document.createElement("div");
    div.style.fontFamily = "monospace";
    div.style.fontSize = "12px";
    div.style.lineHeight = "1.35";
    div.style.margin = "0 0 6px 0";
    div.style.borderBottom = "1px solid rgba(255,255,255,0.06)";
    div.style.paddingBottom = "4px";
    div.style.wordBreak = "break-word";
    div.style.color = color;

    div.innerHTML =
      '<span style="opacity:0.6">[' + escapeHtml(t) + ']</span> ' +
      escapeHtml(entry.message);

    return div;
  }

  function trimBufferAndDom(c) {
    // буфер
    if (window.__logBuffer.length > MAX_LINES) {
      window.__logBuffer.splice(0, window.__logBuffer.length - MAX_LINES);
    }
    // DOM
    while (c.children.length > MAX_LINES) {
      c.removeChild(c.firstChild);
    }
  }

  function flush() {
    flushTimer = null;
    var c = getLogContainer();
    if (!c) return;

    ensureLogScrollable(c);

    if (pending.length === 0) return;

    var frag = document.createDocumentFragment();
    for (var i = 0; i < pending.length; i++) {
      frag.appendChild(makeRow(pending[i]));
    }
    pending.length = 0;

    c.appendChild(frag);
    trimBufferAndDom(c);

    c.scrollTop = c.scrollHeight;
    lastDrawnCount = window.__logBuffer.length;
  }

  function scheduleFlush() {
    if (flushTimer !== null) return;
    flushTimer = setTimeout(flush, FLUSH_EVERY_MS);
  }

  function pushLog(entry) {
    window.__logBuffer.push(entry);
    pending.push(entry);

    // держим буфер ограниченным сразу (чтобы память не росла)
    if (window.__logBuffer.length > MAX_LINES) {
      var overflow = window.__logBuffer.length - MAX_LINES;
      window.__logBuffer.splice(0, overflow);
      // если обрезали буфер — придётся ре-синхронизировать DOM при sanity check
      lastDrawnCount = Math.min(lastDrawnCount, window.__logBuffer.length);
    }

    scheduleFlush();
  }

  function renderAllFromBuffer() {
    var c = getLogContainer();
    if (!c) return;
    ensureLogScrollable(c);

    // Полный ререндер делаем редко (только если лог "перетёрли")
    c.innerHTML = "";
    var frag = document.createDocumentFragment();
    for (var i = 0; i < window.__logBuffer.length; i++) {
      frag.appendChild(makeRow(window.__logBuffer[i]));
    }
    c.appendChild(frag);
    trimBufferAndDom(c);
    c.scrollTop = c.scrollHeight;
    pending.length = 0;
    lastDrawnCount = window.__logBuffer.length;
  }

  function installLogHooks() {
    // eventBus.emit('log', payload)
    try {
      if (window.eventBus && typeof window.eventBus.emit === "function" && !window.eventBus.__patchedLogV3) {
        var origEmit = window.eventBus.emit.bind(window.eventBus);
        window.eventBus.emit = function (name, payload) {
          try {
            if (name === "log") pushLog(normalizeEntry(payload, payload && payload.type));
          } catch (_) {}
          return origEmit(name, payload);
        };
        window.eventBus.__patchedLogV3 = true;
      }
    } catch (_) {}

    // window.log(message, type)
    try {
      if (typeof window.log === "function" && !window.__patchedLogFnV3) {
        var origLog = window.log;
        window.log = function (message, type) {
          try { pushLog(normalizeEntry({ message: message, type: type || "info", time: new Date() }, type || "info")); } catch (_) {}
          return origLog.apply(this, arguments);
        };
        window.__patchedLogFnV3 = true;
      }
    } catch (_) {}

    // clearLog hook
    try {
      if (typeof window.clearLog === "function" && !window.__patchedClearLogV3) {
        var origClear = window.clearLog;
        window.clearLog = function () {
          try { window.__logBuffer.length = 0; pending.length = 0; lastDrawnCount = 0; } catch (_) {}
          try {
            var c = getLogContainer();
            if (c) c.innerHTML = '<div style="opacity:.6;font-size:12px">Лог очищен.</div>';
          } catch (_) {}
          return origClear.apply(this, arguments);
        };
        window.__patchedClearLogV3 = true;
      }
    } catch (_) {}

    // Экспорт полного лога
    window.downloadFullLog = function() {
      var text = window.__logBuffer.map(function(e){
        var t = new Date(e.time || Date.now()).toLocaleTimeString();
        return "[" + t + "] " + (e.type || "info") + ": " + (e.message || "");
      }).join("\n");
      var blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      var a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "translation_log.txt";
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){
        try { URL.revokeObjectURL(a.href); } catch(_) {}
        try { a.remove(); } catch(_) {}
      }, 1000);
    };

    // sanity check: если внешний код перетёр контейнер — восстановим редко
    setInterval(function(){
      try {
        var c = getLogContainer();
        if (!c) return;
        // если внезапно мало строк при непустом буфере — значит кто-то перерисовал лог
        if (window.__logBuffer.length > 0 && c.children.length < Math.min(3, window.__logBuffer.length) && lastDrawnCount > 0) {
          renderAllFromBuffer();
        }
      } catch (_) {}
    }, SANITY_EVERY_MS);
  }

  // -------- PROMPT IMPORT/EXPORT (.txt) --------
  function downloadText(filename, text) {
    var blob = new Blob([String(text || "")], { type: "text/plain;charset=utf-8" });
    var a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(function () {
      try { URL.revokeObjectURL(a.href); } catch (_) {}
      try { a.remove(); } catch (_) {}
    }, 1000);
  }

  function addFileTools(textarea, baseName) {
    if (!textarea || textarea.dataset.filetoolsV3 === "1") return;
    textarea.dataset.filetoolsV3 = "1";

    var wrap = document.createElement("div");
    wrap.style.display = "flex";
    wrap.style.gap = "8px";
    wrap.style.marginTop = "8px";
    wrap.style.flexWrap = "wrap";

    function mkBtn(label) {
      var b = document.createElement("button");
      b.type = "button";
      b.textContent = label;
      b.className = "px-3 py-2 rounded-xl bg-white/10 border border-white/20 text-sm";
      return b;
    }

    var btnImport = mkBtn("Импорт .txt");
    var btnExport = mkBtn("Экспорт .txt");
    var input = document.createElement("input");
    input.type = "file";
    input.accept = ".txt,text/plain";
    input.style.display = "none";

    btnImport.addEventListener("click", function(){ input.click(); });
    input.addEventListener("change", function(){
      var file = input.files && input.files[0];
      if (!file) return;
      var reader = new FileReader();
      reader.onload = function(){
        textarea.value = String(reader.result || "");
        textarea.dispatchEvent(new Event("input", { bubbles: true }));
        textarea.dispatchEvent(new Event("change", { bubbles: true }));
        try { pushLog({ message: "Импорт: " + baseName + " (" + file.name + ")", type: "success", time: new Date() }); } catch(_) {}
      };
      reader.readAsText(file);
      input.value = "";
    });

    btnExport.addEventListener("click", function(){
      downloadText(baseName + ".txt", textarea.value || "");
      try { pushLog({ message: "Экспорт: " + baseName + ".txt", type: "info", time: new Date() }); } catch(_) {}
    });

    wrap.appendChild(btnImport);
    wrap.appendChild(btnExport);
    wrap.appendChild(input);
    textarea.insertAdjacentElement("afterend", wrap);
  }

  function findGlossaryTextareaFallback() {
    var nodes = Array.from(document.querySelectorAll("div,span,h1,h2,h3,h4,label"));
    var hit = nodes.find(function(n){ return (n.textContent || "").includes("Промпт глоссария"); });
    if (!hit) return null;
    var area = hit.parentElement && hit.parentElement.querySelector("textarea");
    return area || null;
  }

  function installPromptTools() {
    var tSystem = $("system-prompt");
    var tTranslation = $("translation-prompt");
    var tGlossary = $("glossary-prompt") || $("glossaryPrompt") || $("glossary-prompt-textarea") || findGlossaryTextareaFallback();

    if (tSystem) addFileTools(tSystem, "system_prompt");
    if (tTranslation) addFileTools(tTranslation, "translation_prompt");
    if (tGlossary) addFileTools(tGlossary, "glossary_prompt");
  }

  function boot() {
    installLogHooks();
    installPromptTools();
    try { pushLog({ message: "Extras patch V3 активирован (fast log)", type: "success", time: new Date() }); } catch(_) {}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();
</script>




<script id="PATCH_DBG_KEYS_V3">
(function(){
  "use strict";

  // ---- debug logger (goes into your UI log()) ----
  var DBG = { on:true, seq:0, t0:Date.now(), last:null, rep:0 };
  function ms(){ return Date.now() - DBG.t0; }
  function shortKey(k){
    if (!k) return "null";
    var s = String(k);
    return s.length + ":" + s.slice(0,2) + "…" + s.slice(-2); // не палим ключ
  }
  function d(msg, type){
    if (!DBG.on) return;
    try{
      var line = "[DBG +" + ms() + "ms #" + (++DBG.seq) + "] " + msg;
      if (DBG.last === line) { DBG.rep++; return; }
      if (DBG.rep > 0 && typeof log === "function") {
        log(DBG.last + " (x" + (DBG.rep+1) + ")", "info");
      }
      DBG.last = line; DBG.rep = 0;
      if (typeof log === "function") log(line, type || "info");
    }catch(e){}
  }

  function getState(){ try { return (typeof state !== "undefined") ? state : null; } catch(e){ return null; } }
  function getPC(){ try { return (typeof PROVIDERS_CONFIG !== "undefined") ? PROVIDERS_CONFIG : null; } catch(e){ return null; } }
  function canGetKeys(){ try { return (typeof getKeys === "function"); } catch(e){ return false; } }
  function hasKM(){ try { return (typeof KeyManager !== "undefined"); } catch(e){ return false; } }

  function ensureKMForProvider(providerId){
    var st = getState();
    var pc = getPC();
    if (!st || !pc || !st.keys) return false;
    if (!hasKM() || !canGetKeys()) return false;

    var keys = [];
    try { keys = getKeys(providerId) || []; } catch(e){ keys = []; }

    var have = Array.isArray(keys) ? keys.length : 0;

    // Если ключей нет — честно логируем
    if (have <= 0) {
      d("ensureKM: provider=" + providerId + " getKeys.len=0", "warning");
      return false;
    }

    var km = st.keys[providerId];

    // если keyManager отсутствует или пустой — создаём/пересоздаём
    try {
      var needCreate = !km || typeof km.count !== "function";
      var needRecreate = false;
      if (!needCreate) {
        var c = km.count();
        if (c <= 0) needRecreate = true;
      }

      if (needCreate || needRecreate) {
        st.keys[providerId] = new KeyManager(keys, pc[providerId].resetPolicy, providerId, null);
        d((needCreate ? "Создан" : "Пересоздан") + " KeyManager provider=" + providerId + " keys=" + have, "success");
        return true;
      } else {
        d("KeyManager OK provider=" + providerId + " km.count=" + km.count() + " getKeys.len=" + have, "info");
        return true;
      }
    } catch(e) {
      d("ensureKM error provider=" + providerId + " err=" + (e && e.message ? e.message : e), "error");
      return false;
    }
  }

  function patchKMLogging(providerId){
    var st = getState();
    if (!st || !st.keys) return false;
    var km = st.keys[providerId];
    if (!km || km.__dbgPatchedV3) return false;
    km.__dbgPatchedV3 = true;

    if (typeof km.acquireKey === "function"){
      var origA = km.acquireKey.bind(km);
      km.acquireKey = async function(modelId){
        var keysLen = (Array.isArray(this._keys) ? this._keys.length : -1);
        var leased = (this._leased && this._leased.size) ? this._leased.size : 0;

        var pausedCount = 0;
        try {
          var pm = this._paused && this._paused.get ? this._paused.get(modelId) : null;
          pausedCount = pm && pm.size ? pm.size : 0;
        } catch(_){}

        var exhaustedCount = 0;
        try {
          var exm = this._exhausted && this._exhausted.get ? this._exhausted.get(modelId) : null;
          exhaustedCount = exm && exm.size ? exm.size : 0;
        } catch(_){}

        d(providerId + ".acquireKey(model=" + modelId + ") keys=" + keysLen +
          " leased=" + leased + " paused=" + pausedCount + " exhausted=" + exhaustedCount, "info");

        var lease = await origA(modelId);

        if (!lease) {
          d(providerId + ".acquireKey -> null", "warning");
          return null;
        }
        d(providerId + ".acquireKey -> idx=" + (lease.index+1) + "/" + keysLen + " key=" + shortKey(lease.key), "success");
        return lease;
      };
    }

    if (typeof km.pauseKeyFor === "function"){
      var origP = km.pauseKeyFor.bind(km);
      km.pauseKeyFor = async function(modelId, apiKey, delayMs){
        d(providerId + ".pauseKeyFor model=" + modelId + " key=" + shortKey(apiKey) + " delayMs=" + delayMs, "warning");
        return await origP(modelId, apiKey, delayMs);
      };
    }

    if (typeof km.markExhaustedFor === "function"){
      var origE = km.markExhaustedFor.bind(km);
      km.markExhaustedFor = async function(modelId, apiKey){
        d(providerId + ".markExhaustedFor model=" + modelId + " key=" + shortKey(apiKey), "error");
        return await origE(modelId, apiKey);
      };
    }

    if (typeof km.incrementRequestFor === "function"){
      var origI = km.incrementRequestFor.bind(km);
      km.incrementRequestFor = async function(modelId, apiKey, rpd){
        d(providerId + ".incrementRequestFor model=" + modelId + " key=" + shortKey(apiKey) + " rpd=" + rpd, "info");
        return await origI(modelId, apiKey, rpd);
      };
    }

    d("DBG patch KM logging enabled for " + providerId, "success");
    return true;
  }

  function patchCallAI(){
    var fn = null;
    try { fn = (typeof callAI === "function") ? callAI : null; } catch(e){ fn = null; }
    if (!fn || fn.__dbgWrappedV3) return false;

    var wrapped = async function(prompt){
      try{
        var st = getState();
        var pid = st ? st.provider : null;
        var km = (st && st.keys) ? st.keys[pid] : null;
        var kmCount = (km && typeof km.count === "function") ? km.count() : -1;
        var keysLen = -1;
        try { keysLen = (canGetKeys() && pid) ? getKeys(pid).length : -1; } catch(_){}
        d("callAI provider=" + pid + " km.count=" + kmCount + " getKeys.len=" + keysLen +
          " promptLen=" + (prompt ? String(prompt).length : 0), "info");
      } catch(_) {}
      return await fn.apply(this, arguments);
    };

    // ставим на window, чтобы точно применилось
    try { window.callAI = wrapped; window.callAI.__dbgWrappedV3 = true; } catch(_) {}
    try { callAI = wrapped; } catch(_) {} // если не получится — ок

    d("callAI wrapped (debug)", "success");
    return true;
  }

  function tick(){
    var st = getState();
    if (!st) return;

    // текущий провайдер
    if (st.provider) {
      ensureKMForProvider(st.provider);
      patchKMLogging(st.provider);
    }

    // также пытаемся обернуть callAI
    patchCallAI();
  }

  function boot(){
    d("PATCH_DBG_KEYS_V3 boot", "success");

    var tries = 0;
    var t = setInterval(function(){
      tries++;
      tick();
      if (tries > 80) clearInterval(t);
    }, 200);

    window.DBG_ON = function(){ DBG.on = true; d("DBG_ON()", "success"); };
    window.DBG_OFF = function(){ d("DBG_OFF()", "warning"); DBG.on = false; };
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();
</script>


<script id="PATCH_FULL_LOG_DOWNLOAD_V1">
(function(){
  "use strict";

  // Полный лог (без ограничений по строкам).
  // ВНИМАНИЕ: совсем без лимитов можно теоретически забить память.
  // Поэтому тут есть ОЧЕНЬ высокий предохранитель по объёму (по умолчанию 30MB).
  var MAX_BYTES = 30 * 1024 * 1024;

  window.__FULL_LOG = window.__FULL_LOG || {
    lines: [],
    bytes: 0,
    dropped: false
  };

  function toTime(t){
    try { return new Date(t || Date.now()).toLocaleTimeString(); }
    catch(_) { return ""; }
  }

  function safeStr(x){
    if (x === null || x === undefined) return "";
    return String(x);
  }

  function appendFull(line){
    try {
      if (window.__FULL_LOG.dropped) return;

      // +1 на \n
      var add = line.length + 1;
      if (window.__FULL_LOG.bytes + add > MAX_BYTES) {
        window.__FULL_LOG.dropped = true;
        window.__FULL_LOG.lines.push("[WARN] FULL LOG reached MAX_BYTES (" + MAX_BYTES + "), logging stopped to avoid crash.");
        return;
      }

      window.__FULL_LOG.lines.push(line);
      window.__FULL_LOG.bytes += add;
    } catch(_) {}
  }

  // Публичная функция для скачивания полного лога
  window.downloadFullLogTxt = function(){
    try {
      var text = window.__FULL_LOG.lines.join("\n");
      var blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      var a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "translation_full_log.txt";
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){
        try { URL.revokeObjectURL(a.href); } catch(_) {}
        try { a.remove(); } catch(_) {}
      }, 1000);
    } catch(e) {
      // если что — попробуем хотя бы сообщить в UI лог
      try { if (typeof log === "function") log("Не удалось скачать лог: " + (e.message || e), "error"); } catch(_) {}
    }
  };

  // Добавим кнопку "Скачать лог" рядом с "Очистить"
  function addDownloadButton(){
    // ищем кнопку/ссылку с текстом "Очистить"
    var candidates = Array.from(document.querySelectorAll("button,a,div,span"))
      .filter(function(el){
        var txt = (el.textContent || "").trim();
        return txt === "Очистить";
      });

    if (!candidates.length) return false;

    // возьмём первую “Очистить”
    var clearEl = candidates[0];

    // если уже добавляли — не добавляем второй раз
    if (clearEl.parentElement && clearEl.parentElement.querySelector("[data-full-log-download-btn='1']")) {
      return true;
    }

    var btn = document.createElement(clearEl.tagName.toLowerCase());
    btn.setAttribute("type", "button");
    btn.textContent = "Скачать лог";
    btn.setAttribute("data-full-log-download-btn", "1");

    // попытка сохранить стиль кнопки
    btn.className = clearEl.className || "";
    btn.style.cssText = clearEl.style.cssText || "";

    // если у "Очистить" нет классов/стилей — зададим нейтральный
    if (!btn.className && !btn.style.cssText) {
      btn.className = "px-3 py-2 rounded-xl bg-white/10 border border-white/20 text-sm";
    }

    btn.addEventListener("click", function(){
      window.downloadFullLogTxt();
    });

    // вставим рядом
    clearEl.insertAdjacentElement("beforebegin", btn);

    // небольшой отступ, если нужно
    btn.style.marginRight = "8px";

    return true;
  }

  // Хук 1: eventBus.emit('log', {message,type,time})
  function hookEventBus(){
    try {
      if (window.eventBus && typeof window.eventBus.emit === "function" && !window.eventBus.__fullLogPatchedV1) {
        var origEmit = window.eventBus.emit.bind(window.eventBus);
        window.eventBus.emit = function(name, payload){
          try {
            if (name === "log") {
              var msg = (payload && typeof payload === "object") ? (payload.message ?? payload.msg ?? JSON.stringify(payload)) : safeStr(payload);
              var type = (payload && payload.type) ? payload.type : "info";
              var time = (payload && payload.time) ? payload.time : Date.now();
              appendFull("[" + toTime(time) + "] " + type + ": " + safeStr(msg));
            }
          } catch(_) {}
          return origEmit(name, payload);
        };
        window.eventBus.__fullLogPatchedV1 = true;
        return true;
      }
    } catch(_) {}
    return false;
  }

  // Хук 2: оборачиваем глобальную log(message,type)
  function hookLogFn(){
    try {
      if (typeof window.log === "function" && !window.__fullLogWrappedLogV1) {
        var origLog = window.log;
        window.log = function(message, type){
          try {
            appendFull("[" + toTime(Date.now()) + "] " + (type || "info") + ": " + safeStr(message));
          } catch(_) {}
          return origLog.apply(this, arguments);
        };
        window.__fullLogWrappedLogV1 = true;
        return true;
      }
    } catch(_) {}
    return false;
  }

  function boot(){
    // добавим стартовую строку
    appendFull("[" + toTime(Date.now()) + "] info: Full-log download patch enabled");

    // хуки могут появиться позже — попробуем несколько раз
    var tries = 0;
    var t = setInterval(function(){
      tries++;
      hookEventBus();
      hookLogFn();
      addDownloadButton();
      if (tries > 60) clearInterval(t);
    }, 200);

    // и ещё раз после загрузки DOM
    setTimeout(addDownloadButton, 1500);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();
</script>


<script id="PATCH_GEMINI_GLOBAL_BACKOFF_V1">
(function(){
  "use strict";

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // анти-спам логов
  var _lastMsg = "";
  var _lastAt = 0;
  function logOnce(msg, type){
    try{
      var now = Date.now();
      if (msg === _lastMsg && (now - _lastAt) < 1500) return;
      _lastMsg = msg; _lastAt = now;
      if (typeof log === "function") log(msg, type || "info");
    } catch(_) {}
  }

  function patchKM(providerId, km){
    if (!km || km.__globalBackoffPatchedV1) return;
    km.__globalBackoffPatchedV1 = true;

    // modelId -> timestamp (ms)
    km._globalPauseUntilByModel = km._globalPauseUntilByModel || new Map();

    // 1) Оборачиваем pauseKeyFor: если пауза >= 5s — считаем её глобальной для Gemini
    if (typeof km.pauseKeyFor === "function"){
      var origPause = km.pauseKeyFor.bind(km);
      km.pauseKeyFor = async function(modelId, apiKey, delayMs){
        try{
          if ((providerId === "gemini" || providerId === "gemini_top") && typeof delayMs === "number" && delayMs >= 5000){
            var until = Date.now() + delayMs;
            var prev = km._globalPauseUntilByModel.get(modelId) || 0;
            if (until > prev) km._globalPauseUntilByModel.set(modelId, until);
            logOnce("⏸️ Gemini глобальная пауза " + Math.ceil((until-Date.now())/1000) + "s (модель " + modelId + ")", "warning");
          }
        }catch(_){}
        return await origPause(modelId, apiKey, delayMs);
      };
    }

    // 2) Оборачиваем acquireKey: если глобальная пауза активна — ждём, а не перебираем ключи
    if (typeof km.acquireKey === "function"){
      var origAcquire = km.acquireKey.bind(km);
      km.acquireKey = async function(modelId){
        modelId = modelId || null;

        // глобальная пауза
        if (providerId === "gemini" || providerId === "gemini_top"){
          try{
            var until = km._globalPauseUntilByModel.get(modelId) || 0;
            var now = Date.now();
            if (until > now){
              var wait = (until - now) + Math.floor(Math.random()*250);
              logOnce("⏳ Жду глобальный лимит Gemini: " + Math.ceil(wait/1000) + "s", "warning");
              await sleep(wait);
            }
          } catch(_){}
        }

        // если после ожидания всё равно null — делаем несколько редких ретраев внутри acquireKey
        for (var i=0; i<6; i++){
          var lease = await origAcquire(modelId);
          if (lease) return lease;
          await sleep(250 + i*150);
        }
        return null;
      };
    }

    logOnce("✅ Global backoff patch применён к KeyManager: " + providerId, "success");
  }

  function tick(){
    try{
      if (typeof state === "undefined" || !state || !state.keys) return;
      if (!state.keys.gemini && !state.keys.gemini_top) return;

      if (state.keys.gemini) patchKM("gemini", state.keys.gemini);
      if (state.keys.gemini_top) patchKM("gemini_top", state.keys.gemini_top);
    }catch(_){}
  }

  var tries = 0;
  var t = setInterval(function(){
    tries++;
    tick();
    if (tries > 200) clearInterval(t);
  }, 200);

})();
</script>


<script id="PATCH_FULL_LOG_BOM_V1">
(function(){
  // Переопределяем скачивание: добавляем UTF-8 BOM, чтобы Android/Windows корректно определяли кодировку
  function downloadWithBom(filename, text){
    var bom = "\ufeff";
    var blob = new Blob([bom + String(text || "")], { type: "text/plain;charset=utf-8" });
    var a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(function(){
      try { URL.revokeObjectURL(a.href); } catch(_) {}
      try { a.remove(); } catch(_) {}
    }, 1000);
  }

  // если уже есть __FULL_LOG — используем её
  window.downloadFullLogTxt = function(){
    try{
      var lines = (window.__FULL_LOG && Array.isArray(window.__FULL_LOG.lines)) ? window.__FULL_LOG.lines : [];
      var text = lines.join("\n");
      downloadWithBom("translation_full_log.txt", text);
      try { if (typeof log === "function") log("✅ Лог скачан (UTF-8 BOM)", "success"); } catch(_) {}
    }catch(e){
      try { if (typeof log === "function") log("❌ Не удалось скачать лог: " + (e.message||e), "error"); } catch(_) {}
    }
  };
})();
</script>

</body>
</html>
